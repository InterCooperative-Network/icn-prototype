# Project Directory Structure (up to depth 2):
icn-prototype/
    requirements.txt
    pytest.ini
    concatenate_code_files.py
    setup.py
    .coverage
    did/
        did.py
        __init__.py
    .pytest_cache/
        CACHEDIR.TAG
        .gitignore
        README.md
        v/
    icn_env/
        pyvenv.cfg
        bin/
            pip
            activate
            flake8
            coverage
            python3
            coverage3
            activate.csh
            black
            normalizer
            python
            pip3.12
            pycodestyle
            pytest
            Activate.ps1
            blackd
            pip3
            py.test
            activate.fish
            flask
            coverage-3.12
            python3.12
            pyflakes
        include/
        lib/
    api/
        server.py
        __init__.py
    tests/
        __init__.py
        integration/
            test_consensus_mechanism.py
            test_block_creation.py
            test_shard_management.py
            test_transaction_processing.py
            test_smart_contract_execution.py
            __init__.py
        performance/
            test_scalability.py
            test_stress_resilience.py
            test_load_handling.py
            __init__.py
        __pycache__/
            __init__.cpython-312.pyc
        unit/
            test_proof_of_cooperation.py
            test_contract_executor.py
            test_block.py
            test_shard.py
            test_node.py
            test_transaction.py
            test_blockchain.py
            test_smart_contract.py
            __init__.py
    system/
        marketplace.py
        reputation.py
        governance.py
        storage.py
        __init__.py
    blockchain/
        blockchain.py
        blockchain.py.backup
        __init__.py
        utils/
            metrics.py
            validation.py
            __init__.py
            crypto.py
        core/
            node.py
            block.py
            transaction.py
            shard.py
            blockchain.py
            __init__.py
        __pycache__/
            __init__.cpython-312.pyc
        contracts/
            contract_executor.py
            smart_contract.py
            __init__.py
        consensus/
            proof_of_cooperation.py
            __init__.py
    .git/
        COMMIT_EDITMSG
        config
        HEAD
        FETCH_HEAD
        ORIG_HEAD
        index
        description
        objects/
        refs/
        branches/
        hooks/
            prepare-commit-msg.sample
            sendemail-validate.sample
            update.sample
            pre-rebase.sample
            pre-receive.sample
            pre-commit.sample
            push-to-checkout.sample
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-push.sample
            pre-merge-commit.sample
            pre-applypatch.sample
        logs/
            HEAD
        info/
            exclude


# Code Files Concatenation:



# ==================== /home/matt/icn-prototype/concatenate_code_files.py ====================

import os


def tree_structure(startpath, max_depth=2):
    tree_str = ""
    start_depth = startpath.rstrip(os.path.sep).count(os.path.sep)
    for root, dirs, files in os.walk(startpath):
        depth = root.count(os.path.sep) - start_depth
        if depth > max_depth:
            continue
        indent = " " * 4 * depth
        tree_str += f"{indent}{os.path.basename(root)}/\n"
        sub_indent = " " * 4 * (depth + 1)
        for file in files:
            tree_str += f"{sub_indent}{file}\n"
    return tree_str


def concatenate_code_files(source_dir, output_file, extensions=None, max_depth=2):
    if extensions is None:
        extensions = [".py", ".rs", ".js", ".ts", ".c"]  # Only most relevant extensions

    # Generate the tree structure
    tree_str = tree_structure(source_dir, max_depth=max_depth)

    with open(output_file, "w", encoding="utf-8") as outfile:
        outfile.write(
            "# Project Directory Structure (up to depth {}):\n".format(max_depth)
        )
        outfile.write(tree_str)
        outfile.write("\n\n# Code Files Concatenation:\n\n")

        # Walk through the directory to find and concatenate code files
        for root, dirs, files in os.walk(source_dir):
            # Exclude temp and irrelevant directories, including 'icn_env'
            dirs[:] = [
                d
                for d in dirs
                if d
                not in [
                    "__pycache__",
                    ".git",
                    "node_modules",
                    "build",
                    "dist",
                    "venv",
                    ".idea",
                    "icn_env",
                ]
            ]

            for file in files:
                file_path = os.path.join(root, file)

                # Skip non-relevant extensions
                if not any(file.endswith(ext) for ext in extensions):
                    continue

                try:
                    # Skip files larger than 50 KB
                    if os.path.getsize(file_path) > 50 * 1024:
                        continue

                    # Check for binary content
                    with open(file_path, "rb") as binary_check:
                        if b"\0" in binary_check.read(1024):
                            continue

                    with open(
                        file_path, "r", encoding="utf-8", errors="ignore"
                    ) as infile:
                        outfile.write(f"\n\n# {'='*20} {file_path} {'='*20}\n\n")
                        outfile.write(infile.read())
                except Exception as e:
                    print(f"Error reading {file_path}: {e}")

    print(f"Concatenation complete! Check the output file: {output_file}")


# Example usage
concatenate_code_files("/home/matt/icn-prototype", "ICN_code_dump.txt", max_depth=2)


# ==================== /home/matt/icn-prototype/setup.py ====================

# setup.py

from setuptools import setup, find_packages

setup(
    name="icn-prototype",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        'pycryptodome',         # for cryptographic operations
        'cryptography',         # for additional crypto functionality
        'flask',               # for the API
        'flask-jwt-extended',  # for JWT auth
        'werkzeug',           # for utilities
        'pytest',             # for testing
    ],
    python_requires='>=3.8',
)

# ==================== /home/matt/icn-prototype/did/did.py ====================

# did/did.py
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional
import logging
from datetime import datetime
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)


@dataclass
class Credential:
    """Verifiable credential for the ICN system."""

    issuer: str
    subject: str
    claims: Dict
    issued_at: datetime = field(default_factory=datetime.now)
    expires_at: Optional[datetime] = None
    proof: Optional[Dict] = None

    def verify(self) -> bool:
        """Verify the credential's cryptographic proof."""
        if not self.proof:
            return False
        # Implement cryptographic verification
        return True

    def revoke(self) -> None:
        """Revoke the credential."""
        self.expires_at = datetime.now()


class IdentityProvider(ABC):
    """Abstract base class for identity providers."""

    @abstractmethod
    def issue_credential(self, subject: str, claims: Dict) -> Credential:
        pass

    @abstractmethod
    def verify_credential(self, credential: Credential) -> bool:
        pass


class DID:
    """Decentralized Identifier implementation for ICN."""

    def __init__(self, cooperative_id: Optional[str] = None):
        self._private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048
        )
        self._public_key = self._private_key.public_key()
        self.cooperative_memberships: List[str] = []
        self.reputation_scores: Dict[str, float] = {}
        self.credentials: List[Credential] = []
        self.metadata: Dict = {}
        if cooperative_id:
            self.add_cooperative_membership(cooperative_id)

        # Create encryption key for sensitive data
        self._encryption_key = Fernet.generate_key()
        self._cipher_suite = Fernet(self._encryption_key)

    def generate_did(self) -> str:
        """Generate the DID string."""
        pub_bytes = self._public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        return f"did:icn:{hashlib.sha256(pub_bytes).hexdigest()[:16]}"

    def encrypt_data(self, data: str) -> bytes:
        """Encrypt data using the public key."""
        try:
            return self._public_key.encrypt(
                data.encode(),
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None,
                ),
            )
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            raise

    def decrypt_data(self, encrypted_data: bytes) -> str:
        """Decrypt data using the private key."""
        try:
            decrypted = self._private_key.decrypt(
                encrypted_data,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None,
                ),
            )
            return decrypted.decode()
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise

    def add_cooperative_membership(self, cooperative_id: str) -> None:
        """Add membership to a cooperative."""
        if cooperative_id not in self.cooperative_memberships:
            self.cooperative_memberships.append(cooperative_id)
            logger.info(f"Added membership to cooperative: {cooperative_id}")

    def update_reputation(
        self, category: str, score: float, evidence: Optional[Dict] = None
    ) -> None:
        """Update reputation score with optional evidence."""
        if score < 0:
            logger.warning(f"Negative reputation score update: {score}")

        old_score = self.reputation_scores.get(category, 0)
        self.reputation_scores[category] = old_score + score

        if evidence:
            if "reputation_evidence" not in self.metadata:
                self.metadata["reputation_evidence"] = {}
            self.metadata["reputation_evidence"][category] = evidence

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def export_public_credentials(self) -> Dict:
        """Export public credentials and memberships."""
        return {
            "did": self.generate_did(),
            "cooperative_memberships": self.cooperative_memberships,
            "reputation_scores": self.reputation_scores,
            "public_credentials": [
                {k: v for k, v in c.__dict__.items() if k != "proof"}
                for c in self.credentials
            ],
        }


class DIDRegistry:
    """Registry for DIDs in the ICN system."""

    def __init__(self):
        self.dids: Dict[str, DID] = {}
        self.revoked_dids: Dict[str, datetime] = {}
        self._identity_providers: Dict[str, IdentityProvider] = {}

    def register_did(self, did: DID) -> str:
        """Register a new DID."""
        did_id = did.generate_did()
        if did_id in self.revoked_dids:
            raise ValueError(f"DID {did_id} has been revoked")
        self.dids[did_id] = did
        logger.info(f"Registered new DID: {did_id}")
        return did_id

    def resolve_did(self, did_id: str) -> Optional[DID]:
        """Resolve a DID to its full object."""
        if did_id in self.revoked_dids:
            logger.warning(f"Attempted to resolve revoked DID: {did_id}")
            return None
        return self.dids.get(did_id)

    def verify_did(self, did_id: str) -> bool:
        """Verify a DID's validity."""
        if did_id in self.revoked_dids:
            return False
        return did_id in self.dids

    def revoke_did(self, did_id: str, reason: str) -> None:
        """Revoke a DID."""
        if did_id in self.dids:
            self.revoked_dids[did_id] = datetime.now()
            del self.dids[did_id]
            logger.warning(f"DID revoked: {did_id}, reason: {reason}")

    def register_identity_provider(self, name: str, provider: IdentityProvider) -> None:
        """Register a new identity provider."""
        self._identity_providers[name] = provider
        logger.info(f"Registered identity provider: {name}")

    def get_identity_provider(self, name: str) -> Optional[IdentityProvider]:
        """Get an identity provider by name."""
        return self._identity_providers.get(name)


# ==================== /home/matt/icn-prototype/did/__init__.py ====================



# ==================== /home/matt/icn-prototype/api/server.py ====================

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


from flask import Flask, request, jsonify
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
from blockchain.blockchain import Blockchain
from did.did import DID, DIDRegistry
from system.governance import Governance, Proposal
from system.marketplace import Marketplace
from system.storage import DistributedStorage

app = Flask(__name__)
app.config["JWT_SECRET_KEY"] = "your_jwt_secret_key"  # Replace with a secure key
jwt = JWTManager(app)

blockchain = Blockchain()
did_registry = DIDRegistry()
governance = Governance(blockchain)
marketplace = Marketplace(blockchain, did_registry)
storage = DistributedStorage(blockchain)

users_db = {}


def role_required(required_role):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            current_user = get_jwt_identity()
            if current_user["role"] != required_role:
                return jsonify({"message": "Access forbidden: insufficient role"}), 403
            return f(*args, **kwargs)

        return wrapper

    return decorator


@app.route("/register", methods=["POST"])
def register():
    username = request.json.get("username")
    password = request.json.get("password")
    role = request.json.get("role", "user")

    if username in users_db:
        return jsonify({"message": "User already exists"}), 400

    did = DID()
    did_id = did_registry.register_did(did)

    hashed_password = generate_password_hash(password)
    users_db[username] = {"password": hashed_password, "role": role, "did": did_id}

    return (
        jsonify({"message": f"User {username} registered successfully", "did": did_id}),
        201,
    )


@app.route("/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")

    user = users_db.get(username)

    if not user or not check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid username or password"}), 401

    access_token = create_access_token(
        identity={"username": username, "role": user["role"], "did": user["did"]}
    )
    return jsonify(access_token=access_token), 200


@app.route("/create_proposal", methods=["POST"])
@jwt_required()
def create_proposal():
    current_user = get_jwt_identity()
    proposal_data = request.json
    proposal = Proposal(
        id=f"proposal_{len(governance.proposals) + 1}",
        title=proposal_data["title"],
        description=proposal_data["description"],
        creator=current_user["did"],
        proposal_type=proposal_data["type"],
        options=proposal_data.get("options"),
        amount=proposal_data.get("amount"),
        stages=proposal_data.get("stages"),
    )
    proposal_id = governance.create_proposal(proposal)
    return jsonify({"message": "Proposal created", "proposal_id": proposal_id}), 201


@app.route("/vote", methods=["POST"])
@jwt_required()
def vote():
    current_user = get_jwt_identity()
    proposal_id = request.json.get("proposal_id")
    vote = request.json.get("vote")
    voting_power = request.json.get("voting_power", 1)

    if governance.cast_vote(proposal_id, vote, current_user["did"], voting_power):
        return jsonify({"message": "Vote cast successfully"}), 200
    return jsonify({"message": "Failed to cast vote"}), 400


@app.route("/finalize_proposal", methods=["POST"])
@jwt_required()
@role_required("admin")
def finalize_proposal():
    proposal_id = request.json.get("proposal_id")

    if governance.finalize_proposal(proposal_id):
        return jsonify({"message": "Proposal finalized successfully"}), 200
    return jsonify({"message": "Failed to finalize proposal"}), 400


@app.route("/create_listing", methods=["POST"])
@jwt_required()
def create_listing():
    current_user = get_jwt_identity()
    listing_data = request.json
    listing_id = marketplace.create_listing(
        f"listing_{len(marketplace.listings) + 1}",
        current_user["did"],
        listing_data["item"],
        listing_data["price"],
    )
    if listing_id:
        return jsonify({"message": "Listing created", "listing_id": listing_id}), 201
    return jsonify({"message": "Failed to create listing"}), 400


@app.route("/place_order", methods=["POST"])
@jwt_required()
def place_order():
    current_user = get_jwt_identity()
    order_data = request.json
    order_id = f"order_{len(marketplace.orders) + 1}"
    if marketplace.place_order(order_id, current_user["did"], order_data["listing_id"]):
        return jsonify({"message": "Order placed", "order_id": order_id}), 201
    return jsonify({"message": "Failed to place order"}), 400


@app.route("/complete_order", methods=["POST"])
@jwt_required()
def complete_order():
    order_id = request.json.get("order_id")
    completed_order = marketplace.complete_order(order_id)
    if completed_order:
        return (
            jsonify({"message": "Order completed", "order": completed_order.__dict__}),
            200,
        )
    return jsonify({"message": "Failed to complete order"}), 400


@app.route("/store_file", methods=["POST"])
@jwt_required()
def store_file():
    file = request.files["file"]
    file_hash = storage.store_file(file.filename, file.read())
    return jsonify({"message": "File stored", "file_hash": file_hash}), 201


@app.route("/retrieve_file/<file_hash>", methods=["GET"])
@jwt_required()
def retrieve_file(file_hash):
    file_data = storage.retrieve_file(file_hash)
    if file_data:
        return file_data, 200
    return jsonify({"message": "File not found"}), 404


if __name__ == "__main__":
    app.run(debug=True)


# ==================== /home/matt/icn-prototype/api/__init__.py ====================



# ==================== /home/matt/icn-prototype/tests/__init__.py ====================

# tests/__init__.py
"""Test suite for the ICN blockchain."""

# ==================== /home/matt/icn-prototype/tests/integration/test_consensus_mechanism.py ====================

import unittest
from datetime import datetime, timedelta
from typing import List

# Adjust imports based on your project structure
from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
from blockchain.core.node import Node
from blockchain.core.block import Block
from blockchain.core.transaction import Transaction

class TestConsensusMechanism(unittest.TestCase):
    """Test suite for the ICN Proof of Cooperation consensus mechanism."""

    def setUp(self):
        """Set up the consensus mechanism and initial test data."""
        self.consensus = ProofOfCooperation(min_reputation=10.0, cooldown_blocks=3)
        self.nodes = self._create_test_nodes()
        
        # Create a genesis block
        self.genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now() - timedelta(minutes=10),
            transactions=[],
            validator="genesis",
            shard_id=1
        )

    def _create_test_node(self, node_id: str, reputation_score: float = 25.0) -> Node:
        """Create a test node with predefined characteristics."""
        node = Node(node_id=node_id, cooperative_id="test_coop", initial_stake=100.0)

        # Assign reputation scores
        for category in node.reputation_scores:
            node.reputation_scores[category] = reputation_score

        # Assign validation history
        node.validation_history = [
            {"timestamp": datetime.now() - timedelta(minutes=i),
             "category": "validation", "score_change": 1.0, "evidence": {"success": True}}
            for i in range(20)
        ]

        # Assign performance metrics
        node.performance_metrics = {
            "availability": 98.0,
            "validation_success_rate": 95.0,
            "network_reliability": 97.0
        }

        # Set node state
        node.metadata["status"] = "active"
        node.cooldown = 0

        # Assign shard
        node.assign_to_shard(1)

        # Add cooperative interactions
        node.cooperative_interactions = [f"coop_{i}" for i in range(30)]

        return node

    def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
        """Create a list of test nodes with varying characteristics."""
        nodes = []
        for i in range(num_nodes):
            reputation = 25.0 + (i * 5.0)
            node = self._create_test_node(f"node_{i}", reputation)
            nodes.append(node)
        return nodes

    def _create_test_block(self, transactions: List[Transaction]) -> Block:
        """Create a test block with predefined transactions."""
        return Block(
            index=self.genesis_block.index + 1,
            previous_hash=self.genesis_block.hash,
            timestamp=datetime.now(),
            transactions=transactions,
            validator="test_validator",
            shard_id=1
        )

    def test_initialization(self):
        """Test initialization of the consensus mechanism."""
        self.assertEqual(self.consensus.min_reputation, 10.0)
        self.assertEqual(self.consensus.cooldown_blocks, 3)
        self.assertGreater(len(self.consensus.reputation_weights), 0)
        self.assertGreater(len(self.consensus.validation_thresholds), 0)

    def test_validator_selection(self):
        """Test the process of selecting a validator."""
        validator = self.consensus.select_validator(self.nodes)
        self.assertIsNotNone(validator)
        self.assertIn(validator, self.nodes)

        # Test selection with specific shard
        shard_validator = self.consensus.select_validator(self.nodes, shard_id=1)
        self.assertIsNotNone(shard_validator)

        # Test selection when all nodes are in cooldown
        for node in self.nodes:
            node.enter_cooldown(3)
        no_validator = self.consensus.select_validator(self.nodes)
        self.assertIsNone(no_validator)

        # Test selection with varying reputation scores
        for node in self.nodes:
            node.cooldown = 0
        high_rep_node = self._create_test_node("high_rep", 100.0)
        self.nodes.append(high_rep_node)

        selection_counts = {node.node_id: 0 for node in self.nodes}
        for _ in range(100):
            selected = self.consensus.select_validator(self.nodes)
            if selected:
                selection_counts[selected.node_id] += 1

        self.assertGreater(selection_counts["high_rep"], selection_counts["node_0"])

    def test_cooperation_score_calculation(self):
        """Test calculation of cooperation scores."""
        node = self._create_test_node("test_node")

        score = self.consensus.calculate_cooperation_score(node)
        self.assertGreater(score, 0)

        # Test with lower reputation
        for category in node.reputation_scores:
            node.reputation_scores[category] = 5.0
        low_score = self.consensus.calculate_cooperation_score(node)
        self.assertLess(low_score, score)

        # Test with limited cooperative interactions
        node.cooperative_interactions = ["coop_1"] * 30
        limited_score = self.consensus.calculate_cooperation_score(node)
        self.assertLess(limited_score, score)

        # Test with lower performance metrics
        node.performance_metrics["availability"] = 50.0
        poor_score = self.consensus.calculate_cooperation_score(node)
        self.assertLess(poor_score, score)

    def test_block_validation(self):
        """Test the block validation process."""
        validator = self._create_test_node("test_validator")

        transactions = [
            Transaction(
                sender=f"sender_{i}",
                receiver=f"receiver_{i}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(3)
        ]

        valid_block = self._create_test_block(transactions)
        self.assertTrue(self.consensus.validate_block(valid_block, self.genesis_block, validator))

        # Test with an invalid timestamp
        invalid_block = self._create_test_block(transactions)
        invalid_block.timestamp = datetime.now() + timedelta(hours=1)
        self.assertFalse(self.consensus.validate_block(invalid_block, self.genesis_block, validator))

        # Test with a validator having insufficient reputation
        invalid_validator = self._create_test_node("invalid_validator", reputation_score=5.0)
        self.assertFalse(self.consensus.validate_block(valid_block, self.genesis_block, invalid_validator))

    def test_collusion_detection(self):
        """Test detection of collusion in transactions."""
        validator = self._create_test_node("test_validator")

        normal_transactions = [
            Transaction(
                sender=f"sender_{i}",
                receiver=f"receiver_{i}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(10)
        ]
        normal_block = self._create_test_block(normal_transactions)

        suspicious_transactions = [
            Transaction(
                sender="suspicious_sender",
                receiver=f"receiver_{i}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(10)
        ]
        suspicious_block = self._create_test_block(suspicious_transactions)

        self.assertFalse(self.consensus.detect_collusion(validator, normal_block))
        self.assertTrue(self.consensus.detect_collusion(validator, suspicious_block))

    def test_cooldown_mechanism(self):
        """Test the cooldown mechanism for validators."""
        validator = self._create_test_node("test_validator")

        selected = self.consensus.select_validator([validator])
        self.assertIsNotNone(selected)
        self.assertEqual(selected.cooldown, self.consensus.cooldown_blocks)

        # Ensure validator cannot be selected during cooldown
        new_selection = self.consensus.select_validator([validator])
        self.assertIsNone(new_selection)

        # Reset cooldown and test selection again
        validator.cooldown = 0
        final_selection = self.consensus.select_validator([validator])
        self.assertIsNotNone(final_selection)

    def test_validation_metrics(self):
        """Test tracking of validation metrics."""
        validator = self._create_test_node("test_validator")
        transactions = [
            Transaction(
                sender=f"sender_{i}",
                receiver=f"receiver_{i}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(3)
        ]

        for i in range(5):
            block = self._create_test_block(transactions)
            self.consensus.validate_block(block, self.genesis_block, validator)

        metrics = self.consensus.get_metrics()
        self.assertGreater(metrics["total_validations"], 0)
        self.assertGreater(metrics["successful_validations"], 0)
        self.assertGreaterEqual(metrics["success_rate"], 0)

    def test_shard_specific_validation(self):
        """Test validation in a shard-specific context."""
        validator = self._create_test_node("test_validator")

        self.assertTrue(validator.can_validate(shard_id=1))
        self.assertFalse(validator.can_validate(shard_id=2))

        # Ensure validator selection for a specific shard
        selected = self.consensus.select_validator(self.nodes, shard_id=1)
        if selected:
            self.assertIn(1, selected.shard_assignments)

    def test_progressive_reputation_requirements(self):
        """Test progressive reputation requirements for new nodes."""
        new_node = self._create_test_node("new_node")
        new_node.total_validations = 0

        # Set lower reputation
        for category in new_node.reputation_scores:
            new_node.reputation_scores[category] = self.consensus.min_reputation * 0.6

        self.assertTrue(self.consensus._can_participate(new_node))

        # Increase validations and recheck eligibility
        new_node.total_validations = 20
        self.assertFalse(self.consensus._can_participate(new_node))

    def test_validator_history(self):
        """Test tracking of validator history."""
        for _ in range(5):
            validator = self.consensus.select_validator(self.nodes)
            if validator:
                self.assertIn(
                    validator.node_id,
                    [record[0] for record in self.consensus.validator_history]
                )

        # Ensure history length is capped
        for _ in range(1000):
            self.consensus.validator_history.append(("test_node", datetime.now(), 1))
        self.assertLessEqual(len(self.consensus.validator_history), 1000)

if __name__ == '__main__':
    unittest.main()


# ==================== /home/matt/icn-prototype/tests/integration/test_block_creation.py ====================

# tests/integration/test_block_creation.py

import unittest
from datetime import datetime, timedelta
from typing import List

# Adjust imports based on your project structure
from blockchain.core.block import Block
from blockchain.core.transaction import Transaction
from blockchain.core.shard import Shard

class TestBlockCreation(unittest.TestCase):
    """Integration tests for block creation in the ICN blockchain."""

    def setUp(self):
        """Set up initial test conditions before each test."""
        self.shard = Shard(shard_id=1, max_transactions_per_block=5)
        self.sample_transactions = self._create_sample_transactions()

    def _create_sample_transactions(self) -> List[Transaction]:
        """Create a set of sample transactions for testing."""
        return [
            Transaction(
                sender=f"user{i}",
                receiver=f"user{i+1}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(10)
        ]

    def test_basic_block_creation(self):
        """Test basic block creation with valid transactions."""
        # Add transactions to shard
        for tx in self.sample_transactions[:5]:
            self.shard.add_transaction(tx)

        # Create block
        block = self.shard.create_block(validator="test_validator")
        self.assertIsNotNone(block, "Block creation failed")
        self.assertEqual(block.index, self.shard.height, "Block index mismatch")
        self.assertEqual(len(block.transactions), 5, "Unexpected number of transactions in block")
        self.assertEqual(block.validator, "test_validator", "Validator mismatch")

    def test_empty_block_creation(self):
        """Test block creation when there are no transactions."""
        block = self.shard.create_block(validator="test_validator")
        self.assertIsNone(block, "Block should not be created when no transactions are present")

    def test_max_transactions_per_block(self):
        """Test block creation with max transactions per block."""
        # Add max transactions to shard
        for tx in self.sample_transactions[:5]:
            self.shard.add_transaction(tx)

        block = self.shard.create_block(validator="test_validator")
        self.assertEqual(len(block.transactions), 5, "Block did not respect max transaction limit")

        # Add more transactions to shard
        for tx in self.sample_transactions[5:10]:
            self.shard.add_transaction(tx)

        # Ensure next block creation only includes 5 transactions
        block = self.shard.create_block(validator="test_validator")
        self.assertEqual(len(block.transactions), 5, "Block exceeded max transaction limit")

    def test_invalid_transaction_handling(self):
        """Test block creation with invalid transactions."""
        # Create an invalid transaction
        invalid_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0},
            shard_id=2  # Different shard
        )

        # Add invalid transaction to shard
        self.shard.add_transaction(invalid_tx)

        block = self.shard.create_block(validator="test_validator")
        self.assertIsNone(block, "Block should not be created with invalid transactions")

    def test_cross_shard_transaction_handling(self):
        """Test block creation with cross-shard transactions."""
        cross_shard_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0, "target_shard": 2},
            shard_id=1
        )
        self.shard.add_transaction(cross_shard_tx)

        block = self.shard.create_block(validator="test_validator")
        self.assertIsNotNone(block, "Block creation failed with cross-shard transaction")
        self.assertIn(cross_shard_tx, block.transactions, "Cross-shard transaction missing from block")

    def test_serialization_and_deserialization(self):
        """Test block serialization and deserialization after creation."""
        # Add transactions to shard and create a block
        for tx in self.sample_transactions[:5]:
            self.shard.add_transaction(tx)

        block = self.shard.create_block(validator="test_validator")
        block_dict = block.to_dict()

        # Deserialize the block
        new_block = Block.from_dict(block_dict)
        self.assertEqual(new_block.index, block.index, "Block index mismatch after deserialization")
        self.assertEqual(len(new_block.transactions), len(block.transactions), "Transaction count mismatch after deserialization")
        self.assertEqual(new_block.hash, block.hash, "Block hash mismatch after deserialization")

if __name__ == "__main__":
    unittest.main()


# ==================== /home/matt/icn-prototype/tests/integration/test_shard_management.py ====================

# tests/integration/test_shard_management.py

import unittest
from datetime import datetime, timedelta
from typing import List

# Adjust imports based on your project structure
from blockchain.core.shard import Shard
from blockchain.core.transaction import Transaction
from blockchain.core.block import Block

class TestShardManagement(unittest.TestCase):
    """Integration tests for shard management in the ICN blockchain."""

    def setUp(self):
        """Set up initial test conditions before each test."""
        self.shard = Shard(shard_id=1, max_transactions_per_block=5)
        self.sample_transactions = self._create_sample_transactions()

    def _create_sample_transactions(self) -> List[Transaction]:
        """Create a set of sample transactions for testing."""
        return [
            Transaction(
                sender=f"user{i}",
                receiver=f"user{i+1}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(10)
        ]

    def test_shard_initialization(self):
        """Test proper initialization of a shard."""
        self.assertEqual(self.shard.shard_id, 1, "Shard ID mismatch")
        self.assertEqual(len(self.shard.chain), 1, "Shard should start with a genesis block")
        self.assertEqual(self.shard.height, 1, "Initial shard height should be 1")
        self.assertEqual(self.shard.max_transactions_per_block, 5, "Max transactions per block mismatch")

    def test_transaction_assignment_to_shard(self):
        """Test that transactions are correctly assigned to the shard."""
        for tx in self.sample_transactions[:5]:
            self.shard.add_transaction(tx)
        
        self.assertEqual(len(self.shard.pending_transactions), 5, "Transaction count mismatch in shard")
        for tx in self.shard.pending_transactions:
            self.assertEqual(tx.shard_id, self.shard.shard_id, "Transaction assigned to incorrect shard")

    def test_cross_shard_references(self):
        """Test handling of cross-shard references."""
        cross_shard_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0, "target_shard": 2},
            shard_id=1
        )
        self.shard.add_transaction(cross_shard_tx)

        self.assertIn(2, self.shard.cross_shard_references, "Cross-shard reference not recorded")
        self.assertIn(
            cross_shard_tx.transaction_id,
            self.shard.cross_shard_references[2],
            "Cross-shard transaction ID not tracked"
        )

    def test_shard_serialization_and_deserialization(self):
        """Test shard serialization and deserialization."""
        # Add transactions and create a block
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        block = self.shard.create_block(validator="test_validator")
        self.shard.add_block(block)

        # Serialize the shard
        shard_dict = self.shard.to_dict()

        # Deserialize the shard
        new_shard = Shard.from_dict(shard_dict)

        self.assertEqual(new_shard.shard_id, self.shard.shard_id, "Shard ID mismatch after deserialization")
        self.assertEqual(new_shard.height, self.shard.height, "Shard height mismatch after deserialization")
        self.assertEqual(len(new_shard.chain), len(self.shard.chain), "Chain length mismatch after deserialization")

    def test_shard_merging(self):
        """Test merging of two shards, if applicable."""
        # Create a new shard to merge with the existing one
        new_shard = Shard(shard_id=2, max_transactions_per_block=5)
        for tx in self.sample_transactions[:3]:
            new_shard.add_transaction(tx)

        # Simulate merging
        merged_transactions = self.shard.merge_shard(new_shard)
        self.assertEqual(len(merged_transactions), 3, "Merged transaction count mismatch")
        self.assertEqual(new_shard.height, 1, "New shard should be reset after merging")

    def test_shard_splitting(self):
        """Test splitting of a shard, if applicable."""
        # Add transactions to the shard
        for tx in self.sample_transactions:
            self.shard.add_transaction(tx)

        # Simulate shard splitting
        split_shard = self.shard.split_shard(new_shard_id=2)
        self.assertIsNotNone(split_shard, "Shard splitting failed")
        self.assertEqual(split_shard.shard_id, 2, "Split shard ID mismatch")
        self.assertLess(len(self.shard.pending_transactions), 10, "Original shard did not reduce transaction count")

if __name__ == "__main__":
    unittest.main()


# ==================== /home/matt/icn-prototype/tests/integration/test_transaction_processing.py ====================



# ==================== /home/matt/icn-prototype/tests/integration/test_smart_contract_execution.py ====================



# ==================== /home/matt/icn-prototype/tests/integration/__init__.py ====================



# ==================== /home/matt/icn-prototype/tests/performance/test_scalability.py ====================



# ==================== /home/matt/icn-prototype/tests/performance/test_stress_resilience.py ====================



# ==================== /home/matt/icn-prototype/tests/performance/test_load_handling.py ====================



# ==================== /home/matt/icn-prototype/tests/performance/__init__.py ====================



# ==================== /home/matt/icn-prototype/tests/unit/test_proof_of_cooperation.py ====================

import unittest
from datetime import datetime, timedelta
import sys
import os
from typing import List
import random

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
from blockchain.core.node import Node
from blockchain.core.block import Block
from blockchain.core.transaction import Transaction

class TestProofOfCooperation(unittest.TestCase):
    """Test cases for the ProofOfCooperation consensus mechanism."""

    def setUp(self):
        """Set up test fixtures before each test method."""
        self.poc = ProofOfCooperation(min_reputation=10.0, cooldown_blocks=3)
        self.test_nodes = self._create_test_nodes()
        
        # Create genesis block
        self.genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now() - timedelta(minutes=10),
            transactions=[],
            validator="genesis",
            shard_id=1
        )

    def _initialize_test_node(self, node_id: str) -> Node:
        """Initialize a test node with all required attributes."""
        node = Node(
            node_id=node_id,
            cooperative_id="test_coop",
            initial_stake=100.0
        )
        
        # Ensure sufficient reputation
        base_score = 25.0  # Well above min_reputation
        for category in node.reputation_scores:
            node.reputation_scores[category] = base_score
            
        # Add successful validation history
        node.validation_history = [
            {
                "timestamp": datetime.now() - timedelta(minutes=i),
                "category": "validation",
                "score_change": 1.0,
                "evidence": {"success": True}
            }
            for i in range(20)
        ]
        
        # Set high performance metrics
        node.performance_metrics = {
            "availability": 98.0,
            "validation_success_rate": 95.0,
            "network_reliability": 97.0
        }
        
        # Set active state
        node.metadata["status"] = "active"
        node.cooldown = 0
        node.total_validations = 15  # Experienced node
        
        # Add shard assignment
        node.assign_to_shard(1)  # Assign to test shard
        node.active_shards[1] = datetime.now() - timedelta(hours=1)
        
        # Add diverse cooperative interactions
        node.cooperative_interactions = [
            f"coop_{i % 5}" for i in range(30)
        ]
        
        return node

    def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
        """Create a list of test nodes."""
        return [
            self._initialize_test_node(f"node_{i}")
            for i in range(num_nodes)
        ]

    def _create_test_block(self, index: int, previous_block: Block, validator_id: str) -> Block:
        """Create a test block properly linked to previous block."""
        return Block(
            index=index,
            previous_hash=previous_block.hash,
            timestamp=datetime.now(),
            transactions=[
                Transaction(
                    sender=f"user_{i}",
                    receiver=f"user_{i+1}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                )
                for i in range(3)
            ],
            validator=validator_id,
            shard_id=1
        )

    def test_initialization(self):
        """Test ProofOfCooperation initialization."""
        self.assertEqual(self.poc.min_reputation, 10.0)
        self.assertEqual(self.poc.cooldown_blocks, 3)
        self.assertGreater(len(self.poc.reputation_weights), 0)
        self.assertGreater(len(self.poc.validation_thresholds), 0)
        self.assertTrue(0 < self.poc.reputation_decay_factor <= 1)

    def test_calculate_cooperation_score(self):
        """Test cooperation score calculation."""
        node = self._initialize_test_node("score_test_node")
        
        # Test basic score calculation
        score = self.poc.calculate_cooperation_score(node)
        self.assertGreater(score, 0)
        
        # Test with shard_id
        shard_score = self.poc.calculate_cooperation_score(node, shard_id=1)
        self.assertGreater(shard_score, 0)
        
        # Test node in cooldown
        node.enter_cooldown(3)
        cooldown_score = self.poc.calculate_cooperation_score(node)
        self.assertEqual(cooldown_score, 0)

    def test_validator_selection(self):
        """Test validator selection process."""
        nodes = [
            self._initialize_test_node(f"select_node_{i}")
            for i in range(5)
        ]
        
        # Test basic selection
        validator = self.poc.select_validator(nodes)
        self.assertIsNotNone(validator)
        self.assertIn(validator, nodes)
        
        # Test selection with shard_id
        shard_validator = self.poc.select_validator(nodes, shard_id=1)
        self.assertIsNotNone(shard_validator)
        
        # Test with all nodes in cooldown
        for node in nodes:
            node.enter_cooldown(3)
        no_validator = self.poc.select_validator(nodes)
        self.assertIsNone(no_validator)

    def test_block_validation(self):
        """Test block validation process."""
        validator = self._initialize_test_node("test_validator")
        
        # Create a valid test block
        test_block = self._create_test_block(1, self.genesis_block, validator.node_id)
        
        # Verify block validation
        is_valid = self.poc.validate_block(test_block, self.genesis_block, validator)
        self.assertTrue(is_valid)
        
        # Test invalid block (future timestamp)
        invalid_block = Block(
            index=1,
            previous_hash=self.genesis_block.hash,
            timestamp=datetime.now() + timedelta(hours=1),
            transactions=[],
            validator=validator.node_id,
            shard_id=1
        )
        is_invalid = self.poc.validate_block(invalid_block, self.genesis_block, validator)
        self.assertFalse(is_invalid)

    def test_collusion_detection(self):
        """Test collusion detection mechanism."""
        node = self._initialize_test_node("collusion_test_node")
        
        # Create block with diverse transactions
        diverse_block = Block(
            index=1,
            previous_hash=self.genesis_block.hash,
            timestamp=datetime.now(),
            transactions=[
                Transaction(
                    sender=f"user_{i}",
                    receiver=f"user_{i+1}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                )
                for i in range(5)
            ],
            validator=node.node_id,
            shard_id=1
        )
        
        # Create block with obvious collusion pattern
        collusion_transactions = [
            Transaction(
                sender="colluding_user",
                receiver=f"receiver_{i}",  # Fixed variable scope issue
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            )
            for i in range(5)
        ]
        
        collusion_block = Block(
            index=2,
            previous_hash=self.genesis_block.hash,
            timestamp=datetime.now(),
            transactions=collusion_transactions,
            validator=node.node_id,
            shard_id=1
        )
        
        # Test detection
        diverse_collusion = self.poc.detect_collusion(node, diverse_block)
        self.assertFalse(diverse_collusion)
        
        repeated_collusion = self.poc.detect_collusion(node, collusion_block)
        self.assertTrue(repeated_collusion)

    def test_diversity_factor(self):
        """Test diversity factor calculation."""
        diverse_node = self._initialize_test_node("diverse_node")
        diverse_node.cooperative_interactions = [f"coop_{i}" for i in range(10)]
        diverse_factor = self.poc._calculate_diversity_factor(diverse_node)
        
        limited_node = self._initialize_test_node("limited_node")
        limited_node.cooperative_interactions = ["coop_1"] * 10
        limited_factor = self.poc._calculate_diversity_factor(limited_node)
        
        self.assertGreater(diverse_factor, limited_factor)

    def test_consistency_factor(self):
        """Test consistency factor calculation."""
        node = self._initialize_test_node("consistency_node")
        
        # Test with successful validations
        node.validation_history = [
            {"evidence": {"success": True}} for _ in range(10)
        ]
        high_consistency = self.poc._calculate_consistency_factor(node)
        
        # Test with mixed success
        node.validation_history = [
            {"evidence": {"success": i % 2 == 0}} for i in range(10)
        ]
        mixed_consistency = self.poc._calculate_consistency_factor(node)
        
        self.assertGreater(high_consistency, mixed_consistency)

    def test_performance_factor(self):
        """Test performance factor calculation."""
        node = self._initialize_test_node("performance_node")
        
        # Test high performance
        node.performance_metrics = {
            "availability": 98.0,
            "validation_success_rate": 95.0,
            "network_reliability": 97.0
        }
        high_performance = self.poc._calculate_performance_factor(node)
        
        # Test lower performance
        node.performance_metrics = {
            "availability": 85.0,
            "validation_success_rate": 82.0,
            "network_reliability": 88.0
        }
        lower_performance = self.poc._calculate_performance_factor(node)
        
        self.assertGreater(high_performance, lower_performance)

    def test_metrics(self):
        """Test consensus metrics collection."""
        # Record some validation activity
        for i in range(5):
            self.poc.performance_metrics["total_validations"] += 1
            self.poc.performance_metrics["successful_validations"] += (i % 2)
        
        metrics = self.poc.get_metrics()
        
        self.assertIn("total_validations", metrics)
        self.assertIn("successful_validations", metrics)
        self.assertIn("average_block_time", metrics)
        self.assertIn("collusion_detections", metrics)
        self.assertGreaterEqual(metrics["total_validations"], 5)

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/test_contract_executor.py ====================

"""
tests/unit/test_contract_executor.py

Unit tests for the ContractExecutor class, handling contract deployment,
execution, and lifecycle management.
"""

import pytest
from datetime import datetime, timedelta
import sys
import os
import asyncio
from typing import Dict, List
import logging

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.contracts.contract_executor import ContractExecutor
from blockchain.contracts.smart_contract import SmartContract, ContractExecutionError

class TestContractExecutor:
    """Test cases for the ContractExecutor class."""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test instance with fresh ContractExecutor."""
        self.executor = ContractExecutor(initial_mana=1000, mana_regen_rate=10)

    @pytest.fixture
    def basic_contract_code(self):
        """Fixture providing basic test contract code."""
        return """
def execute(input_data, state):
    a = input_data.get('a', 0)
    b = input_data.get('b', 0)
    result = a + b
    state['last_result'] = result
    return result
"""

    @pytest.fixture
    def test_contract(self, basic_contract_code):
        """Fixture providing a test contract instance."""
        return SmartContract(
            contract_id="test_contract",
            code=basic_contract_code,
            creator="test_creator",
            mana_cost=10
        )

    @pytest.mark.asyncio
    async def test_deploy_contract(self, test_contract):
        """Test contract deployment functionality."""
        # Test successful deployment
        success = await self.executor.deploy_contract(test_contract)
        assert success
        assert test_contract.contract_id in self.executor.contracts
        
        # Test duplicate deployment
        success = await self.executor.deploy_contract(test_contract)
        assert not success
        
        # Test contract with invalid code
        invalid_contract = SmartContract(
            contract_id="invalid_contract",
            code="invalid python code :",
            creator="test_creator"
        )
        success = await self.executor.deploy_contract(invalid_contract)
        assert not success

    @pytest.mark.asyncio
    async def test_execute_contract(self, test_contract):
        """Test contract execution."""
        await self.executor.deploy_contract(test_contract)
        
        result = await self.executor.execute_contract(
            test_contract.contract_id,
            {"a": 5, "b": 3},
            "test_creator"
        )
        assert result is not None
        assert result.get("result") == 8
        
        # Test insufficient mana
        self.executor.mana_pool = 5
        with pytest.raises(ContractExecutionError):
            await self.executor.execute_contract(
                test_contract.contract_id,
                {"a": 1, "b": 2},
                "test_creator"
            )

    @pytest.mark.asyncio
    async def test_execution_queue(self, test_contract):
        """Test contract execution queue functionality."""
        await self.executor.deploy_contract(test_contract)
        
        queue_success = await self.executor.queue_execution(
            test_contract.contract_id,
            {"a": 1, "b": 2},
            "test_creator"
        )
        assert queue_success

        # Test queue size limit
        self.executor.max_queue_size = 1
        queue_success = await self.executor.queue_execution(
            test_contract.contract_id,
            {"a": 3, "b": 4},
            "test_creator"
        )
        assert not queue_success

    @pytest.mark.asyncio
    async def test_dependency_management(self, basic_contract_code):
        """Test contract dependency management."""
        base_contract = SmartContract(
            contract_id="base_contract",
            code=basic_contract_code,
            creator="test_creator"
        )
        
        dependent_contract = SmartContract(
            contract_id="dependent_contract",
            code="""
def execute(input_data, state):
    value = input_data.get('value', 0)
    state['processed'] = value * 2
    return state['processed']
""",
            creator="test_creator"
        )
        dependent_contract.dependencies.add(base_contract.contract_id)
        
        # Test deployment order validation
        with pytest.raises(ContractExecutionError):
            await self.executor.deploy_contract(dependent_contract)
        
        await self.executor.deploy_contract(base_contract)
        success = await self.executor.deploy_contract(dependent_contract)
        assert success

    @pytest.mark.asyncio
    async def test_mana_regeneration(self, test_contract):
        """Test mana regeneration functionality."""
        initial_mana = self.executor.mana_pool
        
        await self.executor.deploy_contract(test_contract)
        await self.executor.execute_contract(
            test_contract.contract_id,
            {"a": 1, "b": 2},
            "test_creator"
        )
        
        used_mana = initial_mana - self.executor.mana_pool
        await self.executor.regenerate_mana()
        assert self.executor.mana_pool > initial_mana - used_mana

    def test_metrics_collection(self):
        """Test metrics collection and reporting."""
        metrics = self.executor.get_metrics()
        
        assert "total_executions" in metrics
        assert "failed_executions" in metrics
        assert "total_mana_consumed" in metrics
        assert "average_execution_time" in metrics
        assert "contracts_deployed" in metrics
        assert "queue_length" in metrics

    @pytest.mark.asyncio
    async def test_execution_limits(self):
        """Test contract execution limits and restrictions."""
        long_running_contract = SmartContract(
            contract_id="long_running",
            code="""
def execute(input_data, state):
    import time
    time.sleep(6)  # Exceed time limit
    return True
""",
            creator="test_creator"
        )
        
        await self.executor.deploy_contract(long_running_contract)
        
        with pytest.raises(ContractExecutionError):
            await self.executor.execute_contract(
                long_running_contract.contract_id,
                {},
                "test_creator"
            )

    @pytest.mark.asyncio
    async def test_concurrent_execution(self, test_contract):
        """Test concurrent contract execution handling."""
        await self.executor.deploy_contract(test_contract)
        
        tasks = []
        for i in range(5):
            task = self.executor.execute_contract(
                test_contract.contract_id,
                {"a": i, "b": i},
                "test_creator"
            )
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        successful = [r for r in results if not isinstance(r, Exception)]
        assert len(successful) == 5

    @pytest.mark.asyncio
    async def test_error_recovery(self):
        """Test error recovery and state management."""
        failing_contract = SmartContract(
            contract_id="failing_contract",
            code="""
def execute(input_data, state):
    if input_data.get('fail', False):
        raise ValueError('Intended failure')
    state['value'] = input_data.get('value', 0)
    return state['value']
""",
            creator="test_creator"
        )
        
        await self.executor.deploy_contract(failing_contract)
        
        result = await self.executor.execute_contract(
            failing_contract.contract_id,
            {"value": 42},
            "test_creator"
        )
        assert result["result"] == 42
        
        with pytest.raises(ContractExecutionError):
            await self.executor.execute_contract(
                failing_contract.contract_id,
                {"fail": True},
                "test_creator"
            )
        
        result = await self.executor.execute_contract(
            failing_contract.contract_id,
            {"value": 100},
            "test_creator"
        )
        assert result["result"] == 100

    @pytest.mark.asyncio
    async def test_authorization(self, test_contract):
        """Test contract authorization controls."""
        await self.executor.deploy_contract(test_contract)
        
        with pytest.raises(ContractExecutionError):
            await self.executor.execute_contract(
                test_contract.contract_id,
                {"a": 1, "b": 2},
                "unauthorized_user"
            )
        
        test_contract.authorize_caller("new_user")
        result = await self.executor.execute_contract(
            test_contract.contract_id,
            {"a": 1, "b": 2},
            "new_user"
        )
        assert result is not None

    @pytest.mark.asyncio
    async def test_contract_cleanup(self, basic_contract_code):
        """Test contract cleanup and resource management."""
        contracts = []
        for i in range(5):
            contract = SmartContract(
                contract_id=f"contract_{i}",
                code=basic_contract_code,
                creator="test_creator"
            )
            contracts.append(contract)
            await self.executor.deploy_contract(contract)
        
        metrics = self.executor.get_metrics()
        assert metrics["contracts_deployed"] == 5
        
        for contract in contracts:
            assert contract.contract_id in self.executor.contracts

# ==================== /home/matt/icn-prototype/tests/unit/test_block.py ====================

# tests/unit/test_block.py

import unittest
from datetime import datetime, timedelta
import json
import hashlib
import sys
import os
from typing import List

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.core.block import Block
from blockchain.core.transaction import Transaction

class TestBlock(unittest.TestCase):
    """Test cases for the Block class."""

    def setUp(self):
        """Set up test fixtures before each test method."""
        self.sample_transactions = self._create_sample_transactions()
        
        # Create previous block first
        self.previous_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now() - timedelta(minutes=5),
            transactions=[],
            validator="genesis",
            shard_id=1
        )

        # Create current block with correct previous hash
        self.block = Block(
            index=1,
            previous_hash=self.previous_block.hash,  # Use actual hash from previous block
            timestamp=datetime.now(),
            transactions=self.sample_transactions[:2],
            validator="node1",
            shard_id=1
        )

    def _create_sample_transactions(self) -> List[Transaction]:
        """Create sample transactions for testing."""
        transactions = []
        for i in range(1, 6):
            tx = Transaction(
                sender=f"user{i}",
                receiver=f"user{i+1}",
                action="transfer",
                data={"amount": 10.0 * i},
                shard_id=1  # All transactions in same shard
            )
            transactions.append(tx)
        return transactions

    def test_initialization(self):
        """Test block initialization and attribute setting."""
        self.assertEqual(self.block.index, 1)
        self.assertEqual(self.block.previous_hash, self.previous_block.hash)
        self.assertEqual(self.block.validator, "node1")
        self.assertEqual(self.block.shard_id, 1)
        self.assertEqual(len(self.block.transactions), 2)
        self.assertIsNotNone(self.block.merkle_root)
        self.assertIsNotNone(self.block.hash)
        self.assertEqual(self.block.nonce, 0)
        self.assertEqual(self.block.version, "1.0")
        self.assertIn("created_at", self.block.metadata)

    def test_merkle_root_calculation(self):
        """Test Merkle root calculation with different scenarios."""
        # Test with existing transactions
        merkle_root = self.block.calculate_merkle_root()
        self.assertEqual(merkle_root, self.block.merkle_root)
        
        # Test with empty transactions
        empty_block = Block(
            index=0,
            previous_hash="0",
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=0
        )
        self.assertEqual(
            empty_block.merkle_root,
            hashlib.sha256(b"empty").hexdigest()
        )
        
        # Test with odd number of transactions
        odd_block = Block(
            index=2,
            previous_hash=self.block.hash,
            timestamp=datetime.now(),
            transactions=self.sample_transactions[:3],
            validator="node1",
            shard_id=1
        )
        self.assertIsNotNone(odd_block.merkle_root)
        
        # Verify Merkle root changes with transaction modification
        original_root = self.block.merkle_root
        modified_tx = self.block.transactions[0]
        modified_tx.data["amount"] = 999.9
        new_root = self.block.calculate_merkle_root()
        self.assertNotEqual(original_root, new_root)

    def test_hash_calculation(self):
        """Test block hash calculation and verification."""
        # Test initial hash
        initial_hash = self.block.hash
        calculated_hash = self.block.calculate_hash()
        self.assertEqual(initial_hash, calculated_hash)
        
        # Test hash changes with block modifications
        self.block.nonce += 1
        new_hash = self.block.calculate_hash()
        self.assertNotEqual(initial_hash, new_hash)
        
        # Test hash changes with timestamp modification
        original_timestamp = self.block.timestamp
        self.block.timestamp += timedelta(seconds=1)
        newer_hash = self.block.calculate_hash()
        self.assertNotEqual(new_hash, newer_hash)
        # Restore timestamp for other tests
        self.block.timestamp = original_timestamp
        
        # Verify hash format
        self.assertTrue(all(c in "0123456789abcdef" for c in self.block.hash))
        self.assertEqual(len(self.block.hash), 64)  # SHA-256 produces 64 hex chars

    def test_validation(self):
        """Test block validation logic."""
        # Test valid block
        self.assertTrue(self.block.validate(self.previous_block))
        
        # Test invalid hash
        original_hash = self.block.hash
        self.block.hash = "invalid_hash"
        self.assertFalse(self.block.validate(self.previous_block))
        self.block.hash = original_hash
        
        # Test future timestamp
        original_timestamp = self.block.timestamp
        self.block.timestamp = datetime.now() + timedelta(hours=1)
        self.assertFalse(self.block.validate(self.previous_block))
        self.block.timestamp = original_timestamp
        
        # Test invalid previous hash
        original_prev_hash = self.block.previous_hash
        self.block.previous_hash = "wrong_hash"
        self.assertFalse(self.block.validate(self.previous_block))
        self.block.previous_hash = original_prev_hash

    def test_add_transaction(self):
        """Test adding transactions to the block."""
        initial_tx_count = len(self.block.transactions)
        new_tx = self.sample_transactions[3]  # Unused transaction
        
        # Test adding valid transaction
        self.assertTrue(self.block.add_transaction(new_tx))
        self.assertEqual(len(self.block.transactions), initial_tx_count + 1)
        
        # Verify Merkle root was updated
        self.assertNotEqual(self.block.merkle_root, "")
        
        # Test adding transaction with wrong shard_id
        wrong_shard_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 50.0},
            shard_id=2  # Different shard
        )
        self.assertFalse(self.block.add_transaction(wrong_shard_tx))
        
        # Test adding duplicate transaction
        self.assertFalse(self.block.add_transaction(new_tx))

    def test_block_size(self):
        """Test block size calculations and limits."""
        # Add maximum transactions
        for tx in self.sample_transactions:
            self.block.add_transaction(tx)
            
        # Verify block can be serialized
        block_dict = self.block.to_dict()
        block_json = json.dumps(block_dict)
        
        # Simulate block size calculation
        block_size = len(block_json.encode('utf-8'))
        self.assertGreater(block_size, 0)

    def test_cross_shard_references(self):
        """Test cross-shard reference handling."""
        # Add cross-shard reference
        ref = "cross_shard_ref_123"
        self.block.cross_shard_refs.append(ref)
        
        # Verify serialization includes references
        block_dict = self.block.to_dict()
        self.assertIn("cross_shard_refs", block_dict)
        self.assertIn(ref, block_dict["cross_shard_refs"])
        
        # Verify deserialization preserves references
        new_block = Block.from_dict(block_dict)
        self.assertIn(ref, new_block.cross_shard_refs)

    def test_metadata(self):
        """Test block metadata handling."""
        # Test default metadata
        self.assertIn("created_at", self.block.metadata)
        
        # Add custom metadata
        self.block.metadata["test_key"] = "test_value"
        
        # Verify serialization includes metadata
        block_dict = self.block.to_dict()
        self.assertIn("metadata", block_dict)
        self.assertEqual(block_dict["metadata"]["test_key"], "test_value")
        
        # Verify deserialization preserves metadata
        new_block = Block.from_dict(block_dict)
        self.assertEqual(new_block.metadata["test_key"], "test_value")

    def test_serialization(self):
        """Test block serialization and deserialization."""
        # Convert block to dictionary
        block_dict = self.block.to_dict()
        
        # Verify dictionary structure
        self.assertIn("index", block_dict)
        self.assertIn("previous_hash", block_dict)
        self.assertIn("timestamp", block_dict)
        self.assertIn("transactions", block_dict)
        self.assertIn("validator", block_dict)
        self.assertIn("hash", block_dict)
        self.assertIn("merkle_root", block_dict)
        self.assertIn("shard_id", block_dict)
        self.assertIn("version", block_dict)
        
        # Create new block from dictionary
        new_block = Block.from_dict(block_dict)
        
        # Verify all attributes match
        self.assertEqual(new_block.index, self.block.index)
        self.assertEqual(new_block.previous_hash, self.block.previous_hash)
        self.assertEqual(new_block.validator, self.block.validator)
        self.assertEqual(new_block.shard_id, self.block.shard_id)
        self.assertEqual(new_block.hash, self.block.hash)
        self.assertEqual(new_block.merkle_root, self.block.merkle_root)
        
        # Verify transactions were properly deserialized
        self.assertEqual(len(new_block.transactions), len(self.block.transactions))
        for orig_tx, new_tx in zip(self.block.transactions, new_block.transactions):
            self.assertEqual(orig_tx.transaction_id, new_tx.transaction_id)
            self.assertEqual(orig_tx.sender, new_tx.sender)
            self.assertEqual(orig_tx.receiver, new_tx.receiver)
            self.assertEqual(orig_tx.data, new_tx.data)

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/test_shard.py ====================

# tests/unit/test_shard.py

import unittest
from datetime import datetime, timedelta
import sys
import os
from typing import List

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.core.shard import Shard
from blockchain.core.block import Block
from blockchain.core.transaction import Transaction

class TestShard(unittest.TestCase):
    """Test cases for the Shard class."""

    def setUp(self):
        """Set up test fixtures before each test."""
        self.shard = Shard(shard_id=1, max_transactions_per_block=5)
        self.sample_transactions = self._create_sample_transactions()

    def _create_sample_transactions(self) -> List[Transaction]:
        """Create sample transactions for testing."""
        return [
            Transaction(
                sender=f"user{i}",
                receiver=f"user{i+1}",
                action="transfer",
                data={"amount": 10.0},
                shard_id=1
            ) for i in range(10)
        ]

    def test_initialization(self):
        """Test shard initialization."""
        self.assertEqual(self.shard.shard_id, 1)
        self.assertEqual(self.shard.max_transactions_per_block, 5)
        self.assertEqual(len(self.shard.chain), 1)  # Genesis block
        self.assertEqual(self.shard.height, 1)
        self.assertIsNotNone(self.shard.last_block_time)
        self.assertEqual(self.shard.metrics["blocks_created"], 1)

    def test_genesis_block(self):
        """Test genesis block creation and properties."""
        genesis = self.shard.chain[0]
        self.assertEqual(genesis.index, 0)
        self.assertEqual(genesis.previous_hash, "0" * 64)
        self.assertEqual(len(genesis.transactions), 0)
        self.assertEqual(genesis.validator, "genesis")
        self.assertEqual(genesis.shard_id, 1)

    def test_add_transaction(self):
        """Test adding transactions to the shard."""
        # Test valid transaction
        tx = self.sample_transactions[0]
        self.assertTrue(self.shard.add_transaction(tx))
        self.assertEqual(len(self.shard.pending_transactions), 1)

        # Test duplicate transaction
        self.assertFalse(self.shard.add_transaction(tx))
        self.assertEqual(len(self.shard.pending_transactions), 1)

        # Test transaction with wrong shard_id
        invalid_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0},
            shard_id=2
        )
        self.assertFalse(self.shard.add_transaction(invalid_tx))

        # Test transaction pool limit
        for tx in self.sample_transactions[1:11]:  # Try to add 10 more
            self.shard.add_transaction(tx)
        self.assertLessEqual(
            len(self.shard.pending_transactions),
            self.shard.max_transactions_per_block * 2
        )

    def test_create_block(self):
        """Test block creation from pending transactions."""
        # Add some transactions
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)

        # Create block
        block = self.shard.create_block(validator="test_validator")
        self.assertIsNotNone(block)
        self.assertEqual(block.index, self.shard.height)
        self.assertEqual(block.shard_id, self.shard.shard_id)
        self.assertEqual(len(block.transactions), 3)
        self.assertEqual(block.validator, "test_validator")

        # Test with no pending transactions
        self.shard.pending_transactions = []
        block = self.shard.create_block(validator="test_validator")
        self.assertIsNone(block)

    def test_add_block(self):
        """Test adding blocks to the shard."""
        # Create and add a valid block
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        
        block = self.shard.create_block(validator="test_validator")
        initial_height = self.shard.height
        self.assertTrue(self.shard.add_block(block))
        self.assertEqual(self.shard.height, initial_height + 1)
        self.assertEqual(len(self.shard.pending_transactions), 0)

        # Test adding block with wrong shard_id
        invalid_block = Block(
            index=self.shard.height,
            previous_hash=self.shard.chain[-1].hash,
            timestamp=datetime.now(),
            transactions=[],
            validator="test_validator",
            shard_id=2
        )
        self.assertFalse(self.shard.add_block(invalid_block))

        # Test adding block with wrong index
        invalid_block = Block(
            index=self.shard.height + 1,
            previous_hash=self.shard.chain[-1].hash,
            timestamp=datetime.now(),
            transactions=[],
            validator="test_validator",
            shard_id=1
        )
        self.assertFalse(self.shard.add_block(invalid_block))

    def test_validate_chain(self):
        """Test chain validation."""
        # Initial chain should be valid
        self.assertTrue(self.shard.validate_chain())

        # Add some valid blocks
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        block = self.shard.create_block(validator="test_validator")
        self.shard.add_block(block)
        self.assertTrue(self.shard.validate_chain())

        # Tamper with a block
        self.shard.chain[1].transactions = []  # This should invalidate the block's hash
        self.assertFalse(self.shard.validate_chain())

    def test_get_block_by_hash(self):
        """Test retrieving blocks by hash."""
        # Add a block
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        block = self.shard.create_block(validator="test_validator")
        self.shard.add_block(block)

        # Test retrieval
        retrieved_block = self.shard.get_block_by_hash(block.hash)
        self.assertIsNotNone(retrieved_block)
        self.assertEqual(retrieved_block.hash, block.hash)

        # Test non-existent block
        self.assertIsNone(self.shard.get_block_by_hash("nonexistent"))

    def test_get_transaction_by_id(self):
        """Test retrieving transactions by ID."""
        # Add transactions and create block
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        
        # Test finding in pending transactions
        tx_id = self.sample_transactions[0].transaction_id
        found_tx = self.shard.get_transaction_by_id(tx_id)
        self.assertIsNotNone(found_tx)
        self.assertEqual(found_tx.transaction_id, tx_id)

        # Create and add block
        block = self.shard.create_block(validator="test_validator")
        self.shard.add_block(block)

        # Test finding in chain
        found_tx = self.shard.get_transaction_by_id(tx_id)
        self.assertIsNotNone(found_tx)
        self.assertEqual(found_tx.transaction_id, tx_id)

        # Test non-existent transaction
        self.assertIsNone(self.shard.get_transaction_by_id("nonexistent"))

    def test_prune_pending_transactions(self):
        """Test pruning old pending transactions."""
        # Add some transactions with old timestamps
        old_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0},
            shard_id=1
        )
        old_tx.timestamp = datetime.now() - timedelta(hours=2)
        self.shard.add_transaction(old_tx)

        # Add some recent transactions
        self.shard.add_transaction(self.sample_transactions[0])

        # Prune old transactions
        self.shard.prune_pending_transactions(max_age_minutes=60)
        self.assertEqual(len(self.shard.pending_transactions), 1)

    def test_get_metrics(self):
        """Test metrics collection."""
        metrics = self.shard.get_metrics()
        self.assertIn("shard_id", metrics)
        self.assertIn("height", metrics)
        self.assertIn("pending_transactions", metrics)
        self.assertIn("chain_size", metrics)
        self.assertIn("total_transactions_in_chain", metrics)

    def test_serialization(self):
        """Test shard serialization and deserialization."""
        # Add some data to the shard
        for tx in self.sample_transactions[:3]:
            self.shard.add_transaction(tx)
        block = self.shard.create_block(validator="test_validator")
        self.shard.add_block(block)

        # Serialize
        shard_dict = self.shard.to_dict()

        # Deserialize
        new_shard = Shard.from_dict(shard_dict)

        # Verify
        self.assertEqual(new_shard.shard_id, self.shard.shard_id)
        self.assertEqual(new_shard.height, self.shard.height)
        self.assertEqual(len(new_shard.chain), len(self.shard.chain))
        self.assertEqual(
            len(new_shard.pending_transactions),
            len(self.shard.pending_transactions)
        )

    def test_cross_shard_references(self):
        """Test cross-shard transaction handling."""
        # Create a cross-shard transaction
        cross_shard_tx = Transaction(
            sender="user1",
            receiver="user2",
            action="transfer",
            data={"amount": 10.0, "target_shard": 2},
            shard_id=1
        )
        self.shard.add_transaction(cross_shard_tx)

        # Verify reference tracking
        self.assertIn(2, self.shard.cross_shard_references)
        self.assertIn(
            cross_shard_tx.transaction_id,
            self.shard.cross_shard_references[2]
        )

    def test_validation_cache(self):
        """Test transaction validation caching."""
        # Add a transaction
        tx = self.sample_transactions[0]
        self.shard.add_transaction(tx)

        # Verify cache
        self.assertIn(tx.transaction_id, self.shard.validation_cache)
        self.assertTrue(self.shard.validation_cache[tx.transaction_id])

        # Try to add same transaction again
        self.assertFalse(self.shard.add_transaction(tx))

        # Prune transactions and verify cache cleanup
        self.shard.prune_pending_transactions(max_age_minutes=0)
        self.assertNotIn(tx.transaction_id, self.shard.validation_cache)

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/test_node.py ====================

import unittest
from datetime import datetime, timedelta
from blockchain.core.block import Block
from blockchain.core.transaction import Transaction
from blockchain.core.node import Node
from blockchain.core.shard import Shard
from blockchain.consensus.proof_of_cooperation import ProofOfCooperation

class TestBlock(unittest.TestCase):
    def setUp(self):
        """Set up test environment before each test method."""
        self.transactions = [
            Transaction(
                sender="user1",
                receiver="user2", 
                action="transfer",
                data={"amount": 10.0}
            ),
            Transaction(
                sender="user2",
                receiver="user3",
                action="transfer",
                data={"amount": 5.0}
            )
        ]
        
        self.block = Block(
            index=1,
            previous_hash="abc123",
            timestamp=datetime.now(),
            transactions=self.transactions,
            validator="node1",
            shard_id=1
        )

    def test_initialization(self):
        """Test block initialization with proper values."""
        self.assertEqual(self.block.index, 1)
        self.assertEqual(self.block.previous_hash, "abc123")
        self.assertEqual(self.block.validator, "node1")
        self.assertEqual(self.block.shard_id, 1)
        self.assertEqual(len(self.block.transactions), 2)
        self.assertIsNotNone(self.block.merkle_root)

    def test_calculate_merkle_root(self):
        """Test Merkle root calculation."""
        merkle_root = self.block.calculate_merkle_root()
        self.assertEqual(merkle_root, self.block.merkle_root)
        
        # Test with empty transactions
        empty_block = Block(
            index=0,
            previous_hash="0",
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=0
        )
        self.assertIsNotNone(empty_block.merkle_root)

    def test_calculate_hash(self):
        """Test block hash calculation."""
        initial_hash = self.block.hash
        new_hash = self.block.calculate_hash()
        self.assertEqual(initial_hash, new_hash)
        
        # Test hash changes with different transactions
        self.block.transactions.append(
            Transaction(
                sender="user3",
                receiver="user4",
                action="transfer",
                data={"amount": 15.0}
            )
        )
        self.assertNotEqual(initial_hash, self.block.calculate_hash())

    def test_validate(self):
        """Test block validation logic."""
        # Create a previous block
        previous_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now() - timedelta(minutes=5),
            transactions=[],
            validator="genesis",
            shard_id=1
        )
        
        # Test valid block
        self.assertTrue(self.block.validate(previous_block))
        
        # Test invalid cases
        self.block.hash = "invalid_hash"
        self.assertFalse(self.block.validate(previous_block))
        
        self.block.hash = self.block.calculate_hash()
        self.block.timestamp = datetime.now() + timedelta(hours=1)
        self.assertFalse(self.block.validate(previous_block))

    def test_add_transaction(self):
        """Test adding transactions to the block."""
        new_tx = Transaction(
            sender="user3",
            receiver="user4",
            action="transfer",
            data={"amount": 15.0},
            shard_id=1
        )
        
        initial_merkle_root = self.block.merkle_root
        self.assertTrue(self.block.add_transaction(new_tx))
        self.assertNotEqual(initial_merkle_root, self.block.merkle_root)
        
        # Test adding transaction with wrong shard_id
        invalid_tx = Transaction(
            sender="user4",
            receiver="user5",
            action="transfer",
            data={"amount": 20.0},
            shard_id=2
        )
        self.assertFalse(self.block.add_transaction(invalid_tx))

    def test_to_dict_and_from_dict(self):
        """Test converting block to dict and back."""
        block_dict = self.block.to_dict()
        new_block = Block.from_dict(block_dict)
        
        self.assertEqual(new_block.index, self.block.index)
        self.assertEqual(new_block.previous_hash, self.block.previous_hash)
        self.assertEqual(new_block.validator, self.block.validator)
        self.assertEqual(len(new_block.transactions), len(self.block.transactions))
        self.assertEqual(new_block.hash, self.block.hash)

class TestNode(unittest.TestCase):
    def setUp(self):
        """Set up test environment before each test method."""
        self.node = Node(
            node_id="test_node",
            cooperative_id="test_coop",
            initial_stake=100.0
        )

    def test_initialization(self):
        """Test node initialization with proper values."""
        self.assertEqual(self.node.node_id, "test_node")
        self.assertEqual(self.node.cooperative_id, "test_coop")
        self.assertEqual(self.node.stake, 100.0)
        self.assertEqual(self.node.metadata["status"], "active")
        self.assertGreater(len(self.node.reputation_scores), 0)

    def test_update_reputation(self):
        """Test updating reputation scores."""
        category = "validation"
        initial_score = self.node.reputation_scores[category]
        
        # Test positive update
        success = self.node.update_reputation(
            category=category,
            score=5.0,
            cooperative_id="test_coop",
            evidence={"type": "successful_validation"}
        )
        self.assertTrue(success)
        self.assertEqual(self.node.reputation_scores[category], initial_score + 5.0)
        
        # Test invalid category
        success = self.node.update_reputation(
            category="invalid_category",
            score=3.0
        )
        self.assertFalse(success)

    def test_assign_to_shard(self):
        """Test shard assignment logic."""
        # Test successful assignment
        self.assertTrue(self.node.assign_to_shard(1))
        self.assertIn(1, self.node.shard_assignments)
        
        # Test maximum shard limit
        self.node.assign_to_shard(2)
        self.node.assign_to_shard(3)
        self.assertFalse(self.node.assign_to_shard(4))

    def test_can_validate(self):
        """Test validation eligibility checks."""
        # Test initial state
        self.assertTrue(self.node.can_validate())
        
        # Test cooldown period
        self.node.enter_cooldown(2)
        self.assertFalse(self.node.can_validate())
        
        # Test shard-specific validation
        self.node.assign_to_shard(1)
        self.assertTrue(self.node.can_validate(1))
        self.assertFalse(self.node.can_validate(2))

    def test_to_dict_from_dict(self):
        """Test converting node to dict and back."""
        node_dict = self.node.to_dict()
        restored_node = Node.from_dict(node_dict)
        
        self.assertEqual(restored_node.node_id, self.node.node_id)
        self.assertEqual(restored_node.cooperative_id, self.node.cooperative_id)
        self.assertEqual(restored_node.stake, self.node.stake)
        self.assertEqual(restored_node.reputation_scores, self.node.reputation_scores)

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/test_transaction.py ====================

# tests/unit/test_transaction.py

import unittest
from datetime import datetime, timedelta
import json
import sys
import os
import hashlib
from typing import Dict

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.core.transaction import Transaction

class TestTransaction(unittest.TestCase):
    """Test cases for the Transaction class."""

    def setUp(self):
        """Set up test fixtures before each test method."""
        self.transaction_data = {
            "amount": 100.0,
            "fee": 1.0,
            "metadata": {"type": "transfer"}
        }
        
        self.transaction = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=self.transaction_data.copy(),
            shard_id=1
        )

    def test_initialization(self):
        """Test transaction initialization and attribute setting."""
        self.assertEqual(self.transaction.sender, "sender123")
        self.assertEqual(self.transaction.receiver, "receiver456")
        self.assertEqual(self.transaction.action, "transfer")
        self.assertEqual(self.transaction.data["amount"], 100.0)
        self.assertEqual(self.transaction.shard_id, 1)
        self.assertIsNotNone(self.transaction.timestamp)
        self.assertIsNotNone(self.transaction.transaction_id)

    def test_invalid_initialization(self):
        """Test transaction initialization with invalid data."""
        # Test empty sender
        with self.assertRaises(ValueError):
            Transaction(
                sender="",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data,
                shard_id=1
            )

        # Test empty receiver
        with self.assertRaises(ValueError):
            Transaction(
                sender="sender123",
                receiver="",
                action="transfer",
                data=self.transaction_data,
                shard_id=1
            )

        # Test empty action
        with self.assertRaises(ValueError):
            Transaction(
                sender="sender123",
                receiver="receiver456",
                action="",
                data=self.transaction_data,
                shard_id=1
            )

    def test_transaction_id_consistency(self):
        """Test that transaction ID remains consistent after serialization."""
        # Create two identical transactions
        tx1 = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=self.transaction_data.copy(),
            shard_id=1
        )
        
        # Convert to dict and back
        tx_dict = tx1.to_dict()
        tx2 = Transaction.from_dict(tx_dict)
        
        # IDs should match
        self.assertEqual(tx1.transaction_id, tx2.transaction_id)
        
        # Create transaction with same data but different timestamp
        tx3 = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=self.transaction_data.copy(),
            shard_id=1
        )
        
        # IDs should be different due to timestamp
        self.assertNotEqual(tx1.transaction_id, tx3.transaction_id)

    def test_validation(self):
        """Test transaction validation."""
        # Valid transaction should pass
        self.assertTrue(self.transaction.validate())
        
        # Test invalid timestamp
        tx = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=self.transaction_data.copy(),
            shard_id=1
        )
        tx.timestamp = datetime.now() + timedelta(hours=1)
        self.assertFalse(tx.validate())
        
        # Test invalid shard_id
        tx = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=self.transaction_data.copy(),
            shard_id=-1
        )
        self.assertFalse(tx.validate())
        
        # Test invalid data type
        tx = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data="invalid_data",  # Should be dict
            shard_id=1
        )
        self.assertFalse(tx.validate())

    def test_serialization(self):
        """Test transaction serialization and deserialization."""
        # Convert to dictionary
        tx_dict = self.transaction.to_dict()
        
        # Verify dictionary structure
        self.assertIn("transaction_id", tx_dict)
        self.assertIn("sender", tx_dict)
        self.assertIn("receiver", tx_dict)
        self.assertIn("action", tx_dict)
        self.assertIn("data", tx_dict)
        self.assertIn("timestamp", tx_dict)
        self.assertIn("shard_id", tx_dict)
        
        # Create new transaction from dictionary
        new_tx = Transaction.from_dict(tx_dict)
        
        # Verify all attributes match
        self.assertEqual(new_tx.transaction_id, self.transaction.transaction_id)
        self.assertEqual(new_tx.sender, self.transaction.sender)
        self.assertEqual(new_tx.receiver, self.transaction.receiver)
        self.assertEqual(new_tx.action, self.transaction.action)
        self.assertEqual(new_tx.data, self.transaction.data)
        self.assertEqual(new_tx.shard_id, self.transaction.shard_id)
        self.assertEqual(new_tx.timestamp, self.transaction.timestamp)

    def test_hash_consistency(self):
        """Test that transaction hash calculation is consistent."""
        tx1_hash = self.transaction.calculate_hash()
        tx1_dict = self.transaction.to_dict()
        tx2 = Transaction.from_dict(tx1_dict)
        tx2_hash = tx2.calculate_hash()
        
        self.assertEqual(tx1_hash, tx2_hash)
        
        # Modify transaction and verify hash changes
        self.transaction.data["amount"] = 200.0
        self.assertNotEqual(self.transaction.calculate_hash(), tx1_hash)

    def test_deep_copy_data(self):
        """Test that transaction data is properly deep copied."""
        nested_data = {
            "amount": 100.0,
            "metadata": {
                "tags": ["test", "transfer"],
                "extra": {"note": "test transaction"}
            }
        }
        
        tx = Transaction(
            sender="sender123",
            receiver="receiver456",
            action="transfer",
            data=nested_data,
            shard_id=1
        )
        
        # Modify original data
        nested_data["metadata"]["tags"].append("modified")
        
        # Transaction data should be unchanged
        self.assertEqual(len(tx.data["metadata"]["tags"]), 2)
        self.assertNotIn("modified", tx.data["metadata"]["tags"])

    def test_timestamp_serialization(self):
        """Test that timestamp is properly serialized and deserialized."""
        tx_dict = self.transaction.to_dict()
        new_tx = Transaction.from_dict(tx_dict)
        
        self.assertEqual(
            self.transaction.timestamp.isoformat(),
            new_tx.timestamp.isoformat()
        )

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/test_blockchain.py ====================

import pytest
import asyncio
from datetime import datetime

from blockchain.core.blockchain import Blockchain
from blockchain.core.node import Node
from blockchain.core.block import Block
from blockchain.contracts.smart_contract import SmartContract
from blockchain.core.transaction import Transaction

@pytest.fixture
def blockchain():
    """
    Fixture to create a fresh instance of the Blockchain for each test.
    """
    return Blockchain(num_shards=3, initial_mana=1000, mana_regen_rate=10)

def test_initialization(blockchain):
    """
    Test the initialization of the Blockchain.
    """
    assert isinstance(blockchain, Blockchain)
    assert blockchain.cooperative_mana == 1000
    assert blockchain.mana_regen_rate == 10
    assert len(blockchain.shards) == 3
    assert blockchain.genesis_block_created is True

def test_register_node(blockchain):
    """
    Test node registration functionality.
    """
    node = Node(node_id="node_1")
    assert blockchain.register_node(node) is True
    assert node.node_id in blockchain.nodes

    # Duplicate registration should fail
    assert blockchain.register_node(node) is False

def test_create_shard(blockchain):
    """
    Test shard creation in the Blockchain.
    """
    assert blockchain.create_shard(3) is True
    assert 3 in blockchain.shards

    # Attempt to create an existing shard
    assert blockchain.create_shard(3) is False

def test_add_transaction(blockchain):
    """
    Test adding a transaction to the Blockchain.
    """
    transaction = {
        "sender": "alice",
        "receiver": "bob",
        "action": "transfer",
        "data": {"amount": 50}
    }

    # Add a valid transaction
    assert blockchain.add_transaction(transaction) is True

    # Add an invalid transaction
    invalid_transaction = "invalid_format"
    assert blockchain.add_transaction(invalid_transaction) is False

def test_create_block(blockchain):
    """
    Test block creation in the Blockchain.
    """
    node = Node(node_id="node_1")
    blockchain.register_node(node)

    # Create a block in a valid shard
    shard_id = 0
    block = blockchain.create_block(shard_id)
    assert block is not None
    assert isinstance(block, Block)

    # Attempt to create a block in an invalid shard
    invalid_shard_id = 99
    assert blockchain.create_block(invalid_shard_id) is None

def test_add_block(blockchain):
    """
    Test adding a block to the Blockchain.
    """
    node = Node(node_id="node_1")
    blockchain.register_node(node)

    block = Block(
        index=1,
        previous_hash=blockchain.chain[-1].hash,
        timestamp=datetime.now(),
        transactions=[],
        validator="node_1",
        shard_id=0
    )

    # Add a valid block
    assert blockchain.add_block(block) is True

    # Add an invalid block (invalid previous hash)
    invalid_block = Block(
        index=2,
        previous_hash="invalid_hash",
        timestamp=datetime.now(),
        transactions=[],
        validator="node_1",
        shard_id=0
    )
    assert blockchain.add_block(invalid_block) is False

def test_mana_regeneration(blockchain):
    """
    Test mana regeneration functionality.
    """
    # Deplete some mana
    blockchain.cooperative_mana -= 100
    blockchain.regenerate_mana()

    # Check if mana regenerated correctly
    assert blockchain.cooperative_mana == 910  # 1000 - 100 + 10

def test_get_chain_metrics(blockchain):
    """
    Test retrieving blockchain metrics.
    """
    metrics = blockchain.get_chain_metrics()
    assert isinstance(metrics, dict)
    assert metrics["chain_length"] == 1  # Genesis block
    assert metrics["cooperative_mana"] == 1000
    assert metrics["active_nodes"] == 0
    assert metrics["active_shards"] == 3

def test_validate_chain(blockchain):
    """
    Test the entire blockchain validation.
    """
    node = Node(node_id="node_1")
    blockchain.register_node(node)

    block = Block(
        index=1,
        previous_hash=blockchain.chain[-1].hash,
        timestamp=datetime.now(),
        transactions=[],
        validator="node_1",
        shard_id=0
    )
    blockchain.add_block(block)

    # Validate the blockchain
    assert blockchain.validate_chain() is True

    # Corrupt the chain
    blockchain.chain[-1].previous_hash = "corrupt_hash"
    assert blockchain.validate_chain() is False

def test_smart_contract_deployment(blockchain):
    """
    Test deploying a smart contract to the Blockchain.
    """
    contract = SmartContract(
        contract_id="contract_1",
        creator="node_1",
        code="dummy_code",
        mana_cost=100
    )

    result = asyncio.run(blockchain.deploy_smart_contract(contract))
    assert result is True
    assert "contract_1" in blockchain.smart_contracts

    # Deploy an invalid contract (e.g., insufficient mana)
    contract_2 = SmartContract(
        contract_id="contract_2",
        creator="node_1",
        code="dummy_code",
        mana_cost=2000  # Exceeds available mana
    )

    result = asyncio.run(blockchain.deploy_smart_contract(contract_2))
    assert result is False

def test_smart_contract_execution(blockchain):
    """
    Test executing a smart contract on the Blockchain.
    """
    contract = SmartContract(
        contract_id="contract_1",
        creator="node_1",
        code="dummy_code",
        mana_cost=50
    )

    asyncio.run(blockchain.deploy_smart_contract(contract))

    input_data = {"param": "value"}
    result = asyncio.run(blockchain.execute_smart_contract(
        contract_id="contract_1",
        input_data=input_data,
        caller="node_1"
    ))
    assert result is not None

    # Attempt to execute a non-existent contract
    result = asyncio.run(blockchain.execute_smart_contract(
        contract_id="non_existent",
        input_data=input_data,
        caller="node_1"
    ))
    assert result is None


# ==================== /home/matt/icn-prototype/tests/unit/test_smart_contract.py ====================

import unittest
from datetime import datetime, timedelta
import sys
import os
from typing import Dict, Optional

# Add project root to Python path
project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
sys.path.insert(0, project_root)

from blockchain.contracts.smart_contract import SmartContract, ContractExecutionError

class TestSmartContract(unittest.TestCase):
    """Test cases for the SmartContract class."""

    def setUp(self):
        """Set up test fixtures before each test method."""
        self.sample_code = """
def execute(input_data, state):
    # Simple contract that adds numbers
    a = input_data.get('a', 0)
    b = input_data.get('b', 0)
    result = a + b
    state['last_result'] = result
    return result
"""
        self.contract = SmartContract(
            contract_id="test_contract",
            code=self.sample_code,
            creator="test_creator",
            mana_cost=10,
            version="1.0"
        )

    def test_initialization(self):
        """Test smart contract initialization and attributes."""
        self.assertEqual(self.contract.contract_id, "test_contract")
        self.assertEqual(self.contract.creator, "test_creator")
        self.assertEqual(self.contract.mana_cost, 10)
        self.assertEqual(self.contract.version, "1.0")
        self.assertEqual(self.contract.state, {})
        self.assertEqual(self.contract.execution_count, 0)
        self.assertEqual(self.contract.total_mana_consumed, 0)
        self.assertIsNone(self.contract.last_executed)
        self.assertIn(self.contract.creator, self.contract.allowed_callers)

    def test_execute_valid_contract(self):
        """Test execution of a valid contract."""
        input_data = {"a": 5, "b": 3}
        result = self.contract.execute(input_data, available_mana=20)
        
        self.assertEqual(result["result"], 8)
        self.assertEqual(result["mana_used"], 10)
        self.assertEqual(self.contract.state["last_result"], 8)
        self.assertEqual(self.contract.execution_count, 1)
        self.assertEqual(self.contract.total_mana_consumed, 10)
        self.assertIsNotNone(self.contract.last_executed)

    def test_execute_insufficient_mana(self):
        """Test execution with insufficient mana."""
        input_data = {"a": 5, "b": 3}
        
        with self.assertRaises(ContractExecutionError) as context:
            self.contract.execute(input_data, available_mana=5)
        
        self.assertIn("Insufficient mana", str(context.exception))
        self.assertEqual(self.contract.execution_count, 0)
        self.assertEqual(self.contract.total_mana_consumed, 0)

    def test_execute_invalid_code(self):
        """Test execution with invalid contract code."""
        invalid_contract = SmartContract(
            contract_id="invalid_contract",
            code="def invalid_function(): return 'no execute'",
            creator="test_creator",
            mana_cost=10
        )
        
        with self.assertRaises(ContractExecutionError) as context:
            invalid_contract.execute({}, available_mana=20)
        
        self.assertIn("Contract missing execute function", str(context.exception))

    def test_execute_with_state_updates(self):
        """Test contract execution with state updates."""
        # First execution
        result1 = self.contract.execute({"a": 5, "b": 3}, available_mana=20)
        self.assertEqual(self.contract.state["last_result"], 8)
        
        # Second execution
        result2 = self.contract.execute({"a": 2, "b": 4}, available_mana=20)
        self.assertEqual(self.contract.state["last_result"], 6)
        
        self.assertEqual(self.contract.execution_count, 2)
        self.assertEqual(self.contract.total_mana_consumed, 20)

    def test_execution_limits(self):
        """Test contract execution limits."""
        # Set low daily limit for testing
        self.contract.restrictions["max_daily_executions"] = 2
        
        # First execution
        self.contract.execute({"a": 1, "b": 2}, available_mana=20)
        # Second execution
        self.contract.execute({"a": 3, "b": 4}, available_mana=20)
        
        # Third execution should fail
        with self.assertRaises(ContractExecutionError) as context:
            self.contract.execute({"a": 5, "b": 6}, available_mana=20)
        
        self.assertIn("Daily execution limit exceeded", str(context.exception))
        self.assertEqual(self.contract.execution_count, 2)

    def test_authorize_and_revoke_caller(self):
        """Test caller authorization management."""
        new_caller = "new_caller"
        
        # Test authorization
        self.assertTrue(self.contract.authorize_caller(new_caller))
        self.assertIn(new_caller, self.contract.allowed_callers)
        
        # Test revocation
        self.assertTrue(self.contract.revoke_caller(new_caller))
        self.assertNotIn(new_caller, self.contract.allowed_callers)
        
        # Test creator cannot be revoked
        self.assertFalse(self.contract.revoke_caller(self.contract.creator))
        self.assertIn(self.contract.creator, self.contract.allowed_callers)

    def test_update_restrictions(self):
        """Test updating contract restrictions."""
        new_restrictions = {
            "max_state_size": 2048,
            "max_execution_time": 10
        }
        
        self.assertTrue(self.contract.update_restrictions(new_restrictions))
        self.assertEqual(self.contract.restrictions["max_state_size"], 2048)
        self.assertEqual(self.contract.restrictions["max_execution_time"], 10)
        
        # Test invalid restriction update
        invalid_restrictions = {"invalid_key": 100}
        self.assertFalse(self.contract.update_restrictions(invalid_restrictions))

    def test_serialization(self):
        """Test contract serialization and deserialization."""
        # Execute contract to populate some data
        self.contract.execute({"a": 5, "b": 3}, available_mana=20)
        
        # Convert to dictionary
        contract_dict = self.contract.to_dict()
        
        # Create new contract from dictionary
        new_contract = SmartContract.from_dict(contract_dict)
        
        # Verify attributes
        self.assertEqual(new_contract.contract_id, self.contract.contract_id)
        self.assertEqual(new_contract.creator, self.contract.creator)
        self.assertEqual(new_contract.code, self.contract.code)
        self.assertEqual(new_contract.mana_cost, self.contract.mana_cost)
        self.assertEqual(new_contract.version, self.contract.version)
        self.assertEqual(new_contract.state, self.contract.state)
        self.assertEqual(new_contract.restrictions, self.contract.restrictions)

    def test_execution_history(self):
        """Test execution history tracking."""
        # Multiple executions
        self.contract.execute({"a": 1, "b": 2}, available_mana=20)
        self.contract.execute({"a": 3, "b": 4}, available_mana=20)
        
        # Check history
        self.assertEqual(len(self.contract.execution_history), 2)
        
        # Verify history entries
        latest_execution = self.contract.execution_history[-1]
        self.assertIn("timestamp", latest_execution)
        self.assertIn("execution_time", latest_execution)
        self.assertIn("mana_used", latest_execution)
        self.assertIn("state_size", latest_execution)

    def test_get_metrics(self):
        """Test contract metrics calculation."""
        # Execute contract
        self.contract.execute({"a": 5, "b": 3}, available_mana=20)
        
        metrics = self.contract.get_metrics()
        
        self.assertEqual(metrics["contract_id"], "test_contract")
        self.assertEqual(metrics["version"], "1.0")
        self.assertEqual(metrics["creator"], "test_creator")
        self.assertEqual(metrics["execution_count"], 1)
        self.assertEqual(metrics["total_mana_consumed"], 10)
        self.assertGreater(metrics["state_size"], 0)

    def test_state_size_limit(self):
        """Test contract state size limitations."""
        # Create contract that grows state
        growing_code = """
def execute(input_data, state):
    # Add large data to state
    state['data'] = 'x' * input_data['size']
    return len(state['data'])
"""
        growing_contract = SmartContract(
            contract_id="growing_contract",
            code=growing_code,
            creator="test_creator",
            mana_cost=10
        )
        
        # Set small state size limit
        growing_contract.restrictions["max_state_size"] = 100
        
        # Execute with small state update
        growing_contract.execute({"size": 50}, available_mana=20)
        
        # Execute with too large state update
        with self.assertRaises(ContractExecutionError) as context:
            growing_contract.execute({"size": 200}, available_mana=20)
        
        self.assertIn("State size limit exceeded", str(context.exception))

    def test_dependencies(self):
        """Test contract dependency management."""
        dependency_id = "dependency_contract"
        
        # Add dependency
        self.contract.dependencies.add(dependency_id)
        self.assertIn(dependency_id, self.contract.dependencies)
        
        # Verify serialization includes dependencies
        contract_dict = self.contract.to_dict()
        self.assertIn(dependency_id, contract_dict["dependencies"])
        
        # Create new contract from dict and verify dependencies
        new_contract = SmartContract.from_dict(contract_dict)
        self.assertIn(dependency_id, new_contract.dependencies)

    def test_metadata_updates(self):
        """Test contract metadata management."""
        # Update metadata
        self.contract.metadata["description"] = "Test contract"
        self.contract.metadata["tags"].add("test")
        
        # Verify serialization includes metadata
        contract_dict = self.contract.to_dict()
        self.assertEqual(contract_dict["metadata"]["description"], "Test contract")
        self.assertIn("test", contract_dict["metadata"]["tags"])
        
        # Create new contract and verify metadata
        new_contract = SmartContract.from_dict(contract_dict)
        self.assertEqual(new_contract.metadata["description"], "Test contract")
        self.assertIn("test", new_contract.metadata["tags"])

if __name__ == '__main__':
    unittest.main()

# ==================== /home/matt/icn-prototype/tests/unit/__init__.py ====================



# ==================== /home/matt/icn-prototype/system/marketplace.py ====================

from typing import Dict

class Listing:
    def __init__(self, id, seller, item, price):
        self.id = id
        self.seller = seller
        self.item = item
        self.price = price

class Order:
    def __init__(self, id, buyer, listing):
        self.id = id
        self.buyer = buyer
        self.listing = listing
        self.status = "pending"

class Marketplace:
    def __init__(self, blockchain, did_registry):
        self.blockchain = blockchain
        self.did_registry = did_registry
        self.listings: Dict[str, Listing] = {}
        self.orders: Dict[str, Order] = {}

    def create_listing(self, listing_id, seller_did, item, price):
        seller = self.did_registry.resolve_did(seller_did)
        if not seller:
            return None
        
        listing = Listing(listing_id, seller_did, item, price)
        self.listings[listing_id] = listing
        self.blockchain.add_new_block(f"Listing created: {listing_id}", 1)  # Assume shard 1 for marketplace
        return listing_id

    def remove_listing(self, listing_id, seller_did):
        listing = self.listings.get(listing_id)
        if listing and listing.seller == seller_did:
            del self.listings[listing_id]
            self.blockchain.add_new_block(f"Listing removed: {listing_id}", 1)
            return True
        return False

    def place_order(self, order_id, buyer_did, listing_id):
        listing = self.listings.get(listing_id)
        buyer = self.did_registry.resolve_did(buyer_did)
        if not listing or not buyer:
            return False
        
        order = Order(order_id, buyer_did, listing)
        self.orders[order_id] = order
        self.blockchain.add_new_block(f"Order placed: {order_id}", 1)
        return True

    def complete_order(self, order_id):
        order = self.orders.get(order_id)
        if not order:
            return None
        
        # In a real system, you'd implement escrow release here
        order.status = "completed"
        self.blockchain.add_new_block(f"Order completed: {order_id}", 1)
        return order

    def get_listing(self, listing_id):
        return self.listings.get(listing_id)

    def get_order(self, order_id):
        return self.orders.get(order_id)

    def list_listings(self):
        return self.listings

    def list_orders(self):
        return self.orders

    def get_seller_reputation(self, seller_did):
        seller = self.did_registry.resolve_did(seller_did)
        if seller:
            return seller.get_reputation_scores().get("marketplace", 0)
        return 0

# ==================== /home/matt/icn-prototype/system/reputation.py ====================

# system/reputation.py

from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
import logging
from dataclasses import dataclass, field
import math

logger = logging.getLogger(__name__)

@dataclass
class ReputationEvent:
    """Represents a reputation-changing event."""
    category: str
    score: float
    timestamp: datetime
    evidence: Optional[Dict] = None
    decay_rate: float = 0.1

    def get_current_value(self, current_time: datetime) -> float:
        """Calculate the current value of the reputation event with decay."""
        age = (current_time - self.timestamp).total_seconds() / (24 * 3600)  # age in days
        return self.score * math.exp(-self.decay_rate * age)

class ReputationCategory:
    """Manages reputation for a specific category."""
    
    def __init__(self, name: str, weight: float = 1.0, 
                 decay_rate: float = 0.1):
        self.name = name
        self.weight = weight
        self.decay_rate = decay_rate
        self.events: List[ReputationEvent] = []
        self.minimum_score = 0.0
        self.maximum_score = float('inf')

    def add_event(self, score: float, evidence: Optional[Dict] = None) -> None:
        """Add a new reputation event."""
        event = ReputationEvent(
            category=self.name,
            score=score,
            timestamp=datetime.now(),
            evidence=evidence,
            decay_rate=self.decay_rate
        )
        self.events.append(event)

    def get_current_score(self) -> float:
        """Calculate current score with decay."""
        current_time = datetime.now()
        total_score = sum(event.get_current_value(current_time) 
                         for event in self.events)
        return max(min(total_score, self.maximum_score), self.minimum_score)

    def prune_old_events(self, max_age_days: int = 30) -> None:
        """Remove events older than specified age."""
        cutoff_time = datetime.now() - timedelta(days=max_age_days)
        self.events = [event for event in self.events 
                      if event.timestamp >= cutoff_time]

class ReputationSystem:
    """Enhanced reputation system for ICN."""
    
    def __init__(self):
        self.categories: Dict[str, ReputationCategory] = {
            "validation": ReputationCategory("validation", 1.0, 0.1),
            "voting": ReputationCategory("voting", 1.2, 0.05),
            "proposal_creation": ReputationCategory("proposal_creation", 1.5, 0.03),
            "development": ReputationCategory("development", 2.0, 0.02),
            "budget_management": ReputationCategory("budget_management", 1.8, 0.08),
            "community_building": ReputationCategory("community_building", 1.3, 0.04),
            "resource_sharing": ReputationCategory("resource_sharing", 1.4, 0.06),
            "cooperative_growth": ReputationCategory("cooperative_growth", 1.6, 0.03),
            "conflict_resolution": ReputationCategory("conflict_resolution", 1.7, 0.05),
            "sustainability": ReputationCategory("sustainability", 1.5, 0.04),
            "participation": ReputationCategory("participation", 1.1, 0.07),
            "innovation": ReputationCategory("innovation", 1.9, 0.02),
        }
        self.user_reputations: Dict[str, Dict[str, ReputationCategory]] = {}
        self.user_metadata: Dict[str, Dict] = {}
        self.registered_users: Set[str] = set()
        
    def add_user(self, user_id: str, metadata: Optional[Dict] = None) -> None:
        """Initialize reputation categories for a new user."""
        if user_id not in self.user_reputations:
            self.user_reputations[user_id] = {
                name: ReputationCategory(name, cat.weight, cat.decay_rate)
                for name, cat in self.categories.items()
            }
            self.user_metadata[user_id] = metadata or {}
            self.registered_users.add(user_id)
            logger.info(f"Initialized reputation for user: {user_id}")

    def remove_user(self, user_id: str) -> bool:
        """Remove a user from the reputation system."""
        if user_id in self.user_reputations:
            del self.user_reputations[user_id]
            del self.user_metadata[user_id]
            self.registered_users.remove(user_id)
            logger.info(f"Removed user: {user_id}")
            return True
        return False

    def get_all_users(self) -> List[str]:
        """Get list of all registered users."""
        return list(self.registered_users)

    def update_reputation(self, user_id: str, score: float, 
                         category: str, evidence: Optional[Dict] = None) -> bool:
        """Update a user's reputation with evidence."""
        if user_id not in self.user_reputations:
            logger.warning(f"Unknown user: {user_id}")
            return False
        
        if category not in self.user_reputations[user_id]:
            logger.warning(f"Unknown category: {category}")
            return False

        if score == 0:
            return True

        self.user_reputations[user_id][category].add_event(score, evidence)
        logger.info(f"Updated reputation for {user_id} in {category}: {score}")
        
        # Update participation category automatically
        if category != "participation":
            self.user_reputations[user_id]["participation"].add_event(
                abs(score) * 0.1,  # Small participation score for any activity
                {"source_category": category}
            )
        
        return True

    def get_reputation(self, user_id: str) -> Dict[str, float]:
        """Get current reputation scores for a user."""
        if user_id not in self.user_reputations:
            return {}
        
        return {
            category: rep_category.get_current_score()
            for category, rep_category in self.user_reputations[user_id].items()
        }

    def get_total_reputation(self, user_id: str) -> float:
        """Calculate total weighted reputation score."""
        if user_id not in self.user_reputations:
            return 0.0
        
        scores = self.get_reputation(user_id)
        weighted_scores = [
            score * self.categories[category].weight
            for category, score in scores.items()
        ]
        return sum(weighted_scores)

    def get_user_ranking(self, category: Optional[str] = None) -> List[tuple]:
        """Get users ranked by reputation in a category or overall."""
        if category and category not in self.categories:
            return []

        rankings = []
        for user_id in self.registered_users:
            if category:
                score = self.get_reputation(user_id).get(category, 0)
            else:
                score = self.get_total_reputation(user_id)
            rankings.append((user_id, score))

        return sorted(rankings, key=lambda x: x[1], reverse=True)

    def apply_decay(self) -> None:
        """Apply reputation decay to all users."""
        current_time = datetime.now()
        for user_reputations in self.user_reputations.values():
            for category in user_reputations.values():
                category.prune_old_events()

    def get_reputation_history(self, user_id: str, category: str,
                             days: int = 30) -> List[Dict]:
        """Get historical reputation events for a category."""
        if user_id not in self.user_reputations:
            return []
        
        category_rep = self.user_reputations[user_id].get(category)
        if not category_rep:
            return []

        cutoff_time = datetime.now() - timedelta(days=days)
        history = []
        
        for event in category_rep.events:
            if event.timestamp >= cutoff_time:
                history.append({
                    'timestamp': event.timestamp,
                    'score': event.score,
                    'evidence': event.evidence,
                    'current_value': event.get_current_value(datetime.now())
                })
                
        return sorted(history, key=lambda x: x['timestamp'])

    def get_category_thresholds(self, category: str) -> Optional[Dict[str, float]]:
        """Get the minimum and maximum thresholds for a category."""
        if category not in self.categories:
            return None
            
        return {
            'minimum': self.categories[category].minimum_score,
            'maximum': self.categories[category].maximum_score
        }

    def set_category_thresholds(self, category: str, 
                              minimum: float, maximum: float) -> bool:
        """Set the minimum and maximum thresholds for a category."""
        if category not in self.categories:
            return False
            
        if minimum > maximum:
            return False
            
        self.categories[category].minimum_score = minimum
        self.categories[category].maximum_score = maximum
        return True

    def get_system_stats(self) -> Dict:
        """Get system-wide reputation statistics."""
        stats = {
            'total_users': len(self.registered_users),
            'total_events': 0,
            'category_averages': {},
            'top_users': self.get_user_ranking()[:10]
        }
        
        for category in self.categories:
            scores = []
            total_events = 0
            for user_id in self.registered_users:
                user_rep = self.user_reputations.get(user_id, {}).get(category)
                if user_rep:
                    scores.append(user_rep.get_current_score())
                    total_events += len(user_rep.events)
            
            if scores:
                stats['category_averages'][category] = sum(scores) / len(scores)
            else:
                stats['category_averages'][category] = 0
            
            stats['total_events'] += total_events
        
        return stats

# ==================== /home/matt/icn-prototype/system/governance.py ====================

# system/governance.py

from typing import Dict, List, Optional, Union
from datetime import datetime, timedelta
import logging
from dataclasses import dataclass, field
import math
import json

logger = logging.getLogger(__name__)

@dataclass
class Proposal:
    """Represents a governance proposal in the ICN system."""
    id: str
    title: str
    description: str
    creator: str
    proposal_type: str
    options: List[str]
    amount: Optional[float] = None
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    status: str = "pending"
    metadata: Dict = field(default_factory=dict)
    votes: Dict[str, int] = field(default_factory=dict)
    vote_weights: Dict[str, float] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert proposal to dictionary format."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'creator': self.creator,
            'type': self.proposal_type,
            'options': self.options,
            'amount': self.amount,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'status': self.status,
            'metadata': self.metadata,
            'votes': self.votes,
            'vote_weights': self.vote_weights
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Proposal':
        """Create proposal from dictionary."""
        proposal = cls(
            id=data['id'],
            title=data['title'],
            description=data['description'],
            creator=data['creator'],
            proposal_type=data['type'],
            options=data['options'],
            amount=data.get('amount'),
            start_time=datetime.fromisoformat(data['start_time']),
            status=data['status'],
            metadata=data.get('metadata', {})
        )
        if data.get('end_time'):
            proposal.end_time = datetime.fromisoformat(data['end_time'])
        proposal.votes = data.get('votes', {})
        proposal.vote_weights = data.get('vote_weights', {})
        return proposal

class VotingSystem:
    """Manages voting mechanics for proposals."""
    
    def __init__(self, quorum_percentage: float = 0.4):
        self.quorum_percentage = quorum_percentage
        self.vote_records: Dict[str, Dict[str, Dict]] = {}

    def cast_vote(self, proposal_id: str, voter_id: str, choice: str,
                  weight: float = 1.0) -> bool:
        """Cast a weighted vote on a proposal."""
        if proposal_id not in self.vote_records:
            self.vote_records[proposal_id] = {}
            
        self.vote_records[proposal_id][voter_id] = {
            'choice': choice,
            'weight': weight,
            'timestamp': datetime.now()
        }
        return True

    def get_results(self, proposal_id: str) -> Dict[str, float]:
        """Calculate weighted voting results."""
        if proposal_id not in self.vote_records:
            return {}
            
        results = {}
        for vote_info in self.vote_records[proposal_id].values():
            choice = vote_info['choice']
            weight = vote_info['weight']
            results[choice] = results.get(choice, 0) + weight
            
        return results

    def has_quorum(self, proposal_id: str, total_voters: int) -> bool:
        """Check if proposal has reached quorum."""
        if proposal_id not in self.vote_records:
            return False
            
        participation = len(self.vote_records[proposal_id]) / total_voters
        return participation >= self.quorum_percentage

class Governance:
    """Main governance system for the ICN."""
    
    def __init__(self, blockchain, reputation_system):
        self.blockchain = blockchain
        self.reputation_system = reputation_system
        self.proposals: Dict[str, Proposal] = {}
        self.voting_system = VotingSystem()
        self.bylaws: Dict[str, str] = {}
        self.funds: float = 0
        self.approval_thresholds = {
            "constitution": 0.75,  # Constitutional changes require 75% approval
            "bylaw": 0.66,        # Bylaw changes require 66% approval
            "budget": 0.60,       # Budget proposals require 60% approval
            "standard": 0.51      # Standard proposals require simple majority
        }

    def create_proposal(self, proposal: Proposal) -> bool:
        """Create a new governance proposal."""
        try:
            # Validate creator's reputation
            creator_rep = self.reputation_system.get_reputation(proposal.creator)
            if creator_rep.get('proposal_creation', 0) < 10:
                logger.warning(f"Insufficient reputation for proposal creation: {proposal.creator}")
                return False

            # Validate proposal type
            if proposal.proposal_type not in self.approval_thresholds:
                logger.error(f"Invalid proposal type: {proposal.proposal_type}")
                return False

            self.proposals[proposal.id] = proposal
            
            # Create blockchain transaction
            transaction = {
                'type': 'proposal_creation',
                'proposal_id': proposal.id,
                'creator': proposal.creator,
                'timestamp': datetime.now().isoformat()
            }
            
            self.blockchain.add_transaction(transaction)
            logger.info(f"Created proposal: {proposal.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create proposal: {e}")
            return False

    def start_voting(self, proposal_id: str, duration_days: int = 7) -> bool:
        """Start the voting period for a proposal."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "pending":
            return False

        proposal.status = "active"
        proposal.start_time = datetime.now()
        proposal.end_time = proposal.start_time + timedelta(days=duration_days)

        transaction = {
            'type': 'voting_start',
            'proposal_id': proposal_id,
            'start_time': proposal.start_time.isoformat(),
            'end_time': proposal.end_time.isoformat()
        }

        self.blockchain.add_transaction(transaction)
        logger.info(f"Started voting for proposal: {proposal_id}")
        return True

    def cast_vote(self, proposal_id: str, voter_id: str, choice: str) -> bool:
        """Cast a vote on an active proposal."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "active":
            return False

        if datetime.now() > proposal.end_time:
            logger.warning(f"Voting period ended for proposal: {proposal_id}")
            return False

        # Calculate voting power based on reputation
        reputation = self.reputation_system.get_reputation(voter_id)
        voting_power = self._calculate_voting_power(reputation)

        # Record vote
        if self.voting_system.cast_vote(proposal_id, voter_id, choice, voting_power):
            transaction = {
                'type': 'vote_cast',
                'proposal_id': proposal_id,
                'voter': voter_id,
                'choice': choice,
                'weight': voting_power
            }
            self.blockchain.add_transaction(transaction)

            # Update voter's reputation
            self.reputation_system.update_reputation(
                voter_id,
                1.0,
                'voting',
                {'proposal_id': proposal_id}
            )

            logger.info(f"Recorded vote from {voter_id} on proposal {proposal_id}")
            return True

        return False

    def _calculate_voting_power(self, reputation: Dict[str, float]) -> float:
        """Calculate voting power based on reputation scores."""
        # Calculate base voting power from reputation
        base_power = sum(reputation.values()) / len(reputation)
        
        # Apply square root to prevent excessive concentration of power
        return math.sqrt(max(1.0, base_power))

    def finalize_proposal(self, proposal_id: str) -> bool:
        """Finalize a proposal after voting period."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "active":
            return False

        if datetime.now() < proposal.end_time:
            logger.warning(f"Voting period still active for proposal: {proposal_id}")
            return False

        results = self.voting_system.get_results(proposal_id)
        if not results:
            proposal.status = "failed"
            return False

        total_voters = len(self.reputation_system.get_all_users())
        if not self.voting_system.has_quorum(proposal_id, total_voters):
            proposal.status = "failed"
            logger.info(f"Proposal {proposal_id} failed due to lack of quorum")
            return False

        # Calculate approval percentage
        total_votes = sum(results.values())
        approval_percentage = results.get("approve", 0) / total_votes

        # Get required threshold
        threshold = self.approval_thresholds[proposal.proposal_type]

        if approval_percentage >= threshold:
            proposal.status = "approved"
            self._implement_proposal(proposal)
        else:
            proposal.status = "rejected"

        transaction = {
            'type': 'proposal_finalization',
            'proposal_id': proposal_id,
            'status': proposal.status,
            'results': results
        }
        self.blockchain.add_transaction(transaction)

        logger.info(f"Finalized proposal {proposal_id} with status: {proposal.status}")
        return True

    def _implement_proposal(self, proposal: Proposal) -> None:
        """Implement an approved proposal."""
        implementation_handlers = {
            "budget": self._implement_budget_proposal,
            "bylaw": self._implement_bylaw_proposal,
            "constitution": self._implement_constitution_proposal,
        }
        
        handler = implementation_handlers.get(proposal.proposal_type)
        if handler:
            handler(proposal)

    def _implement_budget_proposal(self, proposal: Proposal) -> None:
        """Implement a budget proposal."""
        if proposal.amount and self.funds >= proposal.amount:
            self.funds -= proposal.amount
            transaction = {
                'type': 'budget_execution',
                'proposal_id': proposal.id,
                'amount': proposal.amount
            }
            self.blockchain.add_transaction(transaction)

    def _implement_bylaw_proposal(self, proposal: Proposal) -> None:
        """Implement a bylaw proposal."""
        self.bylaws[proposal.title] = proposal.description
        transaction = {
            'type': 'bylaw_update',
            'proposal_id': proposal.id,
            'title': proposal.title
        }
        self.blockchain.add_transaction(transaction)

    def _implement_constitution_proposal(self, proposal: Proposal) -> None:
        """Implement a constitutional proposal."""
        transaction = {
            'type': 'constitution_update',
            'proposal_id': proposal.id,
            'changes': proposal.metadata.get('changes', {})
        }
        self.blockchain.add_transaction(transaction)

    def get_proposal(self, proposal_id: str) -> Optional[Proposal]:
        """Get a specific proposal."""
        return self.proposals.get(proposal_id)

    def get_active_proposals(self) -> List[Proposal]:
        """Get all currently active proposals."""
        return [p for p in self.proposals.values() if p.status == "active"]

    def get_proposal_metrics(self) -> Dict:
        """Get metrics about proposal activity."""
        return {
            'total_proposals': len(self.proposals),
            'active_proposals': len([p for p in self.proposals.values() if p.status == "active"]),
            'approved_proposals': len([p for p in self.proposals.values() if p.status == "approved"]),
            'rejected_proposals': len([p for p in self.proposals.values() if p.status == "rejected"]),
            'average_participation': self._calculate_average_participation()
        }

    def _calculate_average_participation(self) -> float:
        """Calculate average participation rate in voted proposals."""
        voted_proposals = [p for p in self.proposals.values() 
                         if p.status in ["approved", "rejected"]]
        if not voted_proposals:
            return 0.0

        total_users = len(self.reputation_system.get_all_users())
        participation_rates = []

        for proposal in voted_proposals:
            if proposal.id in self.voting_system.vote_records:
                participation = len(self.voting_system.vote_records[proposal.id]) / total_users
                participation_rates.append(participation)

        return sum(participation_rates) / len(participation_rates) if participation_rates else 0.0

# ==================== /home/matt/icn-prototype/system/storage.py ====================

import hashlib
from typing import Dict, List

class DataChunk:
    def __init__(self, data: bytes):
        self.data = data
        self.hash = hashlib.sha256(data).hexdigest()

class DistributedStorage:
    def __init__(self, blockchain):
        self.blockchain = blockchain
        self.data_chunks: Dict[str, DataChunk] = {}
        self.file_mappings: Dict[str, List[str]] = {}

    def store_file(self, file_name: str, data: bytes) -> str:
        chunk_size = 1024 * 1024  # 1 MB chunks
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        
        chunk_hashes = []
        for chunk in chunks:
            data_chunk = DataChunk(chunk)
            self.data_chunks[data_chunk.hash] = data_chunk
            chunk_hashes.append(data_chunk.hash)
        
        file_hash = hashlib.sha256(("".join(chunk_hashes)).encode()).hexdigest()
        self.file_mappings[file_hash] = chunk_hashes
        
        self.blockchain.add_new_block(f"File stored: {file_hash}", 2)  # Assume shard 2 for storage
        return file_hash

    def retrieve_file(self, file_hash: str) -> bytes:
        chunk_hashes = self.file_mappings.get(file_hash)
        if not chunk_hashes:
            return None
        
        file_data = b""
        for chunk_hash in chunk_hashes:
            chunk = self.data_chunks.get(chunk_hash)
            if chunk:
                file_data += chunk.data
            else:
                return None  # File is incomplete
        
        return file_data

    def delete_file(self, file_hash: str) -> bool:
        chunk_hashes = self.file_mappings.get(file_hash)
        if not chunk_hashes:
            return False
        
        for chunk_hash in chunk_hashes:
            if chunk_hash in self.data_chunks:
                del self.data_chunks[chunk_hash]
        
        del self.file_mappings[file_hash]
        self.blockchain.add_new_block(f"File deleted: {file_hash}", 2)
        return True

# ==================== /home/matt/icn-prototype/system/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/blockchain.py ====================

# blockchain/blockchain.py

import hashlib
import time
import math
import random
import json
import signal
import logging
from typing import Dict, List, Optional, Tuple, Set, Any, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from cryptography.exceptions import InvalidKey
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)

@dataclass
class Transaction:
    """Represents a transaction in the ICN blockchain."""
    sender: str
    receiver: str
    action: str
    data: Dict
    timestamp: datetime = field(default_factory=datetime.now)
    signature: Optional[bytes] = None
    shard_id: Optional[int] = None
    transaction_id: str = field(init=False)
    
    def __post_init__(self):
        """Initialize transaction ID after creation."""
        self.transaction_id = self.calculate_id()
    
    def calculate_id(self) -> str:
        """Calculate unique transaction ID."""
        tx_data = {
            'sender': self.sender,
            'receiver': self.receiver,
            'action': self.action,
            'data': self.data,
            'timestamp': self.timestamp.isoformat(),
            'shard_id': self.shard_id
        }
        return hashlib.sha256(json.dumps(tx_data, sort_keys=True).encode()).hexdigest()
    
    def to_dict(self) -> Dict:
        """Convert transaction to dictionary format."""
        return {
            'transaction_id': self.transaction_id,
            'sender': self.sender,
            'receiver': self.receiver,
            'action': self.action,
            'data': self.data,
            'timestamp': self.timestamp.isoformat(),
            'signature': self.signature.hex() if self.signature else None,
            'shard_id': self.shard_id
        }
        
    @classmethod
    def from_dict(cls, data: Dict) -> 'Transaction':
        """Create transaction from dictionary."""
        timestamp = datetime.fromisoformat(data['timestamp'])
        signature = bytes.fromhex(data['signature']) if data.get('signature') else None
        
        return cls(
            sender=data['sender'],
            receiver=data['receiver'],
            action=data['action'],
            data=data['data'],
            timestamp=timestamp,
            signature=signature,
            shard_id=data.get('shard_id')
        )

    def validate(self) -> bool:
        """Validate transaction structure and data."""
        try:
            # Validate basic structure
            if not all([self.sender, self.receiver, self.action]):
                return False
            
            # Validate timestamp
            if self.timestamp > datetime.now() + timedelta(minutes=5):
                return False
                
            # Validate data structure
            if not isinstance(self.data, dict):
                return False
                
            # Validate transaction ID
            if self.transaction_id != self.calculate_id():
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Transaction validation failed: {e}")
            return False

@dataclass
class Block:
    """Represents a block in the ICN blockchain."""
    index: int
    previous_hash: str
    timestamp: datetime
    transactions: List[Transaction]
    validator: str
    shard_id: int
    hash: str = ""
    nonce: int = 0
    merkle_root: str = ""
    cross_shard_refs: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    version: str = "1.0"
    
    def __post_init__(self):
        """Initialize block after creation."""
        if not self.merkle_root:
            self.merkle_root = self.calculate_merkle_root()
        if not self.hash:
            self.hash = self.calculate_hash()
        self.metadata['created_at'] = datetime.now().isoformat()

    def calculate_merkle_root(self) -> str:
        """Calculate the Merkle root of transactions."""
        if not self.transactions:
            return hashlib.sha256(b"empty").hexdigest()
        
        leaves = [hashlib.sha256(json.dumps(tx.to_dict()).encode()).hexdigest()
                 for tx in self.transactions]
        
        while len(leaves) > 1:
            if len(leaves) % 2 == 1:
                leaves.append(leaves[-1])
            leaves = [hashlib.sha256((a + b).encode()).hexdigest()
                     for a, b in zip(leaves[::2], leaves[1::2])]
        
        return leaves[0]

    def calculate_hash(self) -> str:
        """Calculate the hash of the block."""
        block_dict = {
            'index': self.index,
            'previous_hash': self.previous_hash,
            'timestamp': self.timestamp.isoformat(),
            'merkle_root': self.merkle_root,
            'validator': self.validator,
            'nonce': self.nonce,
            'shard_id': self.shard_id,
            'cross_shard_refs': self.cross_shard_refs,
            'version': self.version
        }
        return hashlib.sha256(json.dumps(block_dict, sort_keys=True).encode()).hexdigest()

    def to_dict(self) -> Dict:
        """Convert block to dictionary format."""
        return {
            'index': self.index,
            'previous_hash': self.previous_hash,
            'timestamp': self.timestamp.isoformat(),
            'transactions': [tx.to_dict() for tx in self.transactions],
            'validator': self.validator,
            'hash': self.hash,
            'nonce': self.nonce,
            'merkle_root': self.merkle_root,
            'shard_id': self.shard_id,
            'cross_shard_refs': self.cross_shard_refs,
            'metadata': self.metadata,
            'version': self.version
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Block':
        """Create block from dictionary."""
        transactions = [Transaction.from_dict(tx) for tx in data['transactions']]
        timestamp = datetime.fromisoformat(data['timestamp'])
        
        return cls(
            index=data['index'],
            previous_hash=data['previous_hash'],
            timestamp=timestamp,
            transactions=transactions,
            validator=data['validator'],
            shard_id=data['shard_id'],
            hash=data['hash'],
            nonce=data['nonce'],
            merkle_root=data['merkle_root'],
            cross_shard_refs=data.get('cross_shard_refs', []),
            metadata=data.get('metadata', {}),
            version=data.get('version', "1.0")
        )

    def validate(self, previous_block: Optional['Block'] = None) -> bool:
        """Validate block structure and consistency."""
        try:
            # Validate hash
            if self.hash != self.calculate_hash():
                return False
                
            # Validate merkle root
            if self.merkle_root != self.calculate_merkle_root():
                return False
                
            # Validate timestamp
            if self.timestamp > datetime.now() + timedelta(minutes=5):
                return False
                
            # Validate transactions
            if not all(tx.validate() for tx in self.transactions):
                return False
                
            # Validate against previous block if provided
            if previous_block:
                if self.previous_hash != previous_block.hash:
                    return False
                if self.index != previous_block.index + 1:
                    return False
                if self.timestamp <= previous_block.timestamp:
                    return False
                    
            return True
            
        except Exception as e:
            logger.error(f"Block validation failed: {e}")
            return False
            class Shard:
    """Represents a blockchain shard."""
    
    def __init__(self, shard_id: int, max_transactions_per_block: int = 100):
        self.shard_id = shard_id
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.height = 0
        self.max_transactions_per_block = max_transactions_per_block
        self.last_block_time = datetime.now()
        self.state: Dict = {}
        self.metrics: Dict = {
            'total_transactions': 0,
            'average_block_time': 0,
            'blocks_created': 0,
            'pending_count': 0
        }
        self._create_genesis_block()

    def _create_genesis_block(self) -> None:
        """Create genesis block for this shard."""
        genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=self.shard_id
        )
        self.chain.append(genesis_block)
        self.height = 1
        self.last_block_time = genesis_block.timestamp
        self.metrics['blocks_created'] = 1

    def add_transaction(self, transaction: Transaction) -> bool:
        """Add a new transaction to pending pool."""
        if transaction.shard_id != self.shard_id:
            return False
            
        if len(self.pending_transactions) >= self.max_transactions_per_block * 2:
            return False
            
        if not transaction.validate():
            return False
            
        self.pending_transactions.append(transaction)
        self.metrics['pending_count'] = len(self.pending_transactions)
        return True

    def create_block(self, validator: str) -> Optional[Block]:
        """Create a new block from pending transactions."""
        if not self.pending_transactions:
            return None
            
        transactions = self.pending_transactions[:self.max_transactions_per_block]
        
        new_block = Block(
            index=self.height,
            previous_hash=self.chain[-1].hash,
            timestamp=datetime.now(),
            transactions=transactions,
            validator=validator,
            shard_id=self.shard_id
        )
        
        return new_block

    def add_block(self, block: Block) -> bool:
        """Add a validated block to the shard chain."""
        if block.shard_id != self.shard_id:
            return False
            
        if block.index != self.height:
            return False
            
        if not block.validate(self.chain[-1]):
            return False
            
        # Update metrics
        block_time = (block.timestamp - self.last_block_time).total_seconds()
        self.metrics['average_block_time'] = (
            (self.metrics['average_block_time'] * self.metrics['blocks_created'] + block_time) /
            (self.metrics['blocks_created'] + 1)
        )
        self.metrics['blocks_created'] += 1
        self.metrics['total_transactions'] += len(block.transactions)
        
        # Remove included transactions from pending pool
        tx_ids = {tx.transaction_id for tx in block.transactions}
        self.pending_transactions = [
            tx for tx in self.pending_transactions 
            if tx.transaction_id not in tx_ids
        ]
        self.metrics['pending_count'] = len(self.pending_transactions)
        
        # Add block to chain
        self.chain.append(block)
        self.height += 1
        self.last_block_time = block.timestamp
        
        return True

    def get_latest_block(self) -> Block:
        """Get the latest block in this shard."""
        return self.chain[-1]

    def validate_chain(self) -> bool:
        """Validate the entire shard chain."""
        for i in range(1, len(self.chain)):
            if not self.chain[i].validate(self.chain[i-1]):
                return False
        return True

    def get_metrics(self) -> Dict:
        """Get shard metrics and statistics."""
        return {
            'shard_id': self.shard_id,
            'height': self.height,
            'pending_transactions': len(self.pending_transactions),
            'last_block_time': self.last_block_time.isoformat(),
            **self.metrics
        }


@dataclass
class Node:
    """Represents a node in the ICN network."""
    
    def __init__(self, node_id: str, cooperative_id: Optional[str] = None,
                 initial_stake: float = 10.0):
        self.node_id = node_id
        self.cooperative_id = cooperative_id
        self.reputation_scores = {
            'validation': 0.0,
            'proposal_creation': 0.0,
            'voting': 0.0,
            'resource_sharing': 0.0,
            'cooperative_growth': 0.0,
            'community_building': 0.0,
            'conflict_resolution': 0.0,
            'transaction_validation': 0.0,
            'data_availability': 0.0,
            'network_stability': 0.0,
            'innovation': 0.0,
            'sustainability': 0.0
        }
        self.stake = initial_stake
        self.cooperative_interactions: List[str] = []
        self.validation_history: List[Dict] = []
        self.resource_usage: Dict[str, float] = {
            'computation': 0.0,
            'storage': 0.0,
            'bandwidth': 0.0,
            'memory': 0.0,
            'energy': 0.0
        }
        self.shard_assignments: Set[int] = set()
        self.active_shards: Dict[int, datetime] = {}
        self.last_validation = 0
        self.total_validations = 0
        self.cooldown = 0
        self.total_cycles = 0
        self.cycles_since_update: Dict[str, int] = {}
        self.performance_metrics: Dict[str, float] = {
            'response_time': 0.0,
            'availability': 100.0,
            'validation_success_rate': 100.0,
            'network_reliability': 100.0
        }
        self.metadata: Dict = {
            'creation_time': datetime.now(),
            'last_active': datetime.now(),
            'version': "1.0",
            'capabilities': set(),
            'status': "active"
        }

    def update_reputation(self, category: str, score: float, 
                         cooperative_id: Optional[str] = None,
                         evidence: Optional[Dict] = None) -> None:
        """Update reputation score for a category with evidence."""
        if category in self.reputation_scores:
            old_score = self.reputation_scores[category]
            self.reputation_scores[category] = max(0, old_score + score)
            
            if cooperative_id:
                self.cooperative_interactions.append(cooperative_id)
                
            if evidence:
                self.validation_history.append({
                    'timestamp': datetime.now(),
                    'category': category,
                    'score_change': score,
                    'evidence': evidence
                })
            
            self.metadata['last_active'] = datetime.now()
            
            # Trim interaction history to last 1000 interactions
            if len(self.cooperative_interactions) > 1000:
                self.cooperative_interactions = self.cooperative_interactions[-1000:]

    def assign_to_shard(self, shard_id: int) -> bool:
        """Assign node to a shard."""
        if len(self.active_shards) >= 3:  # Maximum 3 active shards per node
            return False
            
        self.shard_assignments.add(shard_id)
        self.active_shards[shard_id] = datetime.now()
        return True

    def remove_from_shard(self, shard_id: int) -> bool:
        """Remove node from a shard."""
        if shard_id in self.active_shards:
            del self.active_shards[shard_id]
            self.shard_assignments.discard(shard_id)
            return True
        return False

    def can_validate(self, shard_id: Optional[int] = None) -> bool:
        """Check if node can validate blocks."""
        current_time = time.time()
        
        # Basic validation checks
        if self.cooldown > 0:
            return False
        if current_time - self.last_validation < 10:  # 10 second minimum between validations
            return False
        if self.metadata['status'] != "active":
            return False
            
        # Shard-specific validation
        if shard_id is not None:
            if shard_id not in self.active_shards:
                return False
            if (datetime.now() - self.active_shards[shard_id]).total_seconds() > 3600:  # 1 hour timeout
                return False
                
        return True

    def enter_cooldown(self, cooldown_period: int) -> None:
        """Put node into cooldown period."""
        self.cooldown = cooldown_period
        self.metadata['status'] = "cooldown"

    def update_metrics(self, metrics: Dict[str, float]) -> None:
        """Update node performance metrics."""
        self.performance_metrics.update(metrics)
        self.metadata['last_active'] = datetime.now()

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def to_dict(self) -> Dict:
        """Convert node state to dictionary."""
        return {
            'node_id': self.node_id,
            'cooperative_id': self.cooperative_id,
            'reputation_scores': self.reputation_scores,
            'stake': self.stake,
            'shard_assignments': list(self.shard_assignments),
            'performance_metrics': self.performance_metrics,
            'resource_usage': self.resource_usage,
            'metadata': self.metadata,
            'status': self.metadata['status']
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Node':
        """Create node from dictionary."""
        node = cls(
            node_id=data['node_id'],
            cooperative_id=data['cooperative_id'],
            initial_stake=data['stake']
        )
        node.reputation_scores = data['reputation_scores']
        node.shard_assignments = set(data['shard_assignments'])
        node.performance_metrics = data['performance_metrics']
        node.resource_usage = data['resource_usage']
        node.metadata = data['metadata']
        
        return node
        class ProofOfCooperation:
    """Implements the Proof of Cooperation consensus mechanism."""
    
    def __init__(self, min_reputation: float = 10.0, cooldown_blocks: int = 3):
        self.min_reputation = min_reputation
        self.cooldown_blocks = cooldown_blocks
        self.cooperation_scores: Dict[str, float] = {}
        self.reputation_weights = {
            'cooperative_growth': 1.5,
            'proposal_participation': 1.2,
            'transaction_validation': 1.0,
            'resource_sharing': 1.3,
            'conflict_resolution': 1.1,
            'community_building': 1.4,
            'sustainability': 1.2,
            'innovation': 1.3,
            'network_stability': 1.1,
            'data_availability': 1.2
        }
        self.validation_thresholds = {
            'min_participation': 0.1,
            'min_success_rate': 0.8,
            'min_availability': 0.95,
            'max_consecutive_validations': 3
        }
        self.reputation_decay_factor = 0.99
        self.collusion_threshold = 0.8
        self.validator_history: List[Tuple[str, datetime, int]] = []  # node_id, timestamp, shard_id
        self.validation_stats: Dict[str, Dict] = {}
        self.performance_metrics: Dict[str, float] = {
            'average_block_time': 0.0,
            'total_validations': 0,
            'successful_validations': 0,
            'collusion_detections': 0
        }

    def calculate_cooperation_score(self, node: Node, shard_id: Optional[int] = None) -> float:
        """Calculate a node's cooperation score based on multiple factors."""
        if not node.can_validate(shard_id):
            return 0.0

        base_score = sum(
            score * self.reputation_weights.get(category, 1.0)
            for category, score in node.reputation_scores.items()
        )
        
        diversity_factor = self._calculate_diversity_factor(node)
        consistency_factor = self._calculate_consistency_factor(node)
        performance_factor = self._calculate_performance_factor(node)
        shard_factor = self._calculate_shard_factor(node, shard_id) if shard_id else 1.0
        
        final_score = (base_score * diversity_factor * consistency_factor * 
                      performance_factor * shard_factor)
                      
        return max(0, final_score)

    def _calculate_diversity_factor(self, node: Node) -> float:
        """Calculate diversity factor based on cooperative interactions."""
        recent_interactions = node.cooperative_interactions[-100:]  # Last 100 interactions
        if not recent_interactions:
            return 1.0
            
        unique_coops = len(set(recent_interactions))
        total_interactions = len(recent_interactions)
        
        diversity_score = unique_coops / total_interactions
        normalized_score = 1.0 + math.log(diversity_score + 1)
        
        return max(self.validation_thresholds['min_participation'], normalized_score)

    def _calculate_consistency_factor(self, node: Node) -> float:
        """Calculate consistency factor based on validation history."""
        if not node.validation_history:
            return 1.0
            
        recent_validations = node.validation_history[-50:]  # Last 50 validations
        successful = sum(1 for v in recent_validations 
                        if v.get('evidence', {}).get('success', False))
        
        success_rate = successful / len(recent_validations)
        return max(self.validation_thresholds['min_success_rate'], success_rate)

    def _calculate_performance_factor(self, node: Node) -> float:
        """Calculate performance factor based on node metrics."""
        metrics = node.performance_metrics
        if not metrics:
            return 1.0

        factors = [
            metrics.get('availability', 0) / 100,
            metrics.get('validation_success_rate', 0) / 100,
            metrics.get('network_reliability', 0) / 100
        ]
        
        avg_performance = sum(factors) / len(factors)
        return max(self.validation_thresholds['min_availability'], avg_performance)

    def _calculate_shard_factor(self, node: Node, shard_id: int) -> float:
        """Calculate shard-specific performance factor."""
        if shard_id not in node.active_shards:
            return 0.0
            
        # Consider time spent in shard
        time_in_shard = (datetime.now() - node.active_shards[shard_id]).total_seconds()
        shard_experience = min(1.0, time_in_shard / (24 * 3600))  # Max out at 1 day
        
        return 0.5 + (0.5 * shard_experience)

    def select_validator(self, nodes: List[Node], shard_id: Optional[int] = None) -> Optional[Node]:
        """Select the next validator using weighted random selection."""
        eligible_nodes = [
            node for node in nodes 
            if self._is_eligible_validator(node, shard_id)
        ]
        
        if not eligible_nodes:
            return None
            
        # Calculate scores for eligible nodes
        scores = [
            self.calculate_cooperation_score(node, shard_id) 
            for node in eligible_nodes
        ]
        total_score = sum(scores)
        
        if total_score <= 0:
            # Fallback to random selection if all scores are 0
            selected = random.choice(eligible_nodes)
        else:
            # Weighted random selection
            selection_point = random.uniform(0, total_score)
            current_sum = 0
            selected = eligible_nodes[-1]  # Default to last node
            
            for node, score in zip(eligible_nodes, scores):
                current_sum += score
                if current_sum >= selection_point:
                    selected = node
                    break
        
        # Record selection
        self._record_validator_selection(selected, shard_id)
        selected.enter_cooldown(self.cooldown_blocks)
        
        return selected

    def _is_eligible_validator(self, node: Node, shard_id: Optional[int] = None) -> bool:
        """Check if a node is eligible to validate blocks."""
        if not node.can_validate(shard_id):
            return False
            
        # Check minimum reputation requirement
        if node.get_total_reputation() < self.min_reputation:
            return False
            
        # Check performance factors
        performance_factor = self._calculate_performance_factor(node)
        if performance_factor < self.validation_thresholds['min_availability']:
            return False
            
        # Check recent selections to prevent concentration
        recent_validations = [
            v[0] for v in self.validator_history[-10:]
            if v[0] == node.node_id
        ]
        if len(recent_validations) >= self.validation_thresholds['max_consecutive_validations']:
            return False
            
        return True

    def _record_validator_selection(self, node: Node, shard_id: Optional[int]) -> None:
        """Record validator selection for statistics."""
        self.validator_history.append((node.node_id, datetime.now(), shard_id))
        if len(self.validator_history) > 1000:
            self.validator_history = self.validator_history[-1000:]
            
        if node.node_id not in self.validation_stats:
            self.validation_stats[node.node_id] = {
                'selections': 0,
                'successful_validations': 0,
                'last_selected': None,
                'shard_validations': {}
            }
            
        stats = self.validation_stats[node.node_id]
        stats['selections'] += 1
        stats['last_selected'] = datetime.now()
        
        if shard_id is not None:
            shard_stats = stats['shard_validations'].setdefault(shard_id, {
                'selections': 0,
                'successful': 0
            })
            shard_stats['selections'] += 1

    def validate_block(self, block: Block, previous_block: Optional[Block], 
                      validator: Node) -> bool:
        """Validate a proposed block."""
        try:
            # Verify validator eligibility
            if not self._is_eligible_validator(validator, block.shard_id):
                return False
                
            # Perform block validation
            if not block.validate(previous_block):
                return False
                
            # Verify cross-shard references if present
            if block.cross_shard_refs and not self._validate_cross_shard_refs(block):
                return False
                
            # Update statistics
            self._update_validation_stats(validator, block, True)
            
            return True
            
        except Exception as e:
            logger.error(f"Block validation failed: {e}")
            self._update_validation_stats(validator, block, False)
            return False

    def _validate_cross_shard_refs(self, block: Block) -> bool:
        """Validate cross-shard references in a block."""
        # This would include validation logic for cross-shard references
        # Implementation depends on specific cross-shard protocol
        return True

    def _update_validation_stats(self, validator: Node, block: Block, 
                               success: bool) -> None:
        """Update validation statistics."""
        stats = self.validation_stats.get(validator.node_id, {
            'selections': 0,
            'successful_validations': 0,
            'shard_validations': {}
        })
        
        if success:
            stats['successful_validations'] += 1
            
        if block.shard_id is not None:
            shard_stats = stats['shard_validations'].setdefault(block.shard_id, {
                'selections': 0,
                'successful': 0
            })
            if success:
                shard_stats['successful'] += 1
                
        self.validation_stats[validator.node_id] = stats

class SmartContract:
    """Represents a smart contract in the ICN blockchain."""
    
    def __init__(self, contract_id: str, code: str, creator: str, 
                 mana_cost: int = 10, version: str = "1.0"):
        self.contract_id = contract_id
        self.code = code
        self.creator = creator
        self.state: Dict = {}
        self.mana_cost = mana_cost
        self.version = version
        self.created_at = datetime.now()
        self.last_executed = None
        self.execution_count = 0
        self.total_mana_consumed = 0
        self.execution_history: List[Dict] = []
        self.metadata: Dict = {
            'created_at': self.created_at,
            'version': version,
            'creator': creator,
            'description': '',
            'tags': set()
        }
        self.dependencies: Set[str] = set()
        self.allowed_callers: Set[str] = {creator}
        self.restrictions: Dict = {
            'max_state_size': 1024 * 1024,  # 1MB
            'max_execution_time': 5,  # seconds
            'max_mana_per_execution': 100,
            'max_daily_executions': 1000
        }
        self.daily_executions = 0
        self.last_reset = datetime.now()

    def execute(self, input_data: Dict, available_mana: int) -> Dict:
        """Execute the smart contract code with safety checks."""
        # Reset daily execution counter if needed
        self._reset_daily_executions()
        
        # Validate execution conditions
        validation_result = self._validate_execution(input_data, available_mana)
        if validation_result.get("error"):
            return validation_result
            
        execution_start = time.time()
        try:
            # Set up secure execution environment
            local_namespace = self._setup_execution_environment(input_data)
            
            # Execute contract code
            exec(self.code, {}, local_namespace)
            
            # Validate execution result
            if "execute" not in local_namespace:
                return {"error": "Contract missing execute function"}
                
            # Check execution time
            if time.time() - execution_start > self.restrictions['max_execution_time']:
                return {"error": "Execution time limit exceeded"}
                
            # Execute contract function
            result = local_namespace["execute"](input_data, self.state)
            
            # Update contract metrics
            self._update_execution_metrics(execution_start)
            
            return {
                "state": self.state,
                "result": result,
                "mana_used": self.mana_cost,
                "execution_time": time.time() - execution_start
            }
            
        except Exception as e:
            logger.error(f"Contract execution failed: {e}")
            return {"error": str(e)}

    def _validate_execution(self, input_data: Dict, available_mana: int) -> Dict:
        """Validate execution conditions."""
        if self.daily_executions >= self.restrictions['max_daily_executions']:
            return {"error": "Daily execution limit exceeded"}
            
        if available_mana < self.mana_cost:
            return {"error": "Insufficient mana"}
            
        if len(str(self.state)) > self.restrictions['max_state_size']:
            return {"error": "State size limit exceeded"}
            
        return {}

    def _setup_execution_environment(self, input_data: Dict) -> Dict:
        """Set up secure execution environment with allowed variables."""
        return {
            "input": input_data,
            "state": self.state.copy(),
            "contract_id": self.contract_id,
            "creator": self.creator,
            "version": self.version,
            "metadata": self.metadata
        }

    def _update_execution_metrics(self, execution_start: float) -> None:
        """Update contract execution metrics."""
        self.last_executed = datetime.now()
        self.execution_count += 1
        self.daily_executions += 1
        self.total_mana_consumed += self.mana_cost
        
        execution_record = {
            'timestamp': self.last_executed,
            'execution_time': time.time() - execution_start,
            'mana_used': self.mana_cost,
            'state_size': len(str(self.state))
        }
        
        self.execution_history.append(execution_record)
        if len(self.execution_history) > 1000:
            self.execution_history = self.execution_history[-1000:]

    def _reset_daily_executions(self) -> None:
        """Reset daily execution counter if needed."""
        current_time = datetime.now()
        if (current_time - self.last_reset).days >= 1:
            self.daily_executions = 0
            self.last_reset = current_time

    def update_metadata(self, metadata: Dict) -> bool:
        """Update contract metadata."""
        try:
            self.metadata.update(metadata)
            return True
        except Exception as e:
            logger.error(f"Failed to update metadata: {e}")
            return False

    def add_dependency(self, contract_id: str) -> bool:
        """Add a contract dependency."""
        self.dependencies.add(contract_id)
        return True

    def authorize_caller(self, caller_id: str) -> bool:
        """Add an authorized caller."""
        self.allowed_callers.add(caller_id)
        return True

    def revoke_caller(self, caller_id: str) -> bool:
        """Revoke caller authorization."""
        if caller_id == self.creator:
            return False
        self.allowed_callers.discard(caller_id)
        return True

    def get_metrics(self) -> Dict:
        """Get comprehensive contract metrics."""
        return {
            'contract_id': self.contract_id,
            'version': self.version,
            'creator': self.creator,
            'created_at': self.created_at.isoformat(),
            'last_executed': self.last_executed.isoformat() if self.last_executed else None,
            'execution_count': self.execution_count,
            'daily_executions': self.daily_executions,
            'total_mana_consumed': self.total_mana_consumed,
            'average_mana_per_execution': (
                self.total_mana_consumed / self.execution_count 
                if self.execution_count > 0 else 0
            ),
            'state_size': len(str(self.state)),
            'dependencies': list(self.dependencies),
            'authorized_callers': len(self.allowed_callers),
            'restrictions': self.restrictions
        }

    def to_dict(self) -> Dict:
        """Convert contract to dictionary format."""
        return {
            'contract_id': self.contract_id,
            'code': self.code,
            'creator': self.creator,
            'state': self.state,
            'mana_cost': self.mana_cost,
            'version': self.version,
            'metadata': self.metadata,
            'dependencies': list(self.dependencies),
            'allowed_callers': list(self.allowed_callers),
            'restrictions': self.restrictions,
            'metrics': self.get_metrics()
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'SmartContract':
        """Create contract from dictionary."""
        contract = cls(
            contract_id=data['contract_id'],
            code=data['code'],
            creator=data['creator'],
            mana_cost=data['mana_cost'],
            version=data['version']
        )
        contract.state = data['state']
        contract.metadata = data['metadata']
        contract.dependencies = set(data['dependencies'])
        contract.allowed_callers = set(data['allowed_callers'])
        contract.restrictions = data['restrictions']
        return contract


class Blockchain:
    """Main blockchain implementation for ICN."""
    
    def __init__(self, num_shards: int = 4, initial_mana: int = 1000, 
                 mana_regen_rate: int = 10):
        self.num_shards = num_shards
        self.shards: Dict[int, Shard] = {
            i: Shard(i) for i in range(num_shards)
        }
        self.nodes: List[Node] = []
        self.consensus = ProofOfCooperation()
        self.contracts: Dict[str, SmartContract] = {}
        self.cooperative_mana = initial_mana
        self.mana_regen_rate = mana_regen_rate
        self.cross_shard_queue: Dict[int, List[Transaction]] = {
            i: [] for i in range(num_shards)
        }
        self.metadata: Dict = {
            'creation_time': datetime.now(),
            'last_update': datetime.now(),
            'version': "1.0",
            'network_name': "ICN MainNet",
            'network_id': hashlib.sha256(str(time.time()).encode()).hexdigest()[:8]
        }
        self.metrics: Dict = {
            'total_transactions': 0,
            'total_blocks': 0,
            'average_block_time': 0,
            'active_nodes': 0,
            'total_mana_consumed': 0
        }
        self.state: str = "active"
        self._initialize_network()

    def _initialize_network(self) -> None:
        """Initialize network configuration."""
        logger.info(f"Initializing ICN network {self.metadata['network_id']}")
        self._update_metrics()

    def add_node(self, node: Node) -> bool:
        """Add a new node to the network."""
        if any(n.node_id == node.node_id for n in self.nodes):
            return False
            
        self.nodes.append(node)
        self.metrics['active_nodes'] = len(
            [n for n in self.nodes if n.metadata['status'] == "active"]
        )
        logger.info(f"Added node {node.node_id} to network")
        return True

    def remove_node(self, node_id: str) -> bool:
        """Remove a node from the network."""
        node = self._get_node(node_id)
        if not node:
            return False
            
        self.nodes = [n for n in self.nodes if n.node_id != node_id]
        self.metrics['active_nodes'] = len(
            [n for n in self.nodes if n.metadata['status'] == "active"]
        )
        logger.info(f"Removed node {node_id} from network")
        return True

    def _get_node(self, node_id: str) -> Optional[Node]:
        """Get a node by its ID."""
        return next((n for n in self.nodes if n.node_id == node_id), None)

    def add_transaction(self, transaction: Dict) -> bool:
        """Add a new transaction to the network."""
        # Determine shard for transaction
        shard_id = self._calculate_shard_id(transaction)
        
        tx = Transaction(
            sender=transaction['sender'],
            receiver=transaction['receiver'],
            action=transaction['action'],
            data=transaction['data'],
            shard_id=shard_id
        )
        
        # Add to appropriate shard
        if self.shards[shard_id].add_transaction(tx):
            self.metrics['total_transactions'] += 1
            return True
        return False

    def _calculate_shard_id(self, transaction: Dict) -> int:
        """Calculate which shard should handle a transaction."""
        # Simple hash-based sharding
        tx_hash = hashlib.sha256(
            json.dumps(transaction, sort_keys=True).encode()
        ).hexdigest()
        return int(tx_hash, 16) % self.num_shards

    def create_block(self, shard_id: int) -> Optional[Block]:
        """Create a new block in specified shard."""
        shard = self.shards.get(shard_id)
        if not shard:
            return None
            
        # Select validator
        validator = self.consensus.select_validator(self.nodes, shard_id)
        if not validator:
            return None
            
        # Create block
        block = shard.create_block(validator.node_id)
        if not block:
            return None
            
        # Process cross-shard references
        self._add_cross_shard_refs(block)
        
        return block

    def _add_cross_shard_refs(self, block: Block) -> None:
        """Add cross-shard references to block."""
        cross_shard_txs = [
            tx for tx in block.transactions 
            if self._is_cross_shard_transaction(tx)
        ]
        
        for tx in cross_shard_txs:
            ref = self._create_cross_shard_ref(tx)
            if ref:
                block.cross_shard_refs.append(ref)

    def _is_cross_shard_transaction(self, transaction: Transaction) -> bool:
        """Check if transaction involves multiple shards."""
        return 'target_shard' in transaction.data

    def _create_cross_shard_ref(self, transaction: Transaction) -> Optional[str]:
        """Create a reference for cross-shard transaction."""
        try:
            ref_data = {
                'transaction_id': transaction.transaction_id,
                'source_shard': transaction.shard_id,
                'target_shard': transaction.data.get('target_shard'),
                'timestamp': transaction.timestamp.isoformat()
            }
            return hashlib.sha256(
                json.dumps(ref_data, sort_keys=True).encode()
            ).hexdigest()
        except Exception as e:
            logger.error(f"Failed to create cross-shard reference: {e}")
            return None

    def add_block(self, block: Block) -> bool:
        """Add a validated block to the network."""
        shard = self.shards.get(block.shard_id)
        if not shard:
            return False
            
        # Validate block
        validator = self._get_node(block.validator)
        if not validator:
            return False
            
        if not self.consensus.validate_block(block, shard.chain[-1], validator):
            return False
            
        # Add block to shard
        if shard.add_block(block):
            self._process_block_addition(block)
            return True
            
        return False

    def _process_block_addition(self, block: Block) -> None:
        """Process successful block addition."""
        self.metrics['total_blocks'] += 1
        self._update_metrics()
        
        # Process cross-shard references
        if block.cross_shard_refs:
            self._process_cross_shard_refs(block)
            
        logger.info(
            f"Added block {block.index} to shard {block.shard_id}")
                def _process_cross_shard_refs(self, block: Block) -> None:
        """Process cross-shard references in a block."""
        for ref in block.cross_shard_refs:
            ref_data = self._parse_cross_shard_ref(ref)
            if ref_data:
                target_shard = self.shards.get(ref_data['target_shard'])
                if target_shard:
                    tx = self._create_cross_shard_transaction(ref_data)
                    target_shard.add_transaction(tx)

    def _parse_cross_shard_ref(self, ref: str) -> Optional[Dict]:
        """Parse cross-shard reference into transaction data."""
        try:
            ref_data = json.loads(hashlib.sha256(ref.encode()).hexdigest())
            return ref_data
        except Exception as e:
            logger.error(f"Failed to parse cross-shard reference: {e}")
            return None

    def _create_cross_shard_transaction(self, ref_data: Dict) -> Transaction:
        """Create a cross-shard transaction from reference data."""
        return Transaction(
            sender='cross-shard',
            receiver='target-shard',
            action='cross-shard-transfer',
            data=ref_data,
            shard_id=ref_data['target_shard']
        )

    def add_smart_contract(self, contract: SmartContract) -> bool:
        """Add a new smart contract to the network."""
        if contract.contract_id in self.contracts:
            return False

        self.contracts[contract.contract_id] = contract
        logger.info(f"Added smart contract {contract.contract_id} to network")
        return True

    def execute_smart_contract(self, contract_id: str, input_data: Dict) -> Dict:
        """Execute a smart contract with given input data."""
        contract = self.contracts.get(contract_id)
        if not contract:
            return {"error": "Contract not found"}
        
        # Check available mana
        if self.cooperative_mana < contract.mana_cost:
            return {"error": "Insufficient cooperative mana"}
        
        result = contract.execute(input_data, self.cooperative_mana)
        if "error" not in result:
            self.cooperative_mana -= contract.mana_cost
            self.metrics['total_mana_consumed'] += contract.mana_cost
        return result

    def regenerate_mana(self) -> None:
        """Regenerate cooperative mana over time."""
        self.cooperative_mana = min(
            self.cooperative_mana + self.mana_regen_rate,
            1000  # Max mana limit for demonstration purposes
        )
        self._update_metrics()

    def _update_metrics(self) -> None:
        """Update blockchain network metrics."""
        self.metadata['last_update'] = datetime.now().isoformat()
        self.metrics['average_block_time'] = sum(
            shard.metrics['average_block_time'] for shard in self.shards.values()
        ) / max(1, len(self.shards))

    def to_dict(self) -> Dict:
        """Convert blockchain to dictionary format."""
        return {
            'num_shards': self.num_shards,
            'nodes': [node.to_dict() for node in self.nodes],
            'contracts': {cid: contract.to_dict() for cid, contract in self.contracts.items()},
            'cooperative_mana': self.cooperative_mana,
            'metrics': self.metrics,
            'metadata': self.metadata
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Blockchain':
        """Create blockchain from dictionary."""
        blockchain = cls(
            num_shards=data['num_shards'],
            initial_mana=data['cooperative_mana']
        )
        blockchain.nodes = [Node.from_dict(node) for node in data['nodes']]
        blockchain.contracts = {
            cid: SmartContract.from_dict(contract) 
            for cid, contract in data['contracts'].items()
        }
        blockchain.cooperative_mana = data['cooperative_mana']
        blockchain.metrics = data['metrics']
        blockchain.metadata = data['metadata']
        return blockchain




# ==================== /home/matt/icn-prototype/blockchain/__init__.py ====================

# blockchain/__init__.py
"""
Import core components and make them available at the package level.
We're using relative imports to properly handle the package hierarchy.
"""
from .core.node import Node
from .core.block import Block
from .core.transaction import Transaction 
from .core.shard import Shard
from .core.blockchain import Blockchain

__all__ = [
    "Node",
    "Block", 
    "Transaction",
    "Shard",
    "Blockchain"
]


# ==================== /home/matt/icn-prototype/blockchain/utils/metrics.py ====================

# ================================================================
# File: blockchain/utils/metrics.py
# Description: This file contains functions and classes for managing
# performance and operational metrics within the ICN ecosystem.
# These metrics are used to track node performance, block creation,
# transaction validation, and overall network health.
# ================================================================

from typing import Dict, List
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class MetricsManager:
    """
    The MetricsManager handles the collection, analysis, and reporting of
    performance metrics within the ICN. It tracks node performance, transaction
    throughput, validation success rates, and resource utilization to provide
    real-time feedback for improving cooperative efficiency.
    """

    def __init__(self):
        """
        Initialize the MetricsManager.

        This constructor sets up the basic metrics structure, including
        performance, transaction, and resource usage metrics.
        """
        self.metrics: Dict = {
            "total_blocks_created": 0,
            "total_transactions_processed": 0,
            "average_block_creation_time": 0.0,
            "average_transaction_validation_time": 0.0,
            "resource_utilization": {
                "cpu": 0.0,
                "memory": 0.0,
                "bandwidth": 0.0,
                "storage": 0.0,
            },
            "validation_success_rate": 0.0,
            "uptime": 0.0,
        }
        self.start_time = datetime.now()

    def update_block_creation(self, creation_time: float) -> None:
        """
        Update metrics related to block creation.

        Args:
            creation_time (float): Time taken to create a new block.
        """
        try:
            self.metrics["total_blocks_created"] += 1
            total_time = (
                self.metrics["average_block_creation_time"]
                * (self.metrics["total_blocks_created"] - 1)
            )
            self.metrics["average_block_creation_time"] = (
                total_time + creation_time
            ) / self.metrics["total_blocks_created"]
            logger.info("Updated block creation metrics")

        except Exception as e:
            logger.error(f"Failed to update block creation metrics: {str(e)}")

    def update_transaction_processing(self, processing_time: float) -> None:
        """
        Update metrics related to transaction processing.

        Args:
            processing_time (float): Time taken to validate a transaction.
        """
        try:
            self.metrics["total_transactions_processed"] += 1
            total_time = (
                self.metrics["average_transaction_validation_time"]
                * (self.metrics["total_transactions_processed"] - 1)
            )
            self.metrics["average_transaction_validation_time"] = (
                total_time + processing_time
            ) / self.metrics["total_transactions_processed"]
            logger.info("Updated transaction processing metrics")

        except Exception as e:
            logger.error(f"Failed to update transaction metrics: {str(e)}")

    def update_resource_utilization(self, utilization: Dict[str, float]) -> None:
        """
        Update resource utilization metrics.

        Args:
            utilization (Dict[str, float]): Resource utilization metrics for
            CPU, memory, bandwidth, and storage.
        """
        try:
            for resource, value in utilization.items():
                if resource in self.metrics["resource_utilization"]:
                    self.metrics["resource_utilization"][resource] = max(
                        0.0, value
                    )
            logger.info("Updated resource utilization metrics")

        except Exception as e:
            logger.error(f"Failed to update resource utilization: {str(e)}")

    def update_validation_success(self, successful: bool) -> None:
        """
        Update validation success rate.

        Args:
            successful (bool): True if the validation was successful, False otherwise.
        """
        try:
            total_validations = self.metrics.get("total_validations", 0) + 1
            successful_validations = self.metrics.get("successful_validations", 0)

            if successful:
                successful_validations += 1

            self.metrics["validation_success_rate"] = (
                successful_validations / total_validations * 100
            )
            self.metrics["total_validations"] = total_validations
            self.metrics["successful_validations"] = successful_validations

            logger.info("Updated validation success metrics")

        except Exception as e:
            logger.error(f"Failed to update validation success rate: {str(e)}")

    def calculate_uptime(self) -> None:
        """
        Calculate the node's uptime since the start of the MetricsManager.
        """
        try:
            uptime_seconds = (datetime.now() - self.start_time).total_seconds()
            self.metrics["uptime"] = uptime_seconds / 3600  # uptime in hours
            logger.info("Calculated node uptime")

        except Exception as e:
            logger.error(f"Failed to calculate uptime: {str(e)}")

    def get_metrics(self) -> Dict:
        """
        Retrieve the current metrics.

        Returns:
            Dict: A dictionary containing all current metrics.
        """
        try:
            self.calculate_uptime()
            return self.metrics

        except Exception as e:
            logger.error(f"Failed to get metrics: {str(e)}")
            return {}

    def reset_metrics(self) -> None:
        """
        Reset all metrics to initial values.
        """
        try:
            self.__init__()  # Re-initialize the metrics manager
            logger.info("Reset all metrics")

        except Exception as e:
            logger.error(f"Failed to reset metrics: {str(e)}")


# ==================== /home/matt/icn-prototype/blockchain/utils/validation.py ====================

# ================================================================
# File: blockchain/utils/validation.py
# Description: Contains validation functions for transactions,
# blocks, and cooperative interactions within the ICN. These functions
# ensure data integrity, compliance with cooperative rules, and secure
# operation of the ICN blockchain.
# ================================================================

from typing import Dict, List, Any, Optional
import hashlib
import logging
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

def validate_transaction(transaction: Dict) -> bool:
    """
    Validate a transaction based on predefined rules.

    This function checks transaction structure, required fields, and
    cryptographic integrity, ensuring that transactions comply with the
    ICNs cooperative principles.

    Args:
        transaction (Dict): A dictionary representing a transaction.

    Returns:
        bool: True if the transaction is valid, False otherwise.
    """
    try:
        # Check required fields
        required_fields = ["transaction_id", "sender", "receiver", "amount", "signature", "timestamp"]
        for field in required_fields:
            if field not in transaction:
                logger.error(f"Transaction missing required field: {field}")
                return False

        # Validate amount
        if transaction["amount"] <= 0:
            logger.error("Transaction amount must be greater than zero")
            return False

        # Validate timestamp
        transaction_time = datetime.fromisoformat(transaction["timestamp"])
        current_time = datetime.now()
        if transaction_time > current_time + timedelta(minutes=5):
            logger.error("Transaction timestamp is in the future")
            return False

        # Verify transaction signature (placeholder logic)
        if not _verify_signature(transaction):
            logger.error("Transaction signature verification failed")
            return False

        logger.info(f"Transaction {transaction['transaction_id']} is valid")
        return True

    except Exception as e:
        logger.error(f"Transaction validation failed: {str(e)}")
        return False

def validate_block(block: Dict, previous_block: Optional[Dict] = None) -> bool:
    """
    Validate a block based on structure, integrity, and consistency rules.

    This function checks the blocks cryptographic hash, Merkle root,
    timestamp, and transactions to ensure compliance with cooperative principles.

    Args:
        block (Dict): A dictionary representing a block.
        previous_block (Optional[Dict]): The previous block in the chain.

    Returns:
        bool: True if the block is valid, False otherwise.
    """
    try:
        # Check required fields
        required_fields = ["index", "previous_hash", "timestamp", "transactions", "hash", "merkle_root"]
        for field in required_fields:
            if field not in block:
                logger.error(f"Block missing required field: {field}")
                return False

        # Validate block index
        if previous_block and block["index"] != previous_block["index"] + 1:
            logger.error("Block index is not sequential")
            return False

        # Validate previous hash
        if previous_block and block["previous_hash"] != previous_block["hash"]:
            logger.error("Block previous hash does not match")
            return False

        # Validate timestamp
        block_time = datetime.fromisoformat(block["timestamp"])
        if block_time > datetime.now() + timedelta(minutes=5):
            logger.error("Block timestamp is in the future")
            return False

        if previous_block and block_time <= datetime.fromisoformat(previous_block["timestamp"]):
            logger.error("Block timestamp is not after the previous block")
            return False

        # Validate Merkle root
        if not _validate_merkle_root(block["transactions"], block["merkle_root"]):
            logger.error("Block Merkle root validation failed")
            return False

        # Validate block hash
        if not _validate_block_hash(block):
            logger.error("Block hash validation failed")
            return False

        logger.info(f"Block {block['index']} is valid")
        return True

    except Exception as e:
        logger.error(f"Block validation failed: {str(e)}")
        return False

def _validate_merkle_root(transactions: List[Dict], expected_merkle_root: str) -> bool:
    """
    Validate the Merkle root of a list of transactions.

    Args:
        transactions (List[Dict]): List of transaction dictionaries.
        expected_merkle_root (str): The expected Merkle root hash.

    Returns:
        bool: True if the Merkle root is valid, False otherwise.
    """
    try:
        if not transactions:
            return expected_merkle_root == hashlib.sha256(b"empty").hexdigest()

        # Create leaf nodes from transactions
        leaves = [hashlib.sha256(json.dumps(tx).encode()).hexdigest() for tx in transactions]

        # Build Merkle tree
        while len(leaves) > 1:
            if len(leaves) % 2 == 1:
                leaves.append(leaves[-1])
            leaves = [
                hashlib.sha256((a + b).encode()).hexdigest()
                for a, b in zip(leaves[::2], leaves[1::2])
            ]

        return leaves[0] == expected_merkle_root

    except Exception as e:
        logger.error(f"Failed to validate Merkle root: {str(e)}")
        return False

def _validate_block_hash(block: Dict) -> bool:
    """
    Validate the block's hash by recalculating it.

    Args:
        block (Dict): A dictionary representing a block.

    Returns:
        bool: True if the hash is valid, False otherwise.
    """
    try:
        block_data = {
            "index": block["index"],
            "previous_hash": block["previous_hash"],
            "timestamp": block["timestamp"],
            "merkle_root": block["merkle_root"],
        }
        recalculated_hash = hashlib.sha256(
            json.dumps(block_data, sort_keys=True).encode()
        ).hexdigest()

        return recalculated_hash == block["hash"]

    except Exception as e:
        logger.error(f"Failed to validate block hash: {str(e)}")
        return False

def _verify_signature(transaction: Dict) -> bool:
    """
    Placeholder function to verify the transaction signature.

    This function simulates signature verification and should be replaced with
    actual cryptographic verification logic.

    Args:
        transaction (Dict): A dictionary representing a transaction.

    Returns:
        bool: True if the signature is valid, False otherwise.
    """
    # Placeholder for signature verification logic
    return True

def validate_cooperative_interaction(interaction: Dict) -> bool:
    """
    Validate cooperative interactions such as votes, proposals, and resource sharing.

    This function ensures that cooperative interactions comply with ICN rules,
    supporting fair governance and resource management.

    Args:
        interaction (Dict): A dictionary representing a cooperative interaction.

    Returns:
        bool: True if the interaction is valid, False otherwise.
    """
    try:
        # Check required fields
        required_fields = ["interaction_id", "type", "initiator", "target", "timestamp"]
        for field in required_fields:
            if field not in interaction:
                logger.error(f"Interaction missing required field: {field}")
                return False

        # Validate timestamp
        interaction_time = datetime.fromisoformat(interaction["timestamp"])
        if interaction_time > datetime.now() + timedelta(minutes=5):
            logger.error("Interaction timestamp is in the future")
            return False

        logger.info(f"Cooperative interaction {interaction['interaction_id']} is valid")
        return True

    except Exception as e:
        logger.error(f"Cooperative interaction validation failed: {str(e)}")
        return False


# ==================== /home/matt/icn-prototype/blockchain/utils/__init__.py ====================

# blockchain/utils/__init__.py

from .metrics import Metrics
from .validation import validate_transaction, validate_block

__all__ = [
    "Metrics",
    "validate_transaction",
    "validate_block"
]


# ==================== /home/matt/icn-prototype/blockchain/utils/crypto.py ====================

# ================================================================
# File: blockchain/utils/crypto.py
# Description: Contains cryptographic functions for securing the ICN
# blockchain. Includes hashing, signing, and signature verification to
# ensure the integrity, authenticity, and confidentiality of transactions
# and blocks.
# ================================================================

from typing import Any, Tuple, Optional
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import hmac
import os
import base64
import logging

logger = logging.getLogger(__name__)

# Constants for encryption/decryption
AES_KEY_SIZE = 32
IV_SIZE = 16

def generate_rsa_key_pair() -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
    """
    Generate an RSA key pair for signing and verification.

    Returns:
        Tuple: A tuple containing the RSA private key and public key.
    """
    try:
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        public_key = private_key.public_key()
        logger.info("Generated RSA key pair")
        return private_key, public_key

    except Exception as e:
        logger.error(f"Failed to generate RSA key pair: {str(e)}")
        raise

def sign_data(private_key: rsa.RSAPrivateKey, data: bytes) -> bytes:
    """
    Sign data using a private RSA key.

    Args:
        private_key (rsa.RSAPrivateKey): The private RSA key.
        data (bytes): The data to be signed.

    Returns:
        bytes: The signature of the data.
    """
    try:
        signature = private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        logger.info("Data signed successfully")
        return signature

    except Exception as e:
        logger.error(f"Failed to sign data: {str(e)}")
        raise

def verify_signature(
    public_key: rsa.RSAPublicKey, signature: bytes, data: bytes
) -> bool:
    """
    Verify the signature of data using a public RSA key.

    Args:
        public_key (rsa.RSAPublicKey): The public RSA key.
        signature (bytes): The signature to verify.
        data (bytes): The data that was signed.

    Returns:
        bool: True if the signature is valid, False otherwise.
    """
    try:
        public_key.verify(
            signature,
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        logger.info("Signature verified successfully")
        return True

    except Exception as e:
        logger.error(f"Signature verification failed: {str(e)}")
        return False

def hash_data(data: bytes) -> str:
    """
    Hash data using SHA-256.

    Args:
        data (bytes): The data to be hashed.

    Returns:
        str: The SHA-256 hash of the data in hexadecimal format.
    """
    try:
        digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
        digest.update(data)
        hash_hex = digest.finalize().hex()
        logger.info("Data hashed successfully")
        return hash_hex

    except Exception as e:
        logger.error(f"Failed to hash data: {str(e)}")
        raise

def derive_key(password: bytes, salt: bytes, iterations: int = 100000) -> bytes:
    """
    Derive a cryptographic key from a password using PBKDF2-HMAC-SHA256.

    Args:
        password (bytes): The password to derive the key from.
        salt (bytes): The salt for key derivation.
        iterations (int): Number of iterations for the key derivation.

    Returns:
        bytes: The derived key.
    """
    try:
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=AES_KEY_SIZE,
            salt=salt,
            iterations=iterations,
            backend=default_backend()
        )
        key = kdf.derive(password)
        logger.info("Key derived successfully from password")
        return key

    except Exception as e:
        logger.error(f"Failed to derive key: {str(e)}")
        raise

def aes_encrypt(key: bytes, plaintext: bytes) -> Tuple[bytes, bytes]:
    """
    Encrypt data using AES in CBC mode.

    Args:
        key (bytes): The AES key.
        plaintext (bytes): The data to be encrypted.

    Returns:
        Tuple: The IV and ciphertext.
    """
    try:
        iv = os.urandom(IV_SIZE)
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()

        # Pad plaintext to block size
        padding_length = AES_KEY_SIZE - (len(plaintext) % AES_KEY_SIZE)
        padded_plaintext = plaintext + bytes([padding_length] * padding_length)

        ciphertext = encryptor.update(padded_plaintext) + encryptor.finalize()
        logger.info("Data encrypted successfully")
        return iv, ciphertext

    except Exception as e:
        logger.error(f"Failed to encrypt data: {str(e)}")
        raise

def aes_decrypt(key: bytes, iv: bytes, ciphertext: bytes) -> bytes:
    """
    Decrypt data using AES in CBC mode.

    Args:
        key (bytes): The AES key.
        iv (bytes): The initialization vector (IV).
        ciphertext (bytes): The data to be decrypted.

    Returns:
        bytes: The decrypted plaintext.
    """
    try:
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()

        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()

        # Remove padding
        padding_length = padded_plaintext[-1]
        plaintext = padded_plaintext[:-padding_length]

        logger.info("Data decrypted successfully")
        return plaintext

    except Exception as e:
        logger.error(f"Failed to decrypt data: {str(e)}")
        raise

def hmac_sign(key: bytes, data: bytes) -> bytes:
    """
    Generate an HMAC signature for data using a symmetric key.

    Args:
        key (bytes): The symmetric key.
        data (bytes): The data to be signed.

    Returns:
        bytes: The HMAC signature.
    """
    try:
        hmac_obj = hmac.HMAC(key, hashes.SHA256(), backend=default_backend())
        hmac_obj.update(data)
        signature = hmac_obj.finalize()
        logger.info("HMAC signature generated successfully")
        return signature

    except Exception as e:
        logger.error(f"Failed to generate HMAC signature: {str(e)}")
        raise

def hmac_verify(key: bytes, signature: bytes, data: bytes) -> bool:
    """
    Verify an HMAC signature for data using a symmetric key.

    Args:
        key (bytes): The symmetric key.
        signature (bytes): The HMAC signature to verify.
        data (bytes): The data that was signed.

    Returns:
        bool: True if the HMAC is valid, False otherwise.
    """
    try:
        hmac_obj = hmac.HMAC(key, hashes.SHA256(), backend=default_backend())
        hmac_obj.update(data)
        hmac_obj.verify(signature)
        logger.info("HMAC signature verified successfully")
        return True

    except Exception as e:
        logger.error(f"HMAC verification failed: {str(e)}")
        return False


# ==================== /home/matt/icn-prototype/blockchain/core/node.py ====================

from __future__ import annotations
from datetime import datetime, timedelta
from typing import Dict, List, Set, Optional
import logging
import json

logger = logging.getLogger(__name__)

class Node:
    """
    Represents a node in the ICN network.

    A node is a participant in the network that can validate transactions,
    participate in consensus, and maintain portions of the blockchain.
    """

    def __init__(
        self,
        node_id: str,
        cooperative_id: Optional[str] = None,
        initial_stake: float = 10.0,
    ):
        self.node_id = node_id
        self.cooperative_id = cooperative_id
        self.reputation_scores = {
            "validation": 0.0,
            "proposal_creation": 0.0,
            "voting": 0.0,
            "resource_sharing": 0.0,
            "cooperative_growth": 0.0,
            "community_building": 0.0,
            "conflict_resolution": 0.0,
            "transaction_validation": 0.0,
            "data_availability": 0.0,
            "network_stability": 0.0,
            "innovation": 0.0,
            "sustainability": 0.0,
        }
        self.stake = initial_stake
        self.cooperative_interactions: List[str] = []
        self.validation_history: List[Dict] = []
        self.resource_usage: Dict[str, float] = {
            "computation": 0.0,
            "storage": 0.0,
            "bandwidth": 0.0,
            "memory": 0.0,
            "energy": 0.0,
        }
        self.shard_assignments: Set[int] = set()
        self.active_shards: Dict[int, datetime] = {}
        self.last_validation = datetime.now().timestamp()
        self.total_validations = 0
        self.cooldown = 0
        self.performance_metrics: Dict[str, float] = {
            "response_time": 0.0,
            "availability": 100.0,
            "validation_success_rate": 100.0,
            "network_reliability": 100.0,
        }
        self.metadata: Dict = {
            "creation_time": datetime.now(),
            "last_active": datetime.now(),
            "version": "1.0",
            "capabilities": set(),
            "status": "active",
        }

    def update_reputation(
        self,
        category: str,
        score: float,
        cooperative_id: Optional[str] = None,
        evidence: Optional[Dict] = None,
    ) -> bool:
        """Update reputation score for a category with evidence."""
        try:
            if category not in self.reputation_scores:
                logger.error(f"Invalid reputation category: {category}")
                return False

            old_score = self.reputation_scores[category]
            self.reputation_scores[category] = max(0, old_score + score)

            if cooperative_id:
                self.cooperative_interactions.append(cooperative_id)

            if evidence:
                self.validation_history.append(
                    {
                        "timestamp": datetime.now(),
                        "category": category,
                        "score_change": score,
                        "evidence": evidence,
                    }
                )

            self.metadata["last_active"] = datetime.now()

            # Trim history if needed
            if len(self.cooperative_interactions) > 1000:
                self.cooperative_interactions = self.cooperative_interactions[-1000:]
            if len(self.validation_history) > 1000:
                self.validation_history = self.validation_history[-1000:]

            return True

        except Exception as e:
            logger.error(f"Failed to update reputation: {str(e)}")
            return False

    def assign_to_shard(self, shard_id: int) -> bool:
        """Assign node to a shard."""
        if len(self.active_shards) >= 3:  # Maximum 3 active shards per node
            logger.warning(f"Node {self.node_id} already assigned to maximum shards")
            return False

        self.shard_assignments.add(shard_id)
        self.active_shards[shard_id] = datetime.now()
        logger.info(f"Node {self.node_id} assigned to shard {shard_id}")
        return True

    def remove_from_shard(self, shard_id: int) -> bool:
        """Remove node from a shard."""
        if shard_id in self.active_shards:
            del self.active_shards[shard_id]
            self.shard_assignments.discard(shard_id)
            logger.info(f"Node {self.node_id} removed from shard {shard_id}")
            return True
        return False

    def can_validate(self, shard_id: Optional[int] = None) -> bool:
        """Check if node can validate blocks."""
        current_time = datetime.now().timestamp()

        # Basic validation checks
        if self.cooldown > 0:
            return False

        if (current_time - self.last_validation) < 10:  # 10-second minimum
            return False

        if self.metadata["status"] != "active":
            return False

        # Shard-specific validation
        if shard_id is not None:
            if shard_id not in self.active_shards:
                return False

            shard_time = self.active_shards[shard_id]
            if (datetime.now() - shard_time).total_seconds() > 3600:  # 1 hour timeout
                return False

        return True

    def enter_cooldown(self, cooldown_period: int) -> None:
        """Put node into a cooldown period."""
        self.cooldown = cooldown_period
        self.metadata["status"] = "cooldown"
        logger.info(
            f"Node {self.node_id} entered cooldown for {cooldown_period} periods"
        )

    def update_metrics(self, metrics: Dict[str, float]) -> None:
        """Update node performance metrics."""
        self.performance_metrics.update(metrics)
        self.metadata["last_active"] = datetime.now()

        # Calculate validation success rate
        if self.total_validations > 0:
            success_rate = (
                len(
                    [
                        v
                        for v in self.validation_history
                        if v.get("evidence", {}).get("success", False)
                    ]
                )
                / self.total_validations
                * 100
            )
            self.performance_metrics["validation_success_rate"] = success_rate

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def record_resource_usage(self, usage: Dict[str, float]) -> None:
        """Record resource usage metrics."""
        for resource, amount in usage.items():
            if resource in self.resource_usage:
                self.resource_usage[resource] += amount

        # Update availability based on resource usage
        total_usage = sum(self.resource_usage.values())
        self.performance_metrics["availability"] = max(0, 100 - (total_usage / 5))

    def to_dict(self) -> Dict:
        """Convert node state to dictionary."""
        return {
            "node_id": self.node_id,
            "cooperative_id": self.cooperative_id,
            "reputation_scores": self.reputation_scores,
            "stake": self.stake,
            "shard_assignments": list(self.shard_assignments),
            "active_shards": {k: v.isoformat() for k, v in self.active_shards.items()},
            "performance_metrics": self.performance_metrics,
            "resource_usage": self.resource_usage,
            "metadata": {
                **self.metadata,
                "creation_time": self.metadata["creation_time"].isoformat(),
                "last_active": self.metadata["last_active"].isoformat(),
                "capabilities": list(self.metadata["capabilities"]),
            },
            "status": self.metadata["status"],
        }

    @classmethod
    def from_dict(cls, data: Dict) -> Node:
        """Create node from dictionary."""
        try:
            node = cls(
                node_id=data["node_id"],
                cooperative_id=data["cooperative_id"],
                initial_stake=data["stake"],
            )
            node.reputation_scores = data["reputation_scores"]
            node.shard_assignments = set(data["shard_assignments"])
            node.active_shards = {
                int(k): datetime.fromisoformat(v)
                for k, v in data["active_shards"].items()
            }
            node.performance_metrics = data["performance_metrics"]
            node.resource_usage = data["resource_usage"]

            # Restore metadata
            node.metadata.update(data["metadata"])
            node.metadata["creation_time"] = datetime.fromisoformat(
                data["metadata"]["creation_time"]
            )
            node.metadata["last_active"] = datetime.fromisoformat(
                data["metadata"]["last_active"]
            )
            node.metadata["capabilities"] = set(data["metadata"]["capabilities"])

            return node

        except Exception as e:
            logger.error(f"Failed to create node from dictionary: {str(e)}")
            raise ValueError("Invalid node data")

    def __str__(self) -> str:
        """Return a human-readable string representation of the node."""
        return (
            f"Node(id={self.node_id}, "
            f"coop={self.cooperative_id}, "
            f"status={self.metadata['status']}, "
            f"rep={self.get_total_reputation():.2f})"
        )


# ==================== /home/matt/icn-prototype/blockchain/core/block.py ====================

# ============================================================
# File: blockchain/core/block.py
# Description: Core block structure for the ICN blockchain.
# This file defines the block class used within each shard of
# the ICN blockchain. A block contains validated transactions
# and includes cryptographic links to maintain chain integrity.
# ============================================================

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Set
import hashlib
import json
import logging
from copy import deepcopy
from .transaction import Transaction

logger = logging.getLogger(__name__)

@dataclass
class Block:
    """
    Represents a block in the ICN blockchain.

    A block is the fundamental unit of the blockchain, containing a list
    of transactions and cryptographic links to ensure immutability and
    integrity. Each block is validated by a node within a specific shard.
    """

    index: int
    previous_hash: str
    timestamp: datetime
    transactions: List[Transaction]
    validator: str
    shard_id: int
    hash: str = ""
    nonce: int = 0
    merkle_root: str = ""
    cross_shard_refs: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    version: str = "1.0"
    
    # Track transaction IDs for duplicate prevention
    _transaction_ids: Set[str] = field(default_factory=set, init=False, repr=False)
    _is_deserialized: bool = field(default=False, init=False, repr=False)

    def __post_init__(self) -> None:
        """
        Post-initialization for the block instance.

        This method ensures that the block's hash and Merkle root are set
        if not provided during initialization. It also sets metadata
        indicating the block's creation time and initializes transaction tracking.
        """
        # Initialize transaction ID tracking
        self._transaction_ids = {tx.transaction_id for tx in self.transactions}
        
        # Sort cross-shard references for consistency
        self.cross_shard_refs = sorted(self.cross_shard_refs)
        
        # Ensure metadata contains creation time
        if "created_at" not in self.metadata:
            self.metadata["created_at"] = datetime.now().isoformat()
            
        # Only calculate merkle root and hash if they're not provided
        if not self.merkle_root and not self._is_deserialized:
            self.merkle_root = self.calculate_merkle_root()
            
        if not self.hash and not self._is_deserialized:
            self.hash = self.calculate_hash()
            
        # Validate all initial transactions match shard
        for tx in self.transactions:
            if tx.shard_id != self.shard_id:
                logger.warning(f"Transaction {tx.transaction_id} shard_id doesn't match block")

    def calculate_merkle_root(self) -> str:
        """Calculate the Merkle root of the transactions."""
        if not self.transactions:
            return hashlib.sha256(b"empty").hexdigest()

        leaves = []
        # Ensure consistent transaction serialization
        for tx in sorted(self.transactions, key=lambda t: t.transaction_id):
            tx_dict = tx.to_dict()
            # Remove any non-deterministic fields
            tx_dict.pop('timestamp', None)
            tx_json = json.dumps(tx_dict, sort_keys=True)
            leaves.append(hashlib.sha256(tx_json.encode()).hexdigest())

        while len(leaves) > 1:
            if len(leaves) % 2 == 1:
                leaves.append(leaves[-1])
            leaves = [
                hashlib.sha256((a + b).encode()).hexdigest()
                for a, b in zip(leaves[::2], leaves[1::2])
            ]

        return leaves[0] if leaves else hashlib.sha256(b"empty").hexdigest()

    def calculate_hash(self) -> str:
        """Calculate the hash of the block."""
        block_dict = {
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp.isoformat(),
            "merkle_root": self.merkle_root,
            "validator": self.validator,
            "nonce": self.nonce,
            "shard_id": self.shard_id,
            "cross_shard_refs": sorted(self.cross_shard_refs),
            "version": self.version
        }
        return hashlib.sha256(
            json.dumps(block_dict, sort_keys=True).encode()
        ).hexdigest()

    def validate(self, previous_block: Optional["Block"] = None) -> bool:
        """Validate block structure and consistency."""
        try:
            # Validate transactions
            if not all(isinstance(tx, Transaction) for tx in self.transactions):
                logger.error("Invalid transaction type in block")
                return False

            if not all(tx.validate() for tx in self.transactions):
                logger.error("Invalid transaction in block")
                return False

            # Validate timestamp
            now = datetime.now()
            if self.timestamp > now + timedelta(minutes=5):
                logger.error("Block timestamp is in the future")
                return False

            # Validate shard consistency
            if not all(tx.shard_id == self.shard_id for tx in self.transactions):
                logger.error("Transaction shard_id mismatch")
                return False

            # Previous block validation
            if previous_block:
                if self.previous_hash != previous_block.hash:
                    logger.error("Block's previous hash doesn't match previous block")
                    return False

                if self.index != previous_block.index + 1:
                    logger.error("Block index is not sequential")
                    return False

                if self.timestamp <= previous_block.timestamp:
                    logger.error("Block timestamp is not after previous block")
                    return False

            # Only validate merkle root and hash if not deserializing
            if not self._is_deserialized and self.merkle_root != self.calculate_merkle_root():
                logger.error("Invalid merkle root")
                return False

            if not self._is_deserialized and self.hash != self.calculate_hash():
                logger.error("Invalid block hash")
                return False

            return True

        except Exception as e:
            logger.error(f"Block validation failed: {str(e)}")
            return False

    def add_transaction(self, transaction: Transaction) -> bool:
        """Add a transaction to the block."""
        try:
            # Validate transaction
            if not transaction.validate():
                logger.error("Cannot add invalid transaction to block")
                return False

            if transaction.shard_id != self.shard_id:
                logger.error("Transaction shard_id doesn't match block")
                return False

            if transaction.transaction_id in self._transaction_ids:
                logger.error(f"Duplicate transaction {transaction.transaction_id}")
                return False

            # Add transaction
            self.transactions.append(transaction)
            self._transaction_ids.add(transaction.transaction_id)

            # Update block state
            self.merkle_root = self.calculate_merkle_root()
            self.hash = self.calculate_hash()

            return True

        except Exception as e:
            logger.error(f"Failed to add transaction: {str(e)}")
            return False

    def to_dict(self) -> Dict:
        """Convert block to dictionary format."""
        return {
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp.isoformat(),
            "transactions": [tx.to_dict() for tx in self.transactions],
            "validator": self.validator,
            "hash": self.hash,
            "nonce": self.nonce,
            "merkle_root": self.merkle_root,
            "shard_id": self.shard_id,
            "cross_shard_refs": sorted(self.cross_shard_refs),
            "metadata": deepcopy(self.metadata),
            "version": self.version,
        }

    @classmethod
    def from_dict(cls, data: Dict) -> "Block":
        """Create block instance from dictionary."""
        try:
            # Mark as being deserialized to prevent recalculation
            block = cls(
                index=data["index"],
                previous_hash=data["previous_hash"],
                timestamp=datetime.fromisoformat(data["timestamp"]),
                transactions=[Transaction.from_dict(tx) for tx in data["transactions"]],
                validator=data["validator"],
                shard_id=data["shard_id"],
                hash=data["hash"],
                nonce=data["nonce"],
                merkle_root=data["merkle_root"],
                cross_shard_refs=sorted(data.get("cross_shard_refs", [])),
                metadata=deepcopy(data.get("metadata", {})),
                version=data.get("version", "1.0")
            )
            block._is_deserialized = True

            return block

        except Exception as e:
            logger.error(f"Failed to create block from dictionary: {str(e)}")
            raise ValueError(f"Invalid block data: {str(e)}")

    def __str__(self) -> str:
        """Return human-readable string representation."""
        return (
            f"Block(index={self.index}, "
            f"hash={self.hash[:8]}..., "
            f"tx_count={len(self.transactions)}, "
            f"shard={self.shard_id})"
        )

# ==================== /home/matt/icn-prototype/blockchain/core/transaction.py ====================

# blockchain/core/transaction.py

from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, Optional, Any
import hashlib
import json
import logging
from copy import deepcopy

logger = logging.getLogger(__name__)

@dataclass
class Transaction:
    """
    Represents a transaction in the ICN blockchain.
    
    A transaction is the fundamental unit of record in the blockchain, representing
    any action or data transfer between parties in the network.
    """
    
    sender: str
    receiver: str
    action: str
    data: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)
    signature: Optional[bytes] = None
    shard_id: Optional[int] = None
    transaction_id: str = field(init=False)
    _is_deserialized: bool = field(default=False, init=False, repr=False)

    def __post_init__(self) -> None:
        """Initialize transaction ID and perform validation after creation."""
        # Validate inputs
        if not self.sender:
            raise ValueError("Sender cannot be empty")
        if not self.receiver:
            raise ValueError("Receiver cannot be empty")
        if not self.action:
            raise ValueError("Action cannot be empty")
            
        # Deep copy data to prevent external modifications
        self.data = deepcopy(self.data)
        
        # Calculate transaction ID
        if not hasattr(self, 'transaction_id') or not self.transaction_id:
            self.transaction_id = self.calculate_id()

    def calculate_id(self) -> str:
        """
        Calculate unique transaction ID using transaction data.
        
        Returns:
            str: The calculated transaction ID
        """
        tx_data = {
            "sender": self.sender,
            "receiver": self.receiver,
            "action": self.action,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "shard_id": self.shard_id
        }
        tx_json = json.dumps(tx_data, sort_keys=True)
        return hashlib.sha256(tx_json.encode()).hexdigest()

    def calculate_hash(self) -> str:
        """
        Calculate cryptographic hash of the transaction.
        
        Returns:
            str: The calculated hash
        """
        tx_dict = self.to_dict()
        # Remove signature from hash calculation
        tx_dict.pop('signature', None)
        tx_json = json.dumps(tx_dict, sort_keys=True)
        return hashlib.sha256(tx_json.encode()).hexdigest()

    def validate(self) -> bool:
        """
        Validate the transaction's structure and data.
        
        Returns:
            bool: True if the transaction is valid
        """
        try:
            # Validate required fields
            if not all([self.sender, self.receiver, self.action]):
                logger.error("Missing required transaction fields")
                return False

            # Validate timestamp
            now = datetime.now()
            if self.timestamp > now + timedelta(minutes=5):
                logger.error(f"Transaction timestamp {self.timestamp} is in the future")
                return False

            if self.timestamp < now - timedelta(days=1):
                logger.error(f"Transaction timestamp {self.timestamp} is too old")
                return False

            # Validate data structure
            if not isinstance(self.data, dict):
                logger.error("Transaction data must be a dictionary")
                return False

            # Validate action format
            if not self.action.isalnum() or len(self.action) > 64:
                logger.error("Invalid action format")
                return False

            # Validate shard_id if present
            if self.shard_id is not None and not isinstance(self.shard_id, int):
                logger.error("Invalid shard_id type")
                return False
            
            if self.shard_id is not None and self.shard_id < 0:
                logger.error("Invalid shard_id value")
                return False

            # Verify transaction ID consistency
            if self.transaction_id != self.calculate_id():
                logger.error("Transaction ID mismatch")
                return False

            return True

        except Exception as e:
            logger.error(f"Transaction validation failed: {str(e)}")
            return False

    def to_dict(self) -> Dict:
        """
        Convert transaction to dictionary format.
        
        Returns:
            Dict: The dictionary representation
        """
        return {
            "transaction_id": self.transaction_id,
            "sender": self.sender,
            "receiver": self.receiver,
            "action": self.action,
            "data": deepcopy(self.data),
            "timestamp": self.timestamp.isoformat(),
            "signature": self.signature.hex() if self.signature else None,
            "shard_id": self.shard_id,
        }

    @classmethod
    def from_dict(cls, data: Dict) -> Transaction:
        """
        Create a transaction instance from a dictionary.
        
        Args:
            data (Dict): The dictionary containing transaction data
            
        Returns:
            Transaction: The created transaction instance
            
        Raises:
            ValueError: If the data is invalid
        """
        try:
            timestamp = datetime.fromisoformat(data["timestamp"])
            signature = bytes.fromhex(data["signature"]) if data.get("signature") else None
            
            # Create transaction with original transaction_id
            tx = cls(
                sender=data["sender"],
                receiver=data["receiver"],
                action=data["action"],
                data=deepcopy(data["data"]),
                timestamp=timestamp,
                signature=signature,
                shard_id=data.get("shard_id")
            )
            
            # Set the original transaction_id
            tx.transaction_id = data["transaction_id"]
            tx._is_deserialized = True
            
            # Verify consistency
            if not tx._is_deserialized and tx.transaction_id != tx.calculate_id():
                raise ValueError("Transaction ID mismatch after deserialization")
            
            return tx

        except Exception as e:
            logger.error(f"Failed to create transaction from dictionary: {str(e)}")
            raise ValueError(f"Invalid transaction data: {str(e)}")

    def __str__(self) -> str:
        """
        Return a human-readable string representation.
        
        Returns:
            str: The string representation
        """
        return (
            f"Transaction(id={self.transaction_id[:8]}..., "
            f"action={self.action}, "
            f"sender={self.sender[:8]}..., "
            f"receiver={self.receiver[:8]}...)"
        )

# ==================== /home/matt/icn-prototype/blockchain/core/shard.py ====================

# ================================================================
# File: blockchain/core/shard.py
# Description: Core shard implementation for the ICN blockchain.
# Handles a partition of the blockchain, managing its own chain of
# blocks, transaction pool, and validation processes.
# ================================================================

from __future__ import annotations
from datetime import datetime, timedelta
from typing import List, Dict, Optional, Set, Tuple
import logging
from .transaction import Transaction
from .block import Block

logger = logging.getLogger(__name__)

class Shard:
    """
    Represents a blockchain shard.

    A shard is a partition of the blockchain that processes a subset of transactions,
    enabling parallel processing and improved scalability. Each shard maintains its
    own chain of blocks, transaction pool, and validation state.

    Attributes:
        shard_id (int): Unique identifier for this shard
        chain (List[Block]): The shard's blockchain
        pending_transactions (List[Transaction]): Pool of unconfirmed transactions
        height (int): Current height of the chain
        max_transactions_per_block (int): Maximum transactions allowed per block
        last_block_time (datetime): Timestamp of the last block
        state (Dict): Shard-specific state storage
        metrics (Dict): Performance and operational metrics
    """

    def __init__(self, shard_id: int, max_transactions_per_block: int = 100):
        """
        Initialize a new shard.

        Args:
            shard_id (int): Unique identifier for the shard
            max_transactions_per_block (int): Maximum transactions per block
        """
        self.shard_id = shard_id
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.height = 0
        self.max_transactions_per_block = max_transactions_per_block
        self.last_block_time = datetime.now()
        self.state: Dict = {}  # Shard-specific state
        self.metrics: Dict = {
            "total_transactions": 0,
            "average_block_time": 0,
            "blocks_created": 0,
            "pending_count": 0,
            "validation_failures": 0,
            "successful_blocks": 0,
            "rejected_transactions": 0,
            "total_size_bytes": 0,
            "average_transactions_per_block": 0
        }
        self.validation_cache: Dict[str, bool] = {}  # Cache validation results
        self.known_validators: Set[str] = set()  # Track known validators
        self.cross_shard_references: Dict[str, List[str]] = {}  # Track cross-shard txs
        self.last_prune_time = datetime.now()
        self._create_genesis_block()

    def _create_genesis_block(self) -> None:
        """Create genesis block for this shard."""
        try:
            genesis_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now(),
                transactions=[],
                validator="genesis",
                shard_id=self.shard_id,
            )
            self.chain.append(genesis_block)
            self.height = 1
            self.last_block_time = genesis_block.timestamp
            self.metrics["blocks_created"] = 1
            self.known_validators.add("genesis")
            self._update_size_metrics(genesis_block)
            logger.info(f"Created genesis block for shard {self.shard_id}")

        except Exception as e:
            logger.error(f"Failed to create genesis block: {str(e)}")
            raise RuntimeError("Failed to initialize shard with genesis block")

    def add_transaction(self, transaction: Transaction) -> bool:
        """
        Add a new transaction to pending pool.

        Args:
            transaction (Transaction): Transaction to add to the pool

        Returns:
            bool: True if transaction was added successfully
        """
        try:
            if transaction.shard_id != self.shard_id:
                logger.error(
                    f"Transaction shard_id {transaction.shard_id} "
                    f"doesn't match shard {self.shard_id}"
                )
                self.metrics["rejected_transactions"] += 1
                return False

            if len(self.pending_transactions) >= self.max_transactions_per_block * 2:
                logger.warning(f"Shard {self.shard_id} transaction pool full")
                self.metrics["rejected_transactions"] += 1
                return False

            # Check if transaction already exists
            tx_id = transaction.transaction_id
            if any(tx.transaction_id == tx_id for tx in self.pending_transactions):
                logger.warning(f"Transaction {tx_id} already in pending pool")
                return False

            # Validate transaction
            if not self._validate_transaction(transaction):
                self.metrics["rejected_transactions"] += 1
                return False

            self.pending_transactions.append(transaction)
            self.metrics["pending_count"] = len(self.pending_transactions)
            
            # Check and record cross-shard references
            if self._is_cross_shard_transaction(transaction):
                self._record_cross_shard_reference(transaction)

            return True

        except Exception as e:
            logger.error(f"Failed to add transaction: {str(e)}")
            self.metrics["rejected_transactions"] += 1
            return False

    def _validate_transaction(self, transaction: Transaction) -> bool:
        """
        Validate a transaction before adding to pool.

        Args:
            transaction (Transaction): Transaction to validate

        Returns:
            bool: True if transaction is valid
        """
        try:
            # Check cache first
            tx_id = transaction.transaction_id
            if tx_id in self.validation_cache:
                return self.validation_cache[tx_id]

            # Basic validation
            if not transaction.validate():
                logger.error(f"Transaction {tx_id} failed basic validation")
                self.validation_cache[tx_id] = False
                return False

            # Check if transaction already exists in chain
            if self.get_transaction_by_id(tx_id):
                logger.error(f"Transaction {tx_id} already exists in chain")
                self.validation_cache[tx_id] = False
                return False

            # Validate timestamp
            if transaction.timestamp > datetime.now() + timedelta(minutes=5):
                logger.error(f"Transaction {tx_id} has future timestamp")
                self.validation_cache[tx_id] = False
                return False

            # Cache and return result
            self.validation_cache[tx_id] = True
            return True

        except Exception as e:
            logger.error(f"Transaction validation failed: {str(e)}")
            return False

    def create_block(self, validator: str) -> Optional[Block]:
        """
        Create a new block from pending transactions.

        Args:
            validator (str): ID of the validator creating the block

        Returns:
            Optional[Block]: New block if created successfully, None otherwise
        """
        if not self.pending_transactions:
            logger.debug(f"No pending transactions in shard {self.shard_id}")
            return None

        try:
            # Select transactions for the block
            selected_transactions = self._select_transactions_for_block()
            if not selected_transactions:
                return None

            # Create the block
            new_block = Block(
                index=self.height,
                previous_hash=self.chain[-1].hash,
                timestamp=datetime.now(),
                transactions=selected_transactions,
                validator=validator,
                shard_id=self.shard_id,
            )

            # Update validator tracking
            self.known_validators.add(validator)

            return new_block

        except Exception as e:
            logger.error(f"Failed to create block: {str(e)}")
            self.metrics["validation_failures"] += 1
            return None

    def _select_transactions_for_block(self) -> List[Transaction]:
        """
        Select and sort transactions for a new block.

        Returns:
            List[Transaction]: Selected transactions for the block
        """
        try:
            # Get initial selection
            candidates = self.pending_transactions[:self.max_transactions_per_block]
            
            # Sort by timestamp and fee (if applicable)
            candidates.sort(key=lambda tx: tx.timestamp)
            
            # Ensure all transactions are still valid
            valid_transactions = [
                tx for tx in candidates
                if self._validate_transaction(tx)
            ]

            return valid_transactions

        except Exception as e:
            logger.error(f"Failed to select transactions: {str(e)}")
            return []

    def add_block(self, block: Block) -> bool:
        """
        Add a validated block to the shard chain.

        Args:
            block (Block): Block to add to the chain

        Returns:
            bool: True if block was added successfully
        """
        try:
            # Validate block attributes
            if not self._validate_block_attributes(block):
                return False

            # Validate block against previous block
            if not block.validate(self.chain[-1]):
                logger.error("Block validation failed")
                self.metrics["validation_failures"] += 1
                return False

            # Update metrics
            self._update_metrics_for_new_block(block)

            # Remove included transactions from pending pool
            self._remove_included_transactions(block)

            # Add block to chain
            self.chain.append(block)
            self.height += 1
            self.last_block_time = block.timestamp

            # Update cross-shard references
            self._update_cross_shard_references(block)

            logger.info(f"Added block {block.index} to shard {self.shard_id}")
            self.metrics["successful_blocks"] += 1
            return True

        except Exception as e:
            logger.error(f"Failed to add block: {str(e)}")
            self.metrics["validation_failures"] += 1
            return False

    def _validate_block_attributes(self, block: Block) -> bool:
        """
        Validate block attributes before adding to chain.

        Args:
            block (Block): Block to validate

        Returns:
            bool: True if block attributes are valid
        """
        if block.shard_id != self.shard_id:
            logger.error(
                f"Block shard_id {block.shard_id} "
                f"doesn't match shard {self.shard_id}"
            )
            return False

        if block.index != self.height:
            logger.error(
                f"Block index {block.index} "
                f"doesn't match current height {self.height}"
            )
            return False

        return True

    def _update_metrics_for_new_block(self, block: Block) -> None:
        """
        Update shard metrics when adding a new block.

        Args:
            block (Block): New block being added
        """
        block_time = (block.timestamp - self.last_block_time).total_seconds()
        blocks_created = self.metrics["blocks_created"]
        
        # Update average block time
        self.metrics["average_block_time"] = (
            (self.metrics["average_block_time"] * blocks_created + block_time)
            / (blocks_created + 1)
        )
        
        # Update other metrics
        self.metrics["blocks_created"] += 1
        self.metrics["total_transactions"] += len(block.transactions)
        
        # Update average transactions per block
        total_tx = sum(len(b.transactions) for b in self.chain) + len(block.transactions)
        self.metrics["average_transactions_per_block"] = total_tx / (blocks_created + 1)
        
        # Update size metrics
        self._update_size_metrics(block)

    def _update_size_metrics(self, block: Block) -> None:
        """
        Update size-related metrics for the shard.

        Args:
            block (Block): Block to measure
        """
        try:
            # Estimate block size
            block_dict = block.to_dict()
            block_size = len(str(block_dict))  # Simple size estimation
            self.metrics["total_size_bytes"] += block_size

        except Exception as e:
            logger.error(f"Failed to update size metrics: {str(e)}")

    def _remove_included_transactions(self, block: Block) -> None:
        """
        Remove transactions included in a block from the pending pool.

        Args:
            block (Block): Block containing transactions to remove
        """
        tx_ids = {tx.transaction_id for tx in block.transactions}
        self.pending_transactions = [
            tx for tx in self.pending_transactions 
            if tx.transaction_id not in tx_ids
        ]
        self.metrics["pending_count"] = len(self.pending_transactions)

    def _is_cross_shard_transaction(self, transaction: Transaction) -> bool:
        """
        Check if a transaction involves multiple shards.

        Args:
            transaction (Transaction): Transaction to check

        Returns:
            bool: True if transaction involves multiple shards
        """
        return 'target_shard' in transaction.data

    def _record_cross_shard_reference(self, transaction: Transaction) -> None:
        """
        Record a cross-shard transaction reference.

        Args:
            transaction (Transaction): Cross-shard transaction to record
        """
        target_shard = transaction.data.get('target_shard')
        if target_shard:
            if target_shard not in self.cross_shard_references:
                self.cross_shard_references[target_shard] = []
            self.cross_shard_references[target_shard].append(transaction.transaction_id)

    def _update_cross_shard_references(self, block: Block) -> None:
        """
        Update cross-shard references when adding a block.

        Args:
            block (Block): Block to process for cross-shard references
        """
        for tx in block.transactions:
            if self._is_cross_shard_transaction(tx):
                target_shard = tx.data.get('target_shard')
                if target_shard in self.cross_shard_references:
                    self.cross_shard_references[target_shard] = [
                        tx_id for tx_id in self.cross_shard_references[target_shard]
                        if tx_id != tx.transaction_id
                    ]

    def get_latest_block(self) -> Block:
        """
        Get the latest block in this shard.

        Returns:
            Block: The most recent block in the chain
        """
        return self.chain[-1]

    def validate_chain(self) -> bool:
        """
        Validate the entire shard chain.

        Returns:
            bool: True if the chain is valid
        """
        try:
            for i in range(1, len(self.chain)):
                current_block = self.chain[i]
                previous_block = self.chain[i - 1]

                # Validate block
                if not current_block.validate(previous_block):
                    logger.error(f"Invalid block at height {i}")
                    return False

                # Validate sequence
                if current_block.index != previous_block.index + 1:
                    logger.error(f"Non-sequential blocks at height {i}")
                    return False

                # Validate timestamps
                if current_block.timestamp <= previous_block.timestamp:
                    logger.error(f"Invalid timestamp at height {i}")
                    return False

            return True

        except Exception as e:
            logger.error(f"Chain validation failed: {str(e)}")
            return False

    def get_block_by_hash(self, block_hash: str) -> Optional[Block]:
        """
        Retrieve a block by its hash.

        Args:
            block_hash (str): Hash of the block to retrieve

        Returns:
            Optional[Block]: The block if found, None otherwise
        """
        try:
            # Use next() with generator expression for efficient search
            return next(
                (block for block in self.chain if block.hash == block_hash),
                None
            )
        except Exception as e:
            logger.error(f"Failed to retrieve block: {str(e)}")
            return None

    def get_block_by_height(self, height: int) -> Optional[Block]:
        """
        Retrieve a block by its height.

        Args:
            height (int): Height of the block to retrieve

        Returns:
            Optional[Block]: The block if found, None otherwise
        """
        try:
            if 0 <= height < len(self.chain):
                return self.chain[height]
            logger.warning(f"Block height {height} out of range")
            return None
        except Exception as e:
            logger.error(f"Failed to retrieve block: {str(e)}")
            return None

    def get_transaction_by_id(self, transaction_id: str) -> Optional[Transaction]:
        """
        Find a transaction by its ID in the chain.

        Args:
            transaction_id (str): ID of the transaction to find

        Returns:
            Optional[Transaction]: The transaction if found, None otherwise
        """
        try:
            # First check pending transactions
            pending_tx = next(
                (tx for tx in self.pending_transactions if tx.transaction_id == transaction_id),
                None
            )
            if pending_tx:
                return pending_tx

            # Then search through blocks from newest to oldest
            for block in reversed(self.chain):
                tx = next(
                    (tx for tx in block.transactions if tx.transaction_id == transaction_id),
                    None
                )
                if tx:
                    return tx
            return None
        except Exception as e:
            logger.error(f"Failed to retrieve transaction: {str(e)}")
            return None

    def get_transactions_in_range(self, start_height: int, end_height: int) -> List[Transaction]:
        """
        Get all transactions within a specified block height range.

        Args:
            start_height (int): Starting block height (inclusive)
            end_height (int): Ending block height (inclusive)

        Returns:
            List[Transaction]: List of transactions in the specified range
        """
        transactions = []
        try:
            start_idx = max(0, start_height)
            end_idx = min(end_height + 1, len(self.chain))
            
            for i in range(start_idx, end_idx):
                transactions.extend(self.chain[i].transactions)
            
            return transactions
        except Exception as e:
            logger.error(f"Failed to get transactions in range: {str(e)}")
            return []

    def prune_pending_transactions(self, max_age_minutes: int = 60) -> None:
        """
        Remove old pending transactions.

        Args:
            max_age_minutes (int): Maximum age of transactions to keep in minutes
        """
        try:
            current_time = datetime.now()
            original_count = len(self.pending_transactions)
            
            self.pending_transactions = [
                tx for tx in self.pending_transactions
                if (current_time - tx.timestamp).total_seconds() < max_age_minutes * 60
            ]
            
            pruned_count = original_count - len(self.pending_transactions)
            self.metrics["pending_count"] = len(self.pending_transactions)
            
            if pruned_count > 0:
                logger.info(f"Pruned {pruned_count} old transactions")

            # Clear validation cache for pruned transactions
            self._prune_validation_cache()

        except Exception as e:
            logger.error(f"Failed to prune transactions: {str(e)}")

    def _prune_validation_cache(self) -> None:
        """Clean up the validation cache for efficiency."""
        try:
            # Keep cache entries only for existing transactions
            valid_tx_ids = {tx.transaction_id for tx in self.pending_transactions}
            self.validation_cache = {
                tx_id: result
                for tx_id, result in self.validation_cache.items()
                if tx_id in valid_tx_ids
            }
        except Exception as e:
            logger.error(f"Failed to prune validation cache: {str(e)}")

    def get_metrics(self) -> Dict:
        """
        Get comprehensive shard metrics.

        Returns:
            Dict: Dictionary containing current metrics
        """
        try:
            return {
                "shard_id": self.shard_id,
                "height": self.height,
                "pending_transactions": len(self.pending_transactions),
                "last_block_time": self.last_block_time.isoformat(),
                "chain_size": len(self.chain),
                "total_transactions_in_chain": sum(
                    len(block.transactions) for block in self.chain
                ),
                "known_validators": len(self.known_validators),
                "cross_shard_references": {
                    k: len(v) for k, v in self.cross_shard_references.items()
                },
                "validation_cache_size": len(self.validation_cache),
                **self.metrics,
            }
        except Exception as e:
            logger.error(f"Failed to get metrics: {str(e)}")
            return {}

    def get_chain_stats(self) -> Dict:
        """
        Get detailed statistics about the shard's chain.

        Returns:
            Dict: Dictionary containing chain statistics
        """
        try:
            block_times = []
            tx_counts = []
            validator_blocks = {}

            for i in range(1, len(self.chain)):
                current_block = self.chain[i]
                prev_block = self.chain[i-1]
                
                # Calculate block time
                block_time = (current_block.timestamp - prev_block.timestamp).total_seconds()
                block_times.append(block_time)
                
                # Track transactions
                tx_count = len(current_block.transactions)
                tx_counts.append(tx_count)
                
                # Track validator activity
                validator = current_block.validator
                validator_blocks[validator] = validator_blocks.get(validator, 0) + 1

            return {
                "average_block_time": sum(block_times) / len(block_times) if block_times else 0,
                "min_block_time": min(block_times) if block_times else 0,
                "max_block_time": max(block_times) if block_times else 0,
                "average_transactions": sum(tx_counts) / len(tx_counts) if tx_counts else 0,
                "max_transactions": max(tx_counts) if tx_counts else 0,
                "validator_distribution": validator_blocks,
                "total_blocks": len(self.chain),
                "total_validators": len(validator_blocks)
            }
        except Exception as e:
            logger.error(f"Failed to get chain stats: {str(e)}")
            return {}

    def to_dict(self) -> Dict:
        """
        Convert shard state to dictionary.

        Returns:
            Dict: Dictionary representation of the shard
        """
        try:
            return {
                "shard_id": self.shard_id,
                "height": self.height,
                "chain": [block.to_dict() for block in self.chain],
                "pending_transactions": [
                    tx.to_dict() for tx in self.pending_transactions
                ],
                "max_transactions_per_block": self.max_transactions_per_block,
                "last_block_time": self.last_block_time.isoformat(),
                "state": self.state,
                "metrics": self.metrics,
                "cross_shard_references": self.cross_shard_references,
                "known_validators": list(self.known_validators),
            }
        except Exception as e:
            logger.error(f"Failed to convert shard to dictionary: {str(e)}")
            raise ValueError(f"Failed to serialize shard: {str(e)}")

    @classmethod
    def from_dict(cls, data: Dict) -> 'Shard':
        """
        Create shard from dictionary.

        Args:
            data (Dict): Dictionary containing shard data

        Returns:
            Shard: New shard instance

        Raises:
            ValueError: If the data is invalid or incomplete
        """
        try:
            shard = cls(
                shard_id=data["shard_id"],
                max_transactions_per_block=data["max_transactions_per_block"],
            )

            # Restore chain
            shard.chain = [Block.from_dict(block) for block in data["chain"]]

            # Restore pending transactions
            shard.pending_transactions = [
                Transaction.from_dict(tx) for tx in data["pending_transactions"]
            ]

            # Restore other attributes
            shard.height = data["height"]
            shard.last_block_time = datetime.fromisoformat(data["last_block_time"])
            shard.state = data["state"]
            shard.metrics = data["metrics"]
            shard.cross_shard_references = data.get("cross_shard_references", {})
            shard.known_validators = set(data.get("known_validators", []))

            return shard

        except Exception as e:
            logger.error(f"Failed to create shard from dictionary: {str(e)}")
            raise ValueError(f"Invalid shard data: {str(e)}")

    def __str__(self) -> str:
        """
        Return a human-readable string representation of the shard.

        Returns:
            str: String representation of the shard
        """
        return (
            f"Shard(id={self.shard_id}, "
            f"height={self.height}, "
            f"pending_tx={len(self.pending_transactions)}, "
            f"blocks={len(self.chain)}, "
            f"validators={len(self.known_validators)})"
        )

    def __repr__(self) -> str:
        """
        Return a detailed string representation of the shard.

        Returns:
            str: Detailed string representation of the shard
        """
        return (
            f"Shard(shard_id={self.shard_id}, "
            f"height={self.height}, "
            f"chain_length={len(self.chain)}, "
            f"pending_transactions={len(self.pending_transactions)}, "
            f"last_block_time='{self.last_block_time.isoformat()}', "
            f"metrics={self.metrics})"
        )

# ==================== /home/matt/icn-prototype/blockchain/core/blockchain.py ====================

# ================================================================
# File: blockchain/core/blockchain.py
# ================================================================
# Description: Core Blockchain implementation for the ICN system.
# 
# This module manages the ICN blockchain, coordinating shards, nodes,
# transactions, consensus, and smart contract execution.
# ================================================================

from __future__ import annotations
from typing import List, Dict, Optional, Any
from datetime import datetime, timedelta
import logging
import hashlib
import asyncio

from .block import Block
from .node import Node
from .shard import Shard
from .transaction import Transaction
from ..consensus.proof_of_cooperation import ProofOfCooperation
from ..contracts.smart_contract import SmartContract
from ..contracts.contract_executor import ContractExecutor

logger = logging.getLogger(__name__)

class Blockchain:
    """
    Core Blockchain implementation for the ICN system.
    Manages shards, transactions, blocks, nodes, consensus, and contracts.
    """

    def __init__(self, num_shards: int = 4, initial_mana: int = 1000, mana_regen_rate: int = 10):
        """
        Initialize the blockchain with specified shards, mana, and consensus.
        """
        self.nodes: Dict[str, Node] = {}
        self.shards: Dict[int, Shard] = {}
        self.chain: List[Block] = []
        self.transaction_pool: List[Transaction] = []
        self.smart_contracts: Dict[str, SmartContract] = {}

        self.consensus_mechanism = ProofOfCooperation()
        self.contract_executor = ContractExecutor()

        self.cooperative_mana = initial_mana
        self.mana_regen_rate = mana_regen_rate
        self.genesis_block_created = False

        self._initialize_shards(num_shards)
        self.create_genesis_block()

    def _initialize_shards(self, num_shards: int) -> None:
        """
        Initialize shards for parallel transaction processing.
        """
        for shard_id in range(num_shards):
            self.create_shard(shard_id)

    def create_genesis_block(self) -> None:
        """
        Create the genesis block with no transactions and a special validator.
        """
        if self.genesis_block_created:
            logger.warning("Genesis block already created")
            return

        genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=-1
        )

        self.chain.append(genesis_block)
        self.genesis_block_created = True
        logger.info("Genesis block created")

    def register_node(self, node: Node) -> bool:
        """
        Register a node and make it eligible for validation.
        """
        if not isinstance(node, Node) or node.node_id in self.nodes:
            logger.error(f"Invalid or duplicate node: {node.node_id}")
            return False

        node.is_validator = True
        self.nodes[node.node_id] = node
        logger.info(f"Node {node.node_id} registered as validator")
        return True

    def create_shard(self, shard_id: int) -> bool:
        """
        Create a new shard with the given ID.
        """
        if shard_id in self.shards:
            logger.error(f"Shard {shard_id} already exists")
            return False

        self.shards[shard_id] = Shard(shard_id=shard_id)
        logger.info(f"Shard {shard_id} created")
        return True

    def add_transaction(self, transaction: Dict) -> bool:
        """
        Add a transaction after initializing and validating it.
        """
        if not isinstance(transaction, dict):
            logger.error("Invalid transaction format")
            return False

        tx = Transaction(
            sender=transaction['sender'],
            receiver=transaction['receiver'],
            action=transaction['action'],
            data=transaction['data']
        )

        shard_id = self._calculate_shard_id(tx)
        tx.shard_id = shard_id
        tx.transaction_id = self._calculate_transaction_id(tx)

        if shard_id not in self.shards or not self.shards[shard_id].add_transaction(tx):
            logger.error(f"Failed to add transaction {tx.transaction_id} to shard {shard_id}")
            return False

        logger.info(f"Transaction {tx.transaction_id} added to shard {shard_id}")
        return True

    def _calculate_shard_id(self, transaction: Transaction) -> int:
        """
        Calculate the shard ID for the transaction using its hash.
        """
        tx_hash = hashlib.sha256(str(transaction).encode()).hexdigest()
        return int(tx_hash, 16) % len(self.shards)

    def _calculate_transaction_id(self, transaction: Transaction) -> str:
        """
        Calculate the transaction ID using the hash of its contents.
        """
        tx_hash = hashlib.sha256(str(transaction).encode()).hexdigest()
        return tx_hash

    def create_block(self, shard_id: Optional[int] = None) -> Optional[Block]:
        """
        Create a new block in the specified shard.
        """
        shard = self.shards.get(shard_id)
        if not shard:
            logger.error(f"Shard {shard_id} not found")
            return None

        validator = self.consensus_mechanism.select_validator(list(self.nodes.values()), shard_id)
        if not validator:
            logger.error(f"No eligible validator for shard {shard_id}")
            return None

        new_block = shard.create_block(validator.node_id)
        if new_block and self.add_block(new_block):
            return new_block

        return None

    def add_block(self, block: Block) -> bool:
        """
        Add a validated block to the chain.
        """
        if not isinstance(block, Block) or not block.validate(self.chain[-1]):
            logger.error("Block validation failed")
            return False

        self.chain.append(block)
        logger.info(f"Block {block.index} added to chain")
        return True

    def regenerate_mana(self) -> None:
        """
        Regenerate cooperative mana up to the cap.
        """
        self.cooperative_mana = min(1000, self.cooperative_mana + self.mana_regen_rate)

    def get_chain_metrics(self) -> Dict:
        """
        Return blockchain metrics including chain length and mana.
        """
        return {
            "chain_length": len(self.chain),
            "total_transactions": sum(len(block.transactions) for block in self.chain),
            "average_block_time": self._calculate_average_block_time(),
            "active_nodes": len(self.nodes),
            "active_shards": len(self.shards),
            "cooperative_mana": self.cooperative_mana,
            "contract_count": len(self.smart_contracts),
        }

    def _calculate_average_block_time(self) -> float:
        """
        Calculate the average time between blocks.
        """
        if len(self.chain) <= 1:
            return 0.0

        total_time = sum(
            (self.chain[i].timestamp - self.chain[i-1].timestamp).total_seconds()
            for i in range(1, len(self.chain))
        )
        return total_time / (len(self.chain) - 1)

    def validate_chain(self) -> bool:
        """
        Validate the integrity of the entire chain.
        """
        for i in range(1, len(self.chain)):
            if not self.chain[i].validate(self.chain[i-1]):
                logger.error(f"Block {i} validation failed")
                return False

        logger.info("Blockchain is valid")
        return True

    async def deploy_smart_contract(self, contract: SmartContract) -> bool:
        """
        Deploy a smart contract and register it.
        """
        if contract.contract_id in self.smart_contracts or self.cooperative_mana < contract.mana_cost:
            logger.error(f"Contract {contract.contract_id} deployment failed")
            return False

        self.smart_contracts[contract.contract_id] = contract
        self.cooperative_mana -= contract.mana_cost
        logger.info(f"Contract {contract.contract_id} deployed")
        return True

    async def execute_smart_contract(self, contract_id: str, input_data: Dict, caller: str) -> Optional[Dict]:
        """
        Execute a smart contract with the given input data.
        """
        contract = self.smart_contracts.get(contract_id)
        if not contract or self.cooperative_mana < contract.mana_cost:
            logger.error(f"Failed to execute contract {contract_id}")
            return None

        result = await self.contract_executor.execute_contract(contract_id, input_data, caller)
        if result is not None:
            self.cooperative_mana -= contract.mana_cost
            logger.info(f"Contract {contract_id} executed by {caller}")
        else:
            logger.error(f"Failed to execute contract {contract_id}")

        return result


# ==================== /home/matt/icn-prototype/blockchain/core/__init__.py ====================

# blockchain/core/__init__.py
"""Core blockchain components."""
from .node import Node
from .block import Block
from .transaction import Transaction
from .shard import Shard
from .blockchain import Blockchain

__all__ = [
    "Node",
    "Block",
    "Transaction", 
    "Shard",
    "Blockchain"
]


# ==================== /home/matt/icn-prototype/blockchain/contracts/contract_executor.py ====================

"""
blockchain/contracts/contract_executor.py

This module implements the ContractExecutor for the ICN blockchain, providing
secure contract deployment, execution, and lifecycle management. It enforces
resource limits, security constraints, and cooperative principles.

Key features:
- Secure sandbox execution environment
- Resource management via mana system
- Dependency resolution and validation
- Cross-contract communication
- State integrity protection
- Concurrent execution handling
"""

from typing import Dict, List, Optional, Set
import logging
from datetime import datetime
import asyncio
import re
from .smart_contract import SmartContract, ContractExecutionError

logger = logging.getLogger(__name__)

class ContractExecutor:
    """Manages smart contract deployment, execution, and lifecycle.

    The ContractExecutor ensures secure and fair contract operations within
    the ICN ecosystem. It handles:
    - Contract deployment and validation
    - Secure execution environment
    - Resource management (mana)
    - Dependency resolution
    - State management
    - Concurrent execution
    """

    # Safe imports that contracts are allowed to use
    SAFE_IMPORTS = {
        'math', 'datetime', 'json', 'collections',
        'typing', 'dataclasses', 'enum', 'decimal'
    }

    # Regular expressions for code validation
    CODE_PATTERNS = {
        'import': re.compile(r'^import\s+(\w+)'),
        'from_import': re.compile(r'^from\s+(\w+)\s+import'),
        'execute_func': re.compile(r'def\s+execute\s*\([^)]*\):')
    }

    def __init__(self, initial_mana: int = 1000, mana_regen_rate: int = 10):
        """Initialize the ContractExecutor.

        Args:
            initial_mana: Starting mana pool for contract execution
            mana_regen_rate: Rate at which mana regenerates per cycle
        """
        # Contract management
        self.contracts: Dict[str, SmartContract] = {}
        self.dependency_graph: Dict[str, Set[str]] = {}
        
        # Resource management
        self.mana_pool = initial_mana
        self.mana_regen_rate = mana_regen_rate
        self.max_mana = initial_mana * 2
        
        # Execution management
        self.execution_queue: List[Dict] = []
        self.max_queue_size = 1000
        self.execution_lock = asyncio.Lock()
        
        # Performance tracking
        self.metrics = {
            "total_executions": 0,
            "failed_executions": 0,
            "total_mana_consumed": 0,
            "average_execution_time": 0.0,
            "contracts_deployed": 0,
            "successful_deployments": 0,
            "failed_deployments": 0
        }

    async def deploy_contract(self, contract: SmartContract) -> bool:
        """Deploy a new smart contract.

        Args:
            contract: SmartContract instance to deploy

        Returns:
            bool: True if deployment successful, False otherwise
        
        The deployment process includes:
        1. Code validation
        2. Dependency checking
        3. Security verification
        4. Resource allocation
        """
        try:
            # Check for existing contract
            if contract.contract_id in self.contracts:
                logger.error(f"Contract {contract.contract_id} already exists")
                return False

            # Validate contract code
            if not await self._validate_contract_code(contract.code):
                return False

            # Check dependencies
            if not await self._validate_dependencies(contract.dependencies):
                return False

            # Store contract and update graph
            self.contracts[contract.contract_id] = contract
            self.dependency_graph[contract.contract_id] = contract.dependencies.copy()
            
            # Update metrics
            self.metrics["contracts_deployed"] += 1
            self.metrics["successful_deployments"] += 1
            
            logger.info(f"Successfully deployed contract {contract.contract_id}")
            return True

        except Exception as e:
            logger.error(f"Contract deployment failed: {str(e)}")
            self.metrics["failed_deployments"] += 1
            return False

    async def _validate_contract_code(self, code: str) -> bool:
        """Validate contract code safety and structure.

        Args:
            code: Contract source code to validate

        Returns:
            bool: True if code is safe and valid
        """
        try:
            # Check for execute function
            if not self.CODE_PATTERNS['execute_func'].search(code):
                logger.error("Contract missing execute function")
                return False

            # Validate imports
            for line in code.split('\n'):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Check import statements
                import_match = self.CODE_PATTERNS['import'].match(line)
                from_match = self.CODE_PATTERNS['from_import'].match(line)

                if import_match:
                    module = import_match.group(1)
                    if module not in self.SAFE_IMPORTS:
                        logger.error(f"Unsafe import detected: {module}")
                        return False
                elif from_match:
                    module = from_match.group(1)
                    if module not in self.SAFE_IMPORTS:
                        logger.error(f"Unsafe import detected: {module}")
                        return False

            # Test compilation
            compile(code, '<string>', 'exec')
            return True

        except Exception as e:
            logger.error(f"Code validation failed: {str(e)}")
            return False

    async def execute_contract(
        self, contract_id: str, input_data: Dict, caller: str
    ) -> Dict:
        """Execute a smart contract.

        Args:
            contract_id: ID of contract to execute
            input_data: Input parameters for contract
            caller: ID of calling entity

        Returns:
            Dict containing execution results

        Raises:
            ContractExecutionError: If execution fails
        """
        async with self.execution_lock:
            try:
                # Get and validate contract
                contract = self.contracts.get(contract_id)
                if not contract:
                    raise ContractExecutionError(f"Contract {contract_id} not found")

                # Check authorization
                if caller not in contract.allowed_callers:
                    raise ContractExecutionError(f"Caller {caller} not authorized")

                # Check mana
                if self.mana_pool < contract.mana_cost:
                    raise ContractExecutionError("Insufficient mana")

                # Execute contract
                execution_start = datetime.now()
                result = contract.execute(input_data, self.mana_pool)

                # Update resources
                mana_used = result["mana_used"]
                self.mana_pool = max(0, self.mana_pool - mana_used)
                self.metrics["total_mana_consumed"] += mana_used

                # Update metrics
                execution_time = (datetime.now() - execution_start).total_seconds()
                await self._update_metrics(execution_time, True)

                return result

            except Exception as e:
                await self._update_metrics(0, False)
                raise ContractExecutionError(str(e))

    async def _validate_dependencies(self, dependencies: Set[str]) -> bool:
        """Validate contract dependencies.

        Args:
            dependencies: Set of contract IDs this contract depends on

        Returns:
            bool: True if dependencies are valid
        """
        try:
            # Check existence
            for dep in dependencies:
                if dep not in self.contracts:
                    logger.error(f"Dependency not found: {dep}")
                    return False

            # Check for cycles
            visited: Set[str] = set()
            path: List[str] = []

            async def check_cycle(contract_id: str) -> bool:
                if contract_id in path:
                    cycle = ' -> '.join(path + [contract_id])
                    logger.error(f"Circular dependency detected: {cycle}")
                    return False

                if contract_id in visited:
                    return True

                visited.add(contract_id)
                path.append(contract_id)

                for dep in self.dependency_graph.get(contract_id, set()):
                    if not await check_cycle(dep):
                        return False

                path.pop()
                return True

            # Check each dependency
            for dep in dependencies:
                if not await check_cycle(dep):
                    return False

            return True

        except Exception as e:
            logger.error(f"Dependency validation failed: {str(e)}")
            return False

    async def _update_metrics(self, execution_time: float, success: bool) -> None:
        """Update executor metrics.

        Args:
            execution_time: Time taken for execution
            success: Whether execution was successful
        """
        try:
            self.metrics["total_executions"] += 1
            if not success:
                self.metrics["failed_executions"] += 1

            # Update average execution time
            total = self.metrics["average_execution_time"] * (self.metrics["total_executions"] - 1)
            self.metrics["average_execution_time"] = (total + execution_time) / self.metrics["total_executions"]

        except Exception as e:
            logger.error(f"Failed to update metrics: {str(e)}")

    async def regenerate_mana(self) -> None:
        """Regenerate mana pool resources."""
        try:
            old_mana = self.mana_pool
            self.mana_pool = min(self.max_mana, self.mana_pool + self.mana_regen_rate)
            
            if self.mana_pool > old_mana:
                logger.debug(f"Regenerated mana: {self.mana_pool - old_mana}")

        except Exception as e:
            logger.error(f"Mana regeneration failed: {str(e)}")

    def get_metrics(self) -> Dict:
        """Get executor metrics and statistics."""
        return {
            **self.metrics,
            "current_mana": self.mana_pool,
            "queue_length": len(self.execution_queue),
            "active_contracts": len(self.contracts)
        }

    async def queue_execution(self, contract_id: str, input_data: Dict, caller: str) -> bool:
        """Queue a contract execution request.

        Args:
            contract_id: ID of contract to execute
            input_data: Input parameters
            caller: ID of calling entity

        Returns:
            bool: True if successfully queued
        """
        try:
            if len(self.execution_queue) >= self.max_queue_size:
                logger.error("Execution queue full")
                return False

            self.execution_queue.append({
                "contract_id": contract_id,
                "input_data": input_data,
                "caller": caller,
                "timestamp": datetime.now()
            })
            return True

        except Exception as e:
            logger.error(f"Failed to queue execution: {str(e)}")
            return False

# ==================== /home/matt/icn-prototype/blockchain/contracts/smart_contract.py ====================

"""
blockchain/contracts/smart_contract.py

This module implements the SmartContract class for the ICN blockchain, providing
a secure, sandboxed environment for executing decentralized code. The implementation
follows cooperative principles and ensures fair resource usage.

Key features:
- Secure execution environment with restricted capabilities
- Resource management through mana system
- State persistence and size limitations
- Execution history and metrics tracking
- Caller authorization management
- Cross-contract dependencies
- Daily execution limits and cooldowns
"""

from __future__ import annotations
from datetime import datetime, timedelta
from typing import Dict, List, Set, Optional, Any, Union
import time
import logging
import hashlib
import json
import sys
from io import StringIO
from copy import deepcopy

logger = logging.getLogger(__name__)

class ContractExecutionError(Exception):
    """Exception raised for contract execution failures.
    
    This includes:
    - Code execution errors
    - Resource limit violations
    - State size exceeded
    - Authorization failures
    - Timeout errors
    """
    pass

class SmartContract:
    """Smart contract implementation for the ICN blockchain.
    
    Smart contracts are self-executing code units that run in a secure sandbox.
    They maintain state, track execution metrics, and enforce resource limits
    to ensure fair usage of network resources.
    
    Attributes:
        contract_id (str): Unique identifier for the contract
        code (str): Python source code of the contract
        creator (str): Identity of contract creator
        state (Dict): Contract's persistent state storage
        mana_cost (int): Mana required per execution
        version (str): Contract version identifier
        
    Resource Limits:
        - Maximum state size (default: 1MB)
        - Maximum execution time (default: 5s)
        - Maximum mana per execution (default: 100)
        - Maximum daily executions (default: 1000)
    """

    # Safe built-ins allowed in contract execution
    SAFE_BUILTINS = {
        "abs": abs,
        "bool": bool,
        "dict": dict,
        "float": float,
        "int": int,
        "len": len,
        "list": list,
        "max": max,
        "min": min,
        "round": round,
        "sorted": sorted,
        "str": str,
        "sum": sum,
    }

    def __init__(
        self,
        contract_id: str,
        code: str,
        creator: str,
        mana_cost: int = 10,
        version: str = "1.0",
    ) -> None:
        """Initialize a new smart contract.
        
        Args:
            contract_id: Unique identifier for the contract
            code: Contract source code in Python
            creator: Identity of the contract creator
            mana_cost: Mana cost per execution
            version: Version string for the contract
            
        The constructor initializes execution tracking, state storage,
        and resource limits while setting up the secure execution environment.
        """
        # Basic contract information
        self.contract_id = contract_id
        self.code = code
        self.creator = creator
        self.state: Dict = {}
        self.mana_cost = mana_cost
        self.version = version
        
        # Execution tracking
        self.created_at = datetime.now()
        self.last_executed: Optional[datetime] = None
        self.execution_count = 0
        self.total_mana_consumed = 0
        self.execution_history: List[Dict] = []
        
        # Previous state for rollback
        self._previous_state: Optional[Dict] = None
        
        # Metadata and capabilities
        self.metadata: Dict = {
            "created_at": self.created_at,
            "version": version,
            "creator": creator,
            "description": "",
            "tags": set(),
            "last_updated": self.created_at
        }
        
        # Dependencies and authorization
        self.dependencies: Set[str] = set()
        self.allowed_callers: Set[str] = {creator}
        
        # Resource restrictions
        self.restrictions: Dict = {
            "max_state_size": 1024 * 1024,  # 1MB
            "max_execution_time": 5,         # seconds
            "max_mana_per_execution": 100,   # mana
            "max_daily_executions": 1000,    # executions
        }
        
        # Daily execution tracking
        self.daily_executions = 0
        self.last_reset = datetime.now()

    def execute(self, input_data: Dict, available_mana: int) -> Dict:
        """Execute the smart contract with given input data.
        
        Args:
            input_data: Dictionary of input parameters for the contract
            available_mana: Amount of mana available for execution
            
        Returns:
            Dictionary containing:
            - execution result
            - updated state
            - mana consumed
            - execution time
            - output captured
            
        Raises:
            ContractExecutionError: If execution fails or violates restrictions
        """
        self._reset_daily_executions()
        self._backup_state()
        
        try:
            # Validate execution conditions
            validation_result = self._validate_execution(input_data, available_mana)
            if validation_result.get("error"):
                raise ContractExecutionError(validation_result["error"])

            execution_start = time.time()
            stdout_capture = StringIO()
            original_stdout = sys.stdout
            sys.stdout = stdout_capture

            try:
                # Set up and execute
                local_namespace = self._setup_execution_environment(input_data)
                exec(self.code, {}, local_namespace)

                if "execute" not in local_namespace:
                    raise ContractExecutionError("Contract missing execute function")

                # Execute with timing check
                if time.time() - execution_start > self.restrictions["max_execution_time"]:
                    raise ContractExecutionError("Execution time limit exceeded")

                result = local_namespace["execute"](input_data, self.state)

                # Validate post-execution state
                if len(str(self.state)) > self.restrictions["max_state_size"]:
                    self._rollback_state()
                    raise ContractExecutionError("State size limit exceeded after execution")

                # Update metrics and return result
                self._update_execution_metrics(execution_start)
                output = stdout_capture.getvalue()

                return {
                    "state": self.state,
                    "result": result,
                    "mana_used": self.mana_cost,
                    "execution_time": time.time() - execution_start,
                    "output": output,
                }

            finally:
                sys.stdout = original_stdout

        except ContractExecutionError:
            self._rollback_state()
            raise
        except Exception as e:
            self._rollback_state()
            logger.error(f"Contract execution failed: {str(e)}")
            raise ContractExecutionError(str(e))

    def _validate_execution(self, input_data: Dict, available_mana: int) -> Dict:
        """Validate all conditions required for contract execution.
        
        Performs comprehensive validation including:
        - Daily execution limits
        - Mana availability
        - Current and projected state size
        - Input data format
        """
        try:
            if self.daily_executions >= self.restrictions["max_daily_executions"]:
                return {"error": "Daily execution limit exceeded"}

            if available_mana < self.mana_cost:
                return {"error": "Insufficient mana"}

            # Calculate potential state size
            current_state_size = len(str(self.state))
            potential_growth = len(str(input_data)) * 2  # Conservative estimate
            if current_state_size + potential_growth > self.restrictions["max_state_size"]:
                return {"error": "Projected state size would exceed limit"}

            if not isinstance(input_data, dict):
                return {"error": "Invalid input data format"}

            return {}

        except Exception as e:
            return {"error": f"Validation failed: {str(e)}"}

    def _backup_state(self) -> None:
        """Create a backup of the current state for potential rollback."""
        self._previous_state = deepcopy(self.state)

    def _rollback_state(self) -> None:
        """Rollback to the previous state if available."""
        if self._previous_state is not None:
            self.state = self._previous_state
            self._previous_state = None

    def _setup_execution_environment(self, input_data: Dict) -> Dict:
        """Create a secure execution environment for the contract.
        
        Sets up a restricted namespace with only safe operations allowed.
        Provides access to contract state and metadata while preventing
        access to system resources.
        """
        return {
            "input": input_data,
            "state": self.state,
            "contract_id": self.contract_id,
            "creator": self.creator,
            "version": self.version,
            "metadata": self.metadata.copy(),
            "__builtins__": self.SAFE_BUILTINS,
        }

    def _update_execution_metrics(self, execution_start: float) -> None:
        """Update all execution metrics after successful execution.
        
        Updates:
        - Execution count and history
        - Mana consumption
        - Timing information
        - State size tracking
        """
        self.last_executed = datetime.now()
        self.execution_count += 1
        self.daily_executions += 1
        self.total_mana_consumed += self.mana_cost

        execution_record = {
            "timestamp": self.last_executed,
            "execution_time": time.time() - execution_start,
            "mana_used": self.mana_cost,
            "state_size": len(str(self.state)),
        }

        self.execution_history.append(execution_record)
        if len(self.execution_history) > 1000:
            self.execution_history = self.execution_history[-1000:]

    def _reset_daily_executions(self) -> None:
        """Reset daily execution counter if a day has passed."""
        current_time = datetime.now()
        if (current_time - self.last_reset).days >= 1:
            self.daily_executions = 0
            self.last_reset = current_time

    def authorize_caller(self, caller_id: str) -> bool:
        """Add a new authorized caller for the contract."""
        self.allowed_callers.add(caller_id)
        return True

    def revoke_caller(self, caller_id: str) -> bool:
        """Revoke a caller's authorization (except creator)."""
        if caller_id == self.creator:
            return False
        self.allowed_callers.discard(caller_id)
        return True

    def update_restrictions(self, new_restrictions: Dict) -> bool:
        """Update contract restrictions if valid."""
        try:
            if not all(k in self.restrictions for k in new_restrictions):
                return False
            self.restrictions.update(new_restrictions)
            self.metadata["last_updated"] = datetime.now()
            return True
        except Exception as e:
            logger.error(f"Failed to update restrictions: {str(e)}")
            return False

    def get_metrics(self) -> Dict:
        """Get comprehensive contract metrics."""
        return {
            "contract_id": self.contract_id,
            "version": self.version,
            "creator": self.creator,
            "created_at": self.created_at.isoformat(),
            "last_executed": (
                self.last_executed.isoformat() if self.last_executed else None
            ),
            "execution_count": self.execution_count,
            "daily_executions": self.daily_executions,
            "total_mana_consumed": self.total_mana_consumed,
            "average_mana_per_execution": (
                self.total_mana_consumed / self.execution_count
                if self.execution_count > 0
                else 0
            ),
            "state_size": len(str(self.state)),
            "dependencies": list(self.dependencies),
            "authorized_callers": len(self.allowed_callers),
            "restrictions": self.restrictions,
        }

    def to_dict(self) -> Dict:
        """Convert contract to dictionary representation."""
        return {
            "contract_id": self.contract_id,
            "code": self.code,
            "creator": self.creator,
            "state": self.state,
            "mana_cost": self.mana_cost,
            "version": self.version,
            "metadata": {
                **self.metadata,
                "created_at": self.metadata["created_at"].isoformat(),
                "last_updated": self.metadata["last_updated"].isoformat(),
                "tags": list(self.metadata["tags"]),
            },
            "dependencies": list(self.dependencies),
            "allowed_callers": list(self.allowed_callers),
            "restrictions": self.restrictions,
            "metrics": self.get_metrics(),
        }

    @classmethod
    def from_dict(cls, data: Dict) -> "SmartContract":
        """Create contract instance from dictionary data."""
        contract = cls(
            contract_id=data["contract_id"],
            code=data["code"],
            creator=data["creator"],
            mana_cost=data["mana_cost"],
            version=data["version"],
        )

        contract.state = data["state"]
        contract.metadata = {
            **data["metadata"],
            "created_at": datetime.fromisoformat(data["metadata"]["created_at"]),
            "last_updated": datetime.fromisoformat(data["metadata"]["last_updated"]),
            "tags": set(data["metadata"]["tags"]),
        }
        contract.dependencies = set(data["dependencies"])
        contract.allowed_callers = set(data["allowed_callers"])
        contract.restrictions = data["restrictions"]

        return contract

    def __str__(self) -> str:
        """Human-readable string representation."""
        return (
            f"Contract(id={self.contract_id}, "
            f"creator={self.creator}, "
            f"executions={self.execution_count}, "
            f"mana_cost={self.mana_cost})"
        )

# ==================== /home/matt/icn-prototype/blockchain/contracts/__init__.py ====================

# blockchain/contracts/__init__.py
"""Smart contract components."""
from .smart_contract import SmartContract
from .contract_executor import ContractExecutor

__all__ = ["SmartContract", "ContractExecutor"]


# ==================== /home/matt/icn-prototype/blockchain/consensus/proof_of_cooperation.py ====================

# ================================================================
# File: blockchain/consensus/proof_of_cooperation.py
# Description: Implements the Proof of Cooperation (PoC) consensus
# mechanism for the ICN blockchain. PoC incentivizes cooperative behavior,
# resource contribution, and equitable participation.
# ================================================================

from __future__ import annotations
from typing import Dict, List, Optional, Tuple, Set, Any
from datetime import datetime, timedelta
import math
import random
import logging
from ..core.node import Node
from ..core.block import Block

logger = logging.getLogger(__name__)

class ProofOfCooperation:
    """
    Implements the Proof of Cooperation consensus mechanism for the ICN.

    Key improvements:
    - Progressive reputation requirements for new nodes
    - Dynamic scoring adjustments
    - Enhanced collusion detection
    - Improved validation mechanics
    - Better shard-specific handling
    """

    def __init__(self, min_reputation: float = 10.0, cooldown_blocks: int = 3):
        """
        Initialize the Proof of Cooperation mechanism.
        
        Parameters:
        - min_reputation: Minimum reputation required to participate.
        - cooldown_blocks: Number of blocks for the cooldown period after validation.
        """
        # Core parameters
        self.min_reputation = min_reputation
        self.cooldown_blocks = cooldown_blocks
        
        # Reputation category weights
        self.reputation_weights = {
            "cooperative_growth": 1.5,
            "proposal_participation": 1.2,
            "transaction_validation": 1.3,  # Increased importance
            "resource_sharing": 1.3,
            "conflict_resolution": 1.1,
            "community_building": 1.2,
            "sustainability": 1.2,
            "innovation": 1.3,
            "network_stability": 1.4,  # Increased importance
            "data_availability": 1.2,
        }
        
        # Validation thresholds with progressive scaling
        self.validation_thresholds = {
            "min_participation": 0.05,    # Lowered initial barrier
            "min_success_rate": 0.4,      # More forgiving for new nodes
            "min_availability": 0.6,      # Adjusted for better accessibility
            "max_consecutive_validations": 3,
            "new_node_reputation_factor": 0.3,  # More lenient for new nodes
            "min_interactions": 3,         # Minimum required interactions
        }
        
        # System parameters
        self.cooperation_scores: Dict[str, float] = {}
        self.reputation_decay_factor = 0.95  # Slower decay
        self.collusion_threshold = 0.75
        self.validator_history: List[Tuple[str, datetime, int]] = []
        self.validation_stats: Dict[str, Dict[str, Any]] = {}
        
        # Performance tracking
        self.performance_metrics = {
            "average_block_time": 0.0,
            "total_validations": 0,
            "successful_validations": 0,
            "collusion_detections": 0,
            "failed_validations": 0,
            "total_blocks_validated": 0,
            "new_node_participations": 0,
        }

    def _can_participate(self, node: Node, shard_id: Optional[int] = None) -> bool:
        """
        Determine if a node can participate in consensus with progressive requirements.
        
        Parameters:
        - node: Node to be checked for participation eligibility.
        - shard_id: Optional shard ID for shard-specific checks.
        
        Returns:
        - bool: True if node can participate, False otherwise.
        """
        try:
            # Basic validation check
            if not node.can_validate(shard_id):
                return False

            # Get base reputation requirement
            is_new_node = node.total_validations < 10
            base_requirement = (
                self.min_reputation * self.validation_thresholds["new_node_reputation_factor"]
                if is_new_node else
                self.min_reputation
            )
            
            # Apply progressive scaling based on participation history
            if node.total_validations > 0:
                success_rate = self._calculate_success_rate(node)
                if success_rate > 0.8:
                    base_requirement *= 0.8  # Reward consistent good performance
            
            # Check reputation threshold
            total_reputation = node.get_total_reputation()
            if total_reputation < base_requirement:
                return False

            # Verify shard assignment if specified
            if shard_id is not None:
                if shard_id not in node.active_shards:
                    return False
                # Check shard-specific performance
                if not self._check_shard_performance(node, shard_id):
                    return False

            # Additional checks for established nodes
            if not is_new_node:
                if len(node.cooperative_interactions) < self.validation_thresholds["min_interactions"]:
                    return False
                    
            return True

        except Exception as e:
            logger.error(f"Error in participation check: {e}")
            return False

    def _check_shard_performance(self, node: Node, shard_id: int) -> bool:
        """
        Verify node's performance in specific shard.
        
        Parameters:
        - node: Node to be checked for shard performance.
        - shard_id: ID of the shard for performance check.
        
        Returns:
        - bool: True if shard performance is acceptable, False otherwise.
        """
        try:
            stats = self.validation_stats.get(node.node_id, {})
            shard_stats = stats.get("shard_validations", {}).get(shard_id, {})
            
            if not shard_stats:
                return True  # New to this shard
                
            selections = shard_stats.get("selections", 0)
            if selections == 0:
                return True
                
            success_rate = shard_stats.get("successful", 0) / max(1, selections)
            return success_rate >= self.validation_thresholds["min_success_rate"]
            
        except Exception as e:
            logger.error(f"Error checking shard performance: {e}")
            return True  # Fail open for new nodes

    def calculate_cooperation_score(self, node: Node, shard_id: Optional[int] = None) -> float:
        """
        Calculate node's cooperation score with dynamic adjustments.
        
        Parameters:
        - node: Node whose cooperation score is being calculated.
        - shard_id: Optional shard ID for shard-specific adjustments.
        
        Returns:
        - float: Calculated cooperation score.
        """
        try:
            if not self._can_participate(node, shard_id):
                return 0.0

            # Calculate base reputation score
            base_score = sum(
                score * self.reputation_weights.get(category, 1.0)
                for category, score in node.reputation_scores.items()
            )

            # Calculate and apply modifying factors
            factors = [
                self._calculate_diversity_factor(node),
                self._calculate_consistency_factor(node),
                self._calculate_performance_factor(node)
            ]
            
            if shard_id is not None:
                factors.append(self._calculate_shard_factor(node, shard_id))

            # Combine all factors
            final_score = base_score
            for factor in factors:
                final_score *= factor

            # Apply time decay
            time_factor = self._calculate_time_decay(node)
            final_score *= time_factor

            return max(0.0, final_score)

        except Exception as e:
            logger.error(f"Error calculating cooperation score: {e}")
            return 0.0

    def _calculate_diversity_factor(self, node: Node) -> float:
        """
        Calculate diversity factor with improved scaling.
        
        Parameters:
        - node: Node whose diversity factor is being calculated.
        
        Returns:
        - float: Calculated diversity factor.
        """
        try:
            recent_interactions = node.cooperative_interactions[-100:]
            if not recent_interactions:
                return 1.0

            unique_coops = len(set(recent_interactions))
            total_interactions = len(recent_interactions)
            
            # Base diversity score
            diversity_score = unique_coops / total_interactions
            
            # Progressive scaling based on interaction count
            if total_interactions >= 20:
                if unique_coops >= 5:
                    return 1.0 + math.log(1 + diversity_score) * 1.5
                return 1.0 + math.log(1 + diversity_score)
            
            return max(0.7, diversity_score)  # Minimum baseline for new nodes

        except Exception as e:
            logger.error(f"Error calculating diversity factor: {e}")
            return 0.7

    def _calculate_consistency_factor(self, node: Node) -> float:
        """
        Calculate consistency factor with adaptive thresholds.
        
        Parameters:
        - node: Node whose consistency factor is being calculated.
        
        Returns:
        - float: Calculated consistency factor.
        """
        try:
            if not node.validation_history:
                return 1.0

            recent_validations = node.validation_history[-50:]
            successful = sum(1 for v in recent_validations 
                             if v.get("evidence", {}).get("success", False))
            
            success_rate = successful / len(recent_validations)
            
            # Progressive scaling based on experience
            if node.total_validations < 10:
                min_rate = self.validation_thresholds["min_success_rate"] * 0.8
            else:
                min_rate = self.validation_thresholds["min_success_rate"]
            
            if success_rate > 0.95:  # Exceptional performance
                return 1.8
            elif success_rate > 0.8:  # Strong performance
                return 1.5
            elif success_rate > min_rate:
                return 1.0 + ((success_rate - min_rate) / (1 - min_rate))
                
            return max(0.5, success_rate / min_rate)

        except Exception as e:
            logger.error(f"Error calculating consistency factor: {e}")
            return 0.5

    def _calculate_performance_factor(self, node: Node) -> float:
        """
        Calculate performance factor with weighted metrics.
        
        Parameters:
        - node: Node whose performance factor is being calculated.
        
        Returns:
        - float: Calculated performance factor.
        """
        try:
            metrics = node.performance_metrics
            if not metrics:
                return 1.0

            # Weighted performance metrics
            weights = {
                "availability": 0.35,
                "validation_success_rate": 0.35,
                "network_reliability": 0.3
            }
            
            weighted_sum = sum(
                (metrics.get(metric, 0) / 100) * weight
                for metric, weight in weights.items()
            )
            
            # Apply bonuses for exceptional performance
            if weighted_sum > 0.95:
                return weighted_sum * 1.2
            elif weighted_sum > 0.9:
                return weighted_sum * 1.1
                
            return max(self.validation_thresholds["min_availability"], weighted_sum)

        except Exception as e:
            logger.error(f"Error calculating performance factor: {e}")
            return self.validation_thresholds["min_availability"]

    def _calculate_shard_factor(self, node: Node, shard_id: int) -> float:
        """
        Calculate shard-specific factor with experience weighting.
        
        Parameters:
        - node: Node whose shard factor is being calculated.
        - shard_id: ID of the shard for factor calculation.
        
        Returns:
        - float: Calculated shard factor.
        """
        try:
            if shard_id not in node.active_shards:
                return 0.0

            # Time-based experience
            time_in_shard = (datetime.now() - node.active_shards[shard_id]).total_seconds()
            experience = min(1.0, time_in_shard / (24 * 3600))
            
            # Success rate in shard
            stats = self.validation_stats.get(node.node_id, {})
            shard_stats = stats.get("shard_validations", {}).get(shard_id, {})
            
            if shard_stats:
                success_rate = (
                    shard_stats.get("successful", 0) /
                    max(1, shard_stats.get("selections", 1))
                )
            else:
                success_rate = 1.0  # New to shard
            
            # Combine factors with progressive weighting
            if experience < 0.2:  # New to shard
                return 0.7 + (0.3 * success_rate)
            else:
                return 0.4 + (0.3 * experience) + (0.3 * success_rate)

        except Exception as e:
            logger.error(f"Error calculating shard factor: {e}")
            return 0.5

    def _calculate_time_decay(self, node: Node) -> float:
        """
        Calculate time-based decay factor.
        
        Parameters:
        - node: Node whose time decay factor is being calculated.
        
        Returns:
        - float: Calculated time decay factor.
        """
        try:
            last_active = self._get_time_since_last_validation(node)
            if last_active > timedelta(hours=24):
                hours_inactive = last_active.total_seconds() / 3600
                return math.exp(-hours_inactive / 24)
            return 1.0
        except Exception as e:
            logger.error(f"Error calculating time decay: {e}")
            return 1.0

    def _get_time_since_last_validation(self, node: Node) -> timedelta:
        """
        Get time since node's last validation.
        
        Parameters:
        - node: Node to check last validation time.
        
        Returns:
        - timedelta: Time since last validation.
        """
        stats = self.validation_stats.get(node.node_id, {})
        last_validation = stats.get("last_validation")
        if not last_validation:
            return timedelta(hours=1)  # Default for new nodes
        return datetime.now() - last_validation

    def select_validator(self, nodes: List[Node], shard_id: Optional[int] = None) -> Optional[Node]:
        """
        Select validator using weighted random selection with safeguards.
        
        Parameters:
        - nodes: List of potential validator nodes.
        - shard_id: Optional shard ID for selection.
        
        Returns:
        - Optional[Node]: Selected validator node, if any.
        """
        try:
            # Get eligible nodes
            eligible_nodes = [
                node for node in nodes
                if self._can_participate(node, shard_id)
            ]

            if not eligible_nodes:
                # Special handling for new network state
                new_nodes = [
                    node for node in nodes
                    if node.total_validations == 0 and node.cooldown == 0
                ]
                if new_nodes:
                    selected = random.choice(new_nodes)
                    self._record_validator_selection(selected, shard_id)
                    return selected
                return None

            # Calculate scores
            scores = [
                self.calculate_cooperation_score(node, shard_id)
                for node in eligible_nodes
            ]
            total_score = sum(scores)

            if total_score <= 0:
                return None

            # Weighted random selection
            selection_point = random.uniform(0, total_score)
            current_sum = 0
            selected = None

            for node, score in zip(eligible_nodes, scores):
                current_sum += score
                if current_sum >= selection_point:
                    selected = node
                    break

            if selected:
                self._record_validator_selection(selected, shard_id)
                selected.enter_cooldown(self.cooldown_blocks)

            return selected

        except Exception as e:
            logger.error(f"Error selecting validator: {e}")
            return None

    def validate_block(self, block: Block, previous_block: Optional[Block], validator: Node) -> bool:
        """
        Validate block with comprehensive checks.
        
        Parameters:
        - block: The block to be validated.
        - previous_block: The previous block in the chain.
        - validator: The node validating the block.
        
        Returns:
        - bool: True if the block is valid, False otherwise.
        """
        try:
            # Eligibility check
            if not self._can_validate_block(validator, block.shard_id):
                logger.error(f"Validator {validator.node_id} not eligible")
                return False

            # Block integrity check
            if not block.validate(previous_block):
                logger.error(f"Block {block.index} failed validation")
                self._update_validation_stats(validator, block, False)
                return False

            # Collusion check
            if self.detect_collusion(validator, block):
                logger.warning(f"Collusion detected in block {block.index}")
                self._update_validation_stats(validator, block, False)
                return False

            # Success case
            self._update_validation_stats(validator, block, True)
            logger.info(f"Block {block.index} validated successfully")
            return True

        except Exception as e:
            logger.error(f"Error validating block: {e}")
            self._update_validation_stats(validator, block, False)
            return False

    def _can_validate_block(self, validator: Node, shard_id: Optional[int]) -> bool:
        """
        Check if validator can validate a specific block.
        
        Parameters:
        - validator: The node attempting to validate the block.
        - shard_id: Optional shard ID for validation.
        
        Returns:
        - bool: True if the validator can validate, False otherwise.
        """
        try:
            # New node allowance
            if validator.total_validations < 5:
                if validator.can_validate(shard_id):
                    return True
                return False

            # Standard validation checks
            if not validator.can_validate(shard_id):
                return False

            # Reputation threshold with experience-based scaling
            total_reputation = validator.get_total_reputation()
            reputation_requirement = self.min_reputation
            
            if validator.total_validations > 20:
                # Increase requirements for experienced validators
                reputation_requirement *= 1.2
            elif validator.total_validations > 10:
                reputation_requirement *= 1.0
            else:
                # Reduce requirements for newer validators
                reputation_requirement *= 0.7

            if total_reputation < reputation_requirement:
                return False

            # Check recent performance
            stats = self.validation_stats.get(validator.node_id, {})
            recent_success = stats.get("successful_validations", 0) / max(1, stats.get("selections", 1))
            
            if recent_success < self.validation_thresholds["min_success_rate"]:
                if validator.total_validations > 10:  # Only apply to experienced validators
                    return False

            return True

        except Exception as e:
            logger.error(f"Error checking block validation eligibility: {e}")
            return False

    def detect_collusion(self, validator: Node, block: Block) -> bool:
        """
        Detect collusion patterns in transactions.
        
        Parameters:
        - validator: The node attempting to validate the block.
        - block: The block being validated.
        
        Returns:
        - bool: True if collusion is detected, False otherwise.
        """
        try:
            if len(block.transactions) < 3:
                return False

            # Track transaction patterns
            sender_counts: Dict[str, int] = {}
            receiver_counts: Dict[str, int] = {}
            address_interactions: Dict[str, Set[str]] = {}
            
            # Analyze transaction patterns
            total_transactions = len(block.transactions)
            for tx in block.transactions:
                # Update counts
                sender_counts[tx.sender] = sender_counts.get(tx.sender, 0) + 1
                receiver_counts[tx.receiver] = receiver_counts.get(tx.receiver, 0) + 1
                
                # Track interactions
                if tx.sender not in address_interactions:
                    address_interactions[tx.sender] = set()
                address_interactions[tx.sender].add(tx.receiver)

            # Calculate concentration metrics
            max_sender_concentration = max(sender_counts.values()) / total_transactions
            max_receiver_concentration = max(receiver_counts.values()) / total_transactions
            
            # Dynamic threshold based on block size
            threshold = self.collusion_threshold
            if total_transactions > 10:
                threshold *= 0.9  # Stricter for larger blocks
            elif total_transactions > 20:
                threshold *= 0.85  # Even stricter for very large blocks
            
            # Check for suspicious patterns
            if max_sender_concentration > threshold or max_receiver_concentration > threshold:
                logger.warning(
                    f"High concentration detected - Sender: {max_sender_concentration:.2f}, "
                    f"Receiver: {max_receiver_concentration:.2f}"
                )
                return True
                
            # Check for circular transaction patterns
            for address, interactions in address_interactions.items():
                if len(interactions) > 2:  # Only check addresses with multiple interactions
                    for receiver in interactions:
                        if receiver in address_interactions and address in address_interactions[receiver]:
                            logger.warning(f"Circular transaction pattern detected involving {address}")
                            return True

            return False

        except Exception as e:
            logger.error(f"Error detecting collusion: {e}")
            return False

    def _update_validation_stats(self, validator: Node, block: Block, success: bool) -> None:
        """
        Update validation statistics comprehensively.
        
        Parameters:
        - validator: The node that validated the block.
        - block: The block that was validated.
        - success: Whether the validation was successful.
        """
        try:
            if validator.node_id not in self.validation_stats:
                self.validation_stats[validator.node_id] = {
                    "selections": 0,
                    "successful_validations": 0,
                    "last_validation": None,
                    "shard_validations": {},
                    "consecutive_failures": 0
                }

            stats = self.validation_stats[validator.node_id]
            
            # Update general stats
            stats["selections"] += 1
            if success:
                stats["successful_validations"] += 1
                stats["consecutive_failures"] = 0
            else:
                stats["consecutive_failures"] += 1
                
            stats["last_validation"] = datetime.now()

            # Update shard-specific stats
            if block.shard_id is not None:
                shard_stats = stats["shard_validations"].setdefault(
                    block.shard_id, {
                        "selections": 0,
                        "successful": 0,
                        "last_validation": None,
                        "failure_count": 0
                    }
                )
                shard_stats["selections"] += 1
                if success:
                    shard_stats["successful"] += 1
                else:
                    shard_stats["failure_count"] += 1
                shard_stats["last_validation"] = datetime.now()

            # Update performance metrics
            self.performance_metrics["total_validations"] += 1
            if success:
                self.performance_metrics["successful_validations"] += 1
            else:
                self.performance_metrics["failed_validations"] += 1

            # Track new node participation
            if validator.total_validations < 10:
                self.performance_metrics["new_node_participations"] += 1

        except Exception as e:
            logger.error(f"Error updating validation stats: {e}")

    def get_metrics(self) -> Dict:
        """
        Get comprehensive consensus metrics.
        
        Returns:
        - Dict: A dictionary of consensus metrics.
        """
        try:
            total_validations = self.performance_metrics["total_validations"]
            if total_validations > 0:
                success_rate = (
                    self.performance_metrics["successful_validations"] / total_validations
                )
                avg_score = sum(self.cooperation_scores.values()) / len(self.cooperation_scores) if self.cooperation_scores else 0
            else:
                success_rate = 0
                avg_score = 0
            
            return {
                "active_validators": len(self.validation_stats),
                "total_validations": total_validations,
                "successful_validations": self.performance_metrics["successful_validations"],
                "success_rate": success_rate,
                "average_block_time": self.performance_metrics["average_block_time"],
                "collusion_detections": self.performance_metrics["collusion_detections"],
                "failed_validations": self.performance_metrics["failed_validations"],
                "total_blocks_validated": self.performance_metrics["total_blocks_validated"],
                "new_node_participations": self.performance_metrics["new_node_participations"],
                "average_cooperation_score": avg_score,
                "total_active_nodes": len([
                    node_id for node_id, stats in self.validation_stats.items()
                    if datetime.now() - stats["last_validation"] < timedelta(hours=24)
                    if stats["last_validation"]
                ])
            }
            
        except Exception as e:
            logger.error(f"Error getting metrics: {e}")
            return {}


# ==================== /home/matt/icn-prototype/blockchain/consensus/__init__.py ====================

# blockchain/consensus/__init__.py
"""Consensus mechanism components."""
from .proof_of_cooperation import ProofOfCooperation

__all__ = ["ProofOfCooperation"]