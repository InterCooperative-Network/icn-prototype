# Project Directory Structure (up to depth 2):
icn-prototype/
    requirements.txt
    concatenate_code_files.py
    setup.py
    did/
        did.py
        __init__.py
    .pytest_cache/
        CACHEDIR.TAG
        .gitignore
        README.md
        v/
    icn_env/
        pyvenv.cfg
        bin/
            pip
            activate
            flake8
            python3
            activate.csh
            black
            normalizer
            python
            pip3.12
            pycodestyle
            pytest
            Activate.ps1
            blackd
            pip3
            py.test
            activate.fish
            flask
            python3.12
            pyflakes
        include/
        lib/
    api/
        server.py
        __init__.py
    tests/
        test_governance.py
        test_all.py
        test_blockchain.py
    system/
        marketplace.py
        reputation.py
        governance.py
        storage.py
        __init__.py
    blockchain/
        blockchain.py
        blockchain.py.backup
        __init__.py
        utils/
            metrics.py
            validation.py
            __init__.py
            crypto.py
        core/
            node.py
            block.py
            transaction.py
            shard.py
            blockchain.py
            __init__.py
        contracts/
            contract_executor.py
            smart_contract.py
            __init__.py
        consensus/
            proof_of_cooperation.py
            __init__.py
    .git/
        COMMIT_EDITMSG
        config
        HEAD
        index
        description
        objects/
        refs/
        branches/
        hooks/
            prepare-commit-msg.sample
            sendemail-validate.sample
            update.sample
            pre-rebase.sample
            pre-receive.sample
            pre-commit.sample
            push-to-checkout.sample
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-push.sample
            pre-merge-commit.sample
            pre-applypatch.sample
        logs/
            HEAD
        info/
            exclude


# Code Files Concatenation:



# ==================== /home/matt/icn-prototype/concatenate_code_files.py ====================

import os


def tree_structure(startpath, max_depth=2):
    tree_str = ""
    start_depth = startpath.rstrip(os.path.sep).count(os.path.sep)
    for root, dirs, files in os.walk(startpath):
        depth = root.count(os.path.sep) - start_depth
        if depth > max_depth:
            continue
        indent = " " * 4 * depth
        tree_str += f"{indent}{os.path.basename(root)}/\n"
        sub_indent = " " * 4 * (depth + 1)
        for file in files:
            tree_str += f"{sub_indent}{file}\n"
    return tree_str


def concatenate_code_files(source_dir, output_file, extensions=None, max_depth=2):
    if extensions is None:
        extensions = [".py", ".rs", ".js", ".ts", ".c"]  # Only most relevant extensions

    # Generate the tree structure
    tree_str = tree_structure(source_dir, max_depth=max_depth)

    with open(output_file, "w", encoding="utf-8") as outfile:
        outfile.write(
            "# Project Directory Structure (up to depth {}):\n".format(max_depth)
        )
        outfile.write(tree_str)
        outfile.write("\n\n# Code Files Concatenation:\n\n")

        # Walk through the directory to find and concatenate code files
        for root, dirs, files in os.walk(source_dir):
            # Exclude temp and irrelevant directories, including 'icn_env'
            dirs[:] = [
                d
                for d in dirs
                if d
                not in [
                    "__pycache__",
                    ".git",
                    "node_modules",
                    "build",
                    "dist",
                    "venv",
                    ".idea",
                    "icn_env",
                ]
            ]

            for file in files:
                file_path = os.path.join(root, file)

                # Skip non-relevant extensions
                if not any(file.endswith(ext) for ext in extensions):
                    continue

                try:
                    # Skip files larger than 50 KB
                    if os.path.getsize(file_path) > 50 * 1024:
                        continue

                    # Check for binary content
                    with open(file_path, "rb") as binary_check:
                        if b"\0" in binary_check.read(1024):
                            continue

                    with open(
                        file_path, "r", encoding="utf-8", errors="ignore"
                    ) as infile:
                        outfile.write(f"\n\n# {'='*20} {file_path} {'='*20}\n\n")
                        outfile.write(infile.read())
                except Exception as e:
                    print(f"Error reading {file_path}: {e}")

    print(f"Concatenation complete! Check the output file: {output_file}")


# Example usage
concatenate_code_files("/home/matt/icn-prototype", "ICN_code_dump.txt", max_depth=2)


# ==================== /home/matt/icn-prototype/setup.py ====================

# setup.py

from setuptools import setup, find_packages

setup(
    name="icn-prototype",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        'pycryptodome',         # for cryptographic operations
        'cryptography',         # for additional crypto functionality
        'flask',               # for the API
        'flask-jwt-extended',  # for JWT auth
        'werkzeug',           # for utilities
        'pytest',             # for testing
    ],
    python_requires='>=3.8',
)

# ==================== /home/matt/icn-prototype/did/did.py ====================

# did/did.py
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Dict, List, Optional
import logging
from datetime import datetime
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)


@dataclass
class Credential:
    """Verifiable credential for the ICN system."""

    issuer: str
    subject: str
    claims: Dict
    issued_at: datetime = field(default_factory=datetime.now)
    expires_at: Optional[datetime] = None
    proof: Optional[Dict] = None

    def verify(self) -> bool:
        """Verify the credential's cryptographic proof."""
        if not self.proof:
            return False
        # Implement cryptographic verification
        return True

    def revoke(self) -> None:
        """Revoke the credential."""
        self.expires_at = datetime.now()


class IdentityProvider(ABC):
    """Abstract base class for identity providers."""

    @abstractmethod
    def issue_credential(self, subject: str, claims: Dict) -> Credential:
        pass

    @abstractmethod
    def verify_credential(self, credential: Credential) -> bool:
        pass


class DID:
    """Decentralized Identifier implementation for ICN."""

    def __init__(self, cooperative_id: Optional[str] = None):
        self._private_key = rsa.generate_private_key(
            public_exponent=65537, key_size=2048
        )
        self._public_key = self._private_key.public_key()
        self.cooperative_memberships: List[str] = []
        self.reputation_scores: Dict[str, float] = {}
        self.credentials: List[Credential] = []
        self.metadata: Dict = {}
        if cooperative_id:
            self.add_cooperative_membership(cooperative_id)

        # Create encryption key for sensitive data
        self._encryption_key = Fernet.generate_key()
        self._cipher_suite = Fernet(self._encryption_key)

    def generate_did(self) -> str:
        """Generate the DID string."""
        pub_bytes = self._public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        return f"did:icn:{hashlib.sha256(pub_bytes).hexdigest()[:16]}"

    def encrypt_data(self, data: str) -> bytes:
        """Encrypt data using the public key."""
        try:
            return self._public_key.encrypt(
                data.encode(),
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None,
                ),
            )
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            raise

    def decrypt_data(self, encrypted_data: bytes) -> str:
        """Decrypt data using the private key."""
        try:
            decrypted = self._private_key.decrypt(
                encrypted_data,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None,
                ),
            )
            return decrypted.decode()
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise

    def add_cooperative_membership(self, cooperative_id: str) -> None:
        """Add membership to a cooperative."""
        if cooperative_id not in self.cooperative_memberships:
            self.cooperative_memberships.append(cooperative_id)
            logger.info(f"Added membership to cooperative: {cooperative_id}")

    def update_reputation(
        self, category: str, score: float, evidence: Optional[Dict] = None
    ) -> None:
        """Update reputation score with optional evidence."""
        if score < 0:
            logger.warning(f"Negative reputation score update: {score}")

        old_score = self.reputation_scores.get(category, 0)
        self.reputation_scores[category] = old_score + score

        if evidence:
            if "reputation_evidence" not in self.metadata:
                self.metadata["reputation_evidence"] = {}
            self.metadata["reputation_evidence"][category] = evidence

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def export_public_credentials(self) -> Dict:
        """Export public credentials and memberships."""
        return {
            "did": self.generate_did(),
            "cooperative_memberships": self.cooperative_memberships,
            "reputation_scores": self.reputation_scores,
            "public_credentials": [
                {k: v for k, v in c.__dict__.items() if k != "proof"}
                for c in self.credentials
            ],
        }


class DIDRegistry:
    """Registry for DIDs in the ICN system."""

    def __init__(self):
        self.dids: Dict[str, DID] = {}
        self.revoked_dids: Dict[str, datetime] = {}
        self._identity_providers: Dict[str, IdentityProvider] = {}

    def register_did(self, did: DID) -> str:
        """Register a new DID."""
        did_id = did.generate_did()
        if did_id in self.revoked_dids:
            raise ValueError(f"DID {did_id} has been revoked")
        self.dids[did_id] = did
        logger.info(f"Registered new DID: {did_id}")
        return did_id

    def resolve_did(self, did_id: str) -> Optional[DID]:
        """Resolve a DID to its full object."""
        if did_id in self.revoked_dids:
            logger.warning(f"Attempted to resolve revoked DID: {did_id}")
            return None
        return self.dids.get(did_id)

    def verify_did(self, did_id: str) -> bool:
        """Verify a DID's validity."""
        if did_id in self.revoked_dids:
            return False
        return did_id in self.dids

    def revoke_did(self, did_id: str, reason: str) -> None:
        """Revoke a DID."""
        if did_id in self.dids:
            self.revoked_dids[did_id] = datetime.now()
            del self.dids[did_id]
            logger.warning(f"DID revoked: {did_id}, reason: {reason}")

    def register_identity_provider(self, name: str, provider: IdentityProvider) -> None:
        """Register a new identity provider."""
        self._identity_providers[name] = provider
        logger.info(f"Registered identity provider: {name}")

    def get_identity_provider(self, name: str) -> Optional[IdentityProvider]:
        """Get an identity provider by name."""
        return self._identity_providers.get(name)


# ==================== /home/matt/icn-prototype/did/__init__.py ====================



# ==================== /home/matt/icn-prototype/api/server.py ====================

import sys
import os

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


from flask import Flask, request, jsonify
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from werkzeug.security import generate_password_hash, check_password_hash
from functools import wraps
from blockchain.blockchain import Blockchain
from did.did import DID, DIDRegistry
from system.governance import Governance, Proposal
from system.marketplace import Marketplace
from system.storage import DistributedStorage

app = Flask(__name__)
app.config["JWT_SECRET_KEY"] = "your_jwt_secret_key"  # Replace with a secure key
jwt = JWTManager(app)

blockchain = Blockchain()
did_registry = DIDRegistry()
governance = Governance(blockchain)
marketplace = Marketplace(blockchain, did_registry)
storage = DistributedStorage(blockchain)

users_db = {}


def role_required(required_role):
    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            current_user = get_jwt_identity()
            if current_user["role"] != required_role:
                return jsonify({"message": "Access forbidden: insufficient role"}), 403
            return f(*args, **kwargs)

        return wrapper

    return decorator


@app.route("/register", methods=["POST"])
def register():
    username = request.json.get("username")
    password = request.json.get("password")
    role = request.json.get("role", "user")

    if username in users_db:
        return jsonify({"message": "User already exists"}), 400

    did = DID()
    did_id = did_registry.register_did(did)

    hashed_password = generate_password_hash(password)
    users_db[username] = {"password": hashed_password, "role": role, "did": did_id}

    return (
        jsonify({"message": f"User {username} registered successfully", "did": did_id}),
        201,
    )


@app.route("/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")

    user = users_db.get(username)

    if not user or not check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid username or password"}), 401

    access_token = create_access_token(
        identity={"username": username, "role": user["role"], "did": user["did"]}
    )
    return jsonify(access_token=access_token), 200


@app.route("/create_proposal", methods=["POST"])
@jwt_required()
def create_proposal():
    current_user = get_jwt_identity()
    proposal_data = request.json
    proposal = Proposal(
        id=f"proposal_{len(governance.proposals) + 1}",
        title=proposal_data["title"],
        description=proposal_data["description"],
        creator=current_user["did"],
        proposal_type=proposal_data["type"],
        options=proposal_data.get("options"),
        amount=proposal_data.get("amount"),
        stages=proposal_data.get("stages"),
    )
    proposal_id = governance.create_proposal(proposal)
    return jsonify({"message": "Proposal created", "proposal_id": proposal_id}), 201


@app.route("/vote", methods=["POST"])
@jwt_required()
def vote():
    current_user = get_jwt_identity()
    proposal_id = request.json.get("proposal_id")
    vote = request.json.get("vote")
    voting_power = request.json.get("voting_power", 1)

    if governance.cast_vote(proposal_id, vote, current_user["did"], voting_power):
        return jsonify({"message": "Vote cast successfully"}), 200
    return jsonify({"message": "Failed to cast vote"}), 400


@app.route("/finalize_proposal", methods=["POST"])
@jwt_required()
@role_required("admin")
def finalize_proposal():
    proposal_id = request.json.get("proposal_id")

    if governance.finalize_proposal(proposal_id):
        return jsonify({"message": "Proposal finalized successfully"}), 200
    return jsonify({"message": "Failed to finalize proposal"}), 400


@app.route("/create_listing", methods=["POST"])
@jwt_required()
def create_listing():
    current_user = get_jwt_identity()
    listing_data = request.json
    listing_id = marketplace.create_listing(
        f"listing_{len(marketplace.listings) + 1}",
        current_user["did"],
        listing_data["item"],
        listing_data["price"],
    )
    if listing_id:
        return jsonify({"message": "Listing created", "listing_id": listing_id}), 201
    return jsonify({"message": "Failed to create listing"}), 400


@app.route("/place_order", methods=["POST"])
@jwt_required()
def place_order():
    current_user = get_jwt_identity()
    order_data = request.json
    order_id = f"order_{len(marketplace.orders) + 1}"
    if marketplace.place_order(order_id, current_user["did"], order_data["listing_id"]):
        return jsonify({"message": "Order placed", "order_id": order_id}), 201
    return jsonify({"message": "Failed to place order"}), 400


@app.route("/complete_order", methods=["POST"])
@jwt_required()
def complete_order():
    order_id = request.json.get("order_id")
    completed_order = marketplace.complete_order(order_id)
    if completed_order:
        return (
            jsonify({"message": "Order completed", "order": completed_order.__dict__}),
            200,
        )
    return jsonify({"message": "Failed to complete order"}), 400


@app.route("/store_file", methods=["POST"])
@jwt_required()
def store_file():
    file = request.files["file"]
    file_hash = storage.store_file(file.filename, file.read())
    return jsonify({"message": "File stored", "file_hash": file_hash}), 201


@app.route("/retrieve_file/<file_hash>", methods=["GET"])
@jwt_required()
def retrieve_file(file_hash):
    file_data = storage.retrieve_file(file_hash)
    if file_data:
        return file_data, 200
    return jsonify({"message": "File not found"}), 404


if __name__ == "__main__":
    app.run(debug=True)


# ==================== /home/matt/icn-prototype/api/__init__.py ====================



# ==================== /home/matt/icn-prototype/tests/test_governance.py ====================

# ==================== /home/matt/icn-prototype/tests/test_governance.py ====================

import unittest
from blockchain.blockchain import Blockchain
from system.governance import Governance, Proposal

class TestGovernance(unittest.TestCase):

    def setUp(self):
        """
        Set up a blockchain and governance instance for testing.
        """
        self.blockchain = Blockchain(num_shards=1)
        self.governance = Governance(self.blockchain, voting_power_cap=10)

    def test_create_proposal(self):
        """
        Test creating a proposal with the new voting options.
        """
        proposal = Proposal(
            id="prop1",
            title="Test Proposal",
            description="This is a test proposal.",
            creator="creator1",
            proposal_type="amendment"
        )
        proposal_id = self.governance.create_proposal(proposal, creator_reputation=5)
        self.assertEqual(proposal_id, "prop1")
        self.assertIn("prop1", self.governance.proposals)
        self.assertEqual(self.governance.proposals["prop1"].options, ["approve", "reject", "abstain"])

    def test_start_voting(self):
        """
        Test starting the voting process for a proposal.
        """
        proposal = Proposal(
            id="prop2",
            title="Budget Proposal",
            description="A proposal to allocate budget.",
            creator="creator2",
            proposal_type="budget",
            amount=1000
        )
        self.governance.create_proposal(proposal, creator_reputation=10)
        started = self.governance.start_voting("prop2")
        self.assertTrue(started)
        self.assertIn("prop2", self.governance.votes)
        self.assertEqual(self.governance.votes["prop2"], {"approve": 0, "reject": 0, "abstain": 0})

    def test_cast_vote_approve(self):
        """
        Test casting an 'approve' vote for a proposal.
        """
        proposal = Proposal(
            id="prop3",
            title="Amendment Proposal",
            description="Amend bylaws to include a new rule.",
            creator="creator3",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=7)
        self.governance.start_voting("prop3")
        vote_cast = self.governance.cast_vote("prop3", "approve", "voter1", voting_power=9)
        self.assertTrue(vote_cast)
        self.assertAlmostEqual(self.governance.votes["prop3"]["approve"], 3.0, places=1)  # sqrt(9) = 3

    def test_cast_vote_reject(self):
        """
        Test casting a 'reject' vote for a proposal.
        """
        proposal = Proposal(
            id="prop4",
            title="Reject Proposal Test",
            description="Testing reject votes.",
            creator="creator4",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=8)
        self.governance.start_voting("prop4")
        vote_cast = self.governance.cast_vote("prop4", "reject", "voter2", voting_power=4)
        self.assertTrue(vote_cast)
        self.assertAlmostEqual(self.governance.votes["prop4"]["reject"], 2.0, places=1)  # sqrt(4) = 2

    def test_cast_vote_abstain(self):
        """
        Test casting an 'abstain' vote for a proposal.
        """
        proposal = Proposal(
            id="prop5",
            title="Abstain Proposal Test",
            description="Testing abstain votes.",
            creator="creator5",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=9)
        self.governance.start_voting("prop5")
        vote_cast = self.governance.cast_vote("prop5", "abstain", "voter3", voting_power=16)
        self.assertTrue(vote_cast)
        # Expect ceiling-based integer square root calculation
        self.assertEqual(self.governance.votes["prop5"]["abstain"], 4)




    def test_finalize_approve(self):
        """
        Test finalizing a proposal that should be approved.
        """
        proposal = Proposal(
            id="prop6",
            title="Approve Finalization Test",
            description="Testing approval finalization.",
            creator="creator6",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=10)
        self.governance.start_voting("prop6")
        self.governance.cast_vote("prop6", "approve", "voter1", voting_power=9)
        self.governance.cast_vote("prop6", "reject", "voter2", voting_power=4)
        self.governance.cast_vote("prop6", "abstain", "voter3", voting_power=16)
        finalized = self.governance.finalize_proposal("prop6")
        self.assertTrue(finalized)
        self.assertEqual(self.governance.proposals["prop6"].status, "approved")

    def test_finalize_reject(self):
        """
        Test finalizing a proposal that should be rejected.
        """
        proposal = Proposal(
            id="prop7",
            title="Reject Finalization Test",
            description="Testing rejection finalization.",
            creator="creator7",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=10)
        self.governance.start_voting("prop7")
        self.governance.cast_vote("prop7", "approve", "voter1", voting_power=4)
        self.governance.cast_vote("prop7", "reject", "voter2", voting_power=9)
        self.governance.cast_vote("prop7", "abstain", "voter3", voting_power=16)
        finalized = self.governance.finalize_proposal("prop7")
        self.assertFalse(finalized)
        self.assertEqual(self.governance.proposals["prop7"].status, "rejected")

    def test_abstain_does_not_affect_outcome(self):
        """
        Test that abstain votes do not affect the approval or rejection of a proposal.
        """
        proposal = Proposal(
            id="prop8",
            title="Abstain Outcome Test",
            description="Testing that abstains do not impact outcome.",
            creator="creator8",
            proposal_type="amendment"
        )
        self.governance.create_proposal(proposal, creator_reputation=10)
        self.governance.start_voting("prop8")
        self.governance.cast_vote("prop8", "approve", "voter1", voting_power=9)
        self.governance.cast_vote("prop8", "abstain", "voter2", voting_power=16)
        finalized = self.governance.finalize_proposal("prop8")
        self.assertTrue(finalized)
        self.assertEqual(self.governance.proposals["prop8"].status, "approved")

if __name__ == "__main__":
    unittest.main()


# ==================== /home/matt/icn-prototype/tests/test_all.py ====================

# tests/test_all.py

import unittest
from datetime import datetime, timedelta
import time
from typing import List

# Import all components
from blockchain.blockchain import (
    Blockchain, Block, Transaction, Node, 
    ProofOfCooperation, SmartContract
)
from did.did import DID, DIDRegistry, Credential
from system.governance import Governance, Proposal
from system.marketplace import Marketplace
from system.reputation import ReputationSystem
from system.storage import DistributedStorage

class TestICNIntegration(unittest.TestCase):
    """Integration tests for the entire ICN system."""

    def setUp(self):
        """Set up test environment."""
        # Initialize core components
        self.blockchain = Blockchain()
        self.did_registry = DIDRegistry()
        self.reputation_system = ReputationSystem()
        
        # Initialize governance and marketplace
        self.governance = Governance(self.blockchain, self.reputation_system)
        self.marketplace = Marketplace(self.blockchain, self.did_registry)
        
        # Create test nodes
        self.nodes = self._create_test_nodes()
        for node in self.nodes:
            self.blockchain.add_node(node)
        
        # Create test DIDs
        self.dids = self._create_test_dids()
        
        # Initialize storage
        self.storage = DistributedStorage(self.blockchain)

    def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
        """Create test nodes with various configurations."""
        nodes = []
        for i in range(num_nodes):
            node = Node(
                node_id=f"node_{i}",
                cooperative_id=f"coop_{i % 2}"  # Distribute among two coops
            )
            # Add some initial reputation
            node.reputation_scores = {
                'validation': 10.0 + i,
                'proposal_creation': 5.0 + i,
                'voting': 7.0 + i,
                'resource_sharing': 6.0 + i,
                'cooperative_growth': 8.0 + i,
                'community_building': 9.0 + i,
                'conflict_resolution': 4.0 + i
            }
            nodes.append(node)
        return nodes

    def _create_test_dids(self, num_dids: int = 5) -> List[DID]:
        """Create test DIDs and register them."""
        dids = []
        for i in range(num_dids):
            did = DID()
            self.did_registry.register_did(did)
            did.update_reputation('validation', 10.0)
            dids.append(did)
        return dids

    def test_1_basic_blockchain_operations(self):
        """Test basic blockchain operations."""
        # Create and add transaction
        transaction = Transaction(
            sender=self.dids[0].generate_did(),
            receiver=self.dids[1].generate_did(),
            action="test_transfer",
            data={"amount": 100}
        )
        
        # Add transaction and create block
        self.assertTrue(self.blockchain.add_transaction(transaction))
        
        # Create new block
        block = self.blockchain.create_block()
        self.assertIsNotNone(block)
        
        # Add block to chain
        self.assertTrue(self.blockchain.add_block(block))
        self.assertEqual(self.blockchain.current_height, 2)  # Including genesis

    def test_2_consensus_mechanism(self):
        """Test Proof of Cooperation consensus."""
        # Test validator selection
        validator = self.blockchain.consensus.select_validator(self.nodes)
        self.assertIsNotNone(validator)
        
        # Verify validator cooldown
        self.assertGreater(validator.cooldown, 0)
        
        # Test cooperation score calculation
        score = self.blockchain.consensus.calculate_cooperation_score(validator)
        self.assertGreater(score, 0)

    def test_3_smart_contracts(self):
        """Test smart contract deployment and execution."""
        # Simple counter contract
        contract_code = """
def execute(input_data, state):
    if 'counter' not in state:
        state['counter'] = 0
    state['counter'] += 1
    return {'counter': state['counter']}
"""
        
        # Deploy contract
        self.assertTrue(self.blockchain.deploy_contract(
            "test_contract",
            contract_code,
            self.dids[0].generate_did()
        ))
        
        # Execute contract
        result = self.blockchain.execute_contract("test_contract", {})
        self.assertIn("result", result)
        self.assertEqual(result["result"]["counter"], 1)

    def test_4_governance_operations(self):
        """Test governance operations."""
        # Create proposal
        proposal = Proposal(
            id="test_proposal",
            title="Test Proposal",
            description="Test Description",
            creator=self.dids[0].generate_did(),
            proposal_type="standard",
            options=["approve", "reject"]
        )
        
        # Submit proposal
        self.assertTrue(self.governance.create_proposal(proposal))
        
        # Start voting
        self.assertTrue(self.governance.start_voting(proposal.id))
        
        # Cast votes
        for i, did in enumerate(self.dids[:3]):
            choice = "approve" if i < 2 else "reject"
            self.assertTrue(self.governance.cast_vote(
                proposal.id,
                did.generate_did(),
                choice
            ))
        
        # Fast forward time
        proposal.end_time = datetime.now() - timedelta(minutes=1)
        
        # Finalize proposal
        self.assertTrue(self.governance.finalize_proposal(proposal.id))
        self.assertEqual(self.governance.proposals[proposal.id].status, "approved")

    def test_5_marketplace_operations(self):
        """Test marketplace operations."""
        # Create listing
        listing_id = self.marketplace.create_listing(
            "test_listing",
            self.dids[0].generate_did(),
            "Test Item",
            100
        )
        self.assertIsNotNone(listing_id)
        
        # Place order
        order_id = "test_order"
        self.assertTrue(self.marketplace.place_order(
            order_id,
            self.dids[1].generate_did(),
            listing_id
        ))
        
        # Complete order
        completed_order = self.marketplace.complete_order(order_id)
        self.assertIsNotNone(completed_order)
        self.assertEqual(completed_order.status, "completed")

    def test_6_reputation_system(self):
        """Test reputation system."""
        did_id = self.dids[0].generate_did()
        
        # Update reputation
        self.assertTrue(self.reputation_system.update_reputation(
            did_id,
            10.0,
            "validation",
            {"block_hash": "test_hash"}
        ))
        
        # Check reputation
        reputation = self.reputation_system.get_reputation(did_id)
        self.assertGreater(reputation["validation"], 0)
        
        # Test decay
        self.reputation_system.apply_decay()
        new_reputation = self.reputation_system.get_reputation(did_id)
        self.assertLess(new_reputation["validation"], reputation["validation"])

    def test_7_storage_operations(self):
        """Test storage operations."""
        test_data = b"Test file content"
        
        # Store file
        file_hash = self.storage.store_file("test.txt", test_data)
        self.assertIsNotNone(file_hash)
        
        # Retrieve file
        retrieved_data = self.storage.retrieve_file(file_hash)
        self.assertEqual(retrieved_data, test_data)
        
        # Delete file
        self.assertTrue(self.storage.delete_file(file_hash))
        self.assertIsNone(self.storage.retrieve_file(file_hash))

    def test_8_system_integration(self):
        """Test full system integration."""
        # Create and process a complex transaction
        transaction = Transaction(
            sender=self.dids[0].generate_did(),
            receiver="system",
            action="cooperative_action",
            data={
                "type": "create_cooperative",
                "name": "Test Cooperative",
                "members": [did.generate_did() for did in self.dids[:3]]
            }
        )
        
        self.assertTrue(self.blockchain.add_transaction(transaction))
        
        # Create and add block
        block = self.blockchain.create_block()
        self.assertTrue(self.blockchain.add_block(block))
        
        # Verify chain state
        metrics = self.blockchain.get_metrics()
        self.assertIn('chain_metrics', metrics)
        self.assertIn('node_metrics', metrics)
        self.assertIn('resource_metrics', metrics)

    def test_9_error_handling(self):
        """Test error handling and edge cases."""
        # Test invalid transaction
        invalid_transaction = Transaction(
            sender="invalid_did",
            receiver="system",
            action="invalid_action",
            data={}
        )
        self.assertFalse(self.blockchain.add_transaction(invalid_transaction))
        
        # Test invalid block
        invalid_block = Block(
            index=999,
            previous_hash="invalid",
            timestamp=datetime.now(),
            transactions=[],
            validator="invalid"
        )
        self.assertFalse(self.blockchain.add_block(invalid_block))
        
        # Test invalid smart contract
        invalid_contract = """
def invalid_code():
    import os  # Should be blocked
    return os.system('ls')
"""
        self.assertFalse(self.blockchain.deploy_contract(
            "invalid_contract",
            invalid_contract,
            self.dids[0].generate_did()
        ))

if __name__ == '__main__':
    unittest.main(verbosity=2)

# ==================== /home/matt/icn-prototype/tests/test_blockchain.py ====================

# tests/test_blockchain.py

import unittest
import time
from blockchain.blockchain import Blockchain, Node, ProofOfCooperation, Block
from system.reputation import ReputationSystem
from system.governance import Governance, Proposal
from system.marketplace import Marketplace
from system.storage import DistributedStorage
from did.did import DID, DIDRegistry

class TestICNComponents(unittest.TestCase):
    def setUp(self):
        self.blockchain = Blockchain()
        self.did_registry = DIDRegistry()
        self.reputation_system = ReputationSystem()
        self.governance = Governance(blockchain=self.blockchain)
        self.marketplace = Marketplace(self.blockchain, self.did_registry)
        self.storage = DistributedStorage(self.blockchain)

        # Initialize test DIDs
        self.test_dids = [DID() for _ in range(5)]
        for did in self.test_dids:
            did_id = did.generate_did()
            self.did_registry.register_did(did)
            self.reputation_system.add_user(did_id)

    def test_blockchain_and_poc(self):
        initial_chain_length = len(self.blockchain.get_chain(0))
        self.blockchain.add_new_block("Test Block", 0)
        self.assertEqual(len(self.blockchain.get_chain(0)), initial_chain_length + 1)

        # Test cross-shard transaction
        self.blockchain.cross_shard_transaction(0, 1, "Cross-shard test")
        shard_0_last_block = self.blockchain.get_chain(0)[-1]
        shard_1_last_block = self.blockchain.get_chain(1)[-1]
        self.assertIn("Cross-shard tx start", shard_0_last_block['data'])
        self.assertIn("Cross-shard tx end", shard_1_last_block['data'])

    def test_smart_contracts(self):
        contract_code = """
def execute(input, state):
    if 'counter' not in state:
        state['counter'] = 0
    state['counter'] += 1
    return state
        """
        self.blockchain.deploy_contract("test_contract", contract_code, self.test_dids[0].generate_did())

        # Execute the contract twice and check the counter
        result = self.blockchain.execute_contract("test_contract", {})
        self.assertEqual(result.get('counter', 0), 1)

        result = self.blockchain.execute_contract("test_contract", {})
        self.assertEqual(result.get('counter', 0), 2)

    def test_did_and_reputation(self):
        did = self.test_dids[0]
        did_id = did.generate_did()
        
        # Test DID resolution
        resolved_did = self.did_registry.resolve_did(did_id)
        self.assertEqual(resolved_did.generate_did(), did_id)

        # Test reputation update
        self.reputation_system.update_reputation(did_id, 10, "validation")
        rep = self.reputation_system.get_reputation(did_id)
        self.assertEqual(rep["validation"], 10)

        # Test reputation decay
        self.reputation_system.apply_decay()
        rep = self.reputation_system.get_reputation(did_id)
        self.assertLess(rep["validation"], 10)

class TestEnhancedPoC(unittest.TestCase):
    def setUp(self):
        self.blockchain = Blockchain(num_shards=2)
        self.test_node = self.blockchain.nodes[0]

    def test_reputation_calculation(self):
        # Test initial reputation calculation
        self.test_node.update_reputation("cooperative_growth", 10)
        score = self.blockchain.poc.calculate_reputation_score(self.test_node)
        self.assertGreater(score, 0)

        # Test reputation decay over time
        initial_score = score
        for _ in range(10):
            self.blockchain.poc.update_nodes()
        
        new_score = self.blockchain.poc.calculate_reputation_score(self.test_node)
        self.assertLess(new_score, initial_score)

    def test_diversity_factor(self):
        # Test diversity factor with single cooperative
        self.test_node.update_reputation("cooperative_growth", 10, "coop1")
        single_coop_factor = self.blockchain.poc.calculate_diversity_factor(self.test_node)

        # Test diversity factor with multiple cooperatives
        self.test_node.update_reputation("cooperative_growth", 10, "coop2")
        self.test_node.update_reputation("cooperative_growth", 10, "coop3")
        multi_coop_factor = self.blockchain.poc.calculate_diversity_factor(self.test_node)

        self.assertGreater(multi_coop_factor, single_coop_factor)

    def test_validator_selection(self):
        selections = {}
        for _ in range(100):
            validator = self.blockchain.poc.select_validator()
            if validator:
                selections[validator.node_id] = selections.get(validator.node_id, 0) + 1

        # Check that multiple nodes were selected
        self.assertGreater(len(selections), 1)
        
        # Check that nodes with higher reputation are selected more often
        high_rep_node = max(self.blockchain.nodes, 
                           key=lambda n: sum(n.reputation_scores.values()))
        high_rep_selections = selections.get(high_rep_node.node_id, 0)
        
        for node_id, count in selections.items():
            if node_id != high_rep_node.node_id:
                self.assertGreaterEqual(high_rep_selections, count)

    def test_collusion_detection(self):
        # Simulate repeated validations with same target
        block = Block(1, "prev_hash", time.time(), "test_data", "hash")
        for _ in range(20):
            self.test_node.record_action("validation", "same_target")
        
        # Check collusion detection
        collusion_detected = self.blockchain.poc.detect_collusion(self.test_node, block)
        self.assertTrue(collusion_detected)

        # Test stake slashing
        initial_stake = self.test_node.stake
        self.blockchain.poc.slash_stake(self.test_node, 5)
        self.assertLess(self.test_node.stake, initial_stake)

    def test_network_statistics(self):
        stats = self.blockchain.get_network_statistics()
        
        self.assertIn("total_nodes", stats)
        self.assertIn("active_nodes", stats)
        self.assertIn("average_reputation", stats)
        self.assertIn("cooperation_metrics", stats)

    def test_node_diversity_metrics(self):
        # Add diverse cooperative contributions
        self.test_node.update_reputation("cooperative_growth", 10, "coop1")
        self.test_node.update_reputation("resource_sharing", 5, "coop2")
        
        metrics = self.blockchain.get_node_diversity_metrics()
        node_metric = metrics.get(self.test_node.node_id)
        
        self.assertIn("diversity_factor", node_metric)
        self.assertIn("num_cooperatives", node_metric)
        self.assertIn("total_contribution", node_metric)
        self.assertEqual(node_metric["num_cooperatives"], 2)

    def test_block_validation_reward(self):
        validator = self.blockchain.poc.select_validator()
        if validator:
            initial_reputation = validator.reputation_scores.get("transaction_validation", 0)
            
            block = Block(1, "prev_hash", time.time(), "test_data", "hash")
            self.blockchain.poc.reward_validator(validator, block)
            
            final_reputation = validator.reputation_scores.get("transaction_validation", 0)
            self.assertGreater(final_reputation, initial_reputation)

    def test_mana_management(self):
        initial_mana = self.blockchain.cooperative_mana
        
        # Test mana consumption
        contract_code = "def execute(input, state): return state"
        self.blockchain.deploy_contract("test_contract", contract_code, "test_creator")
        self.blockchain.execute_contract("test_contract", {})
        
        self.assertLess(self.blockchain.cooperative_mana, initial_mana)
        
        # Test mana regeneration
        self.blockchain.regenerate_mana()
        self.assertGreater(self.blockchain.cooperative_mana, 
                          self.blockchain.cooperative_mana - self.blockchain.mana_regen_rate)

    def test_governance(self):
        proposal = Proposal(
            id="proposal_1",
            title="Test Budget Proposal",
            description="Test Description",
            creator=self.test_dids[0].generate_did(),
            proposal_type="budget",
            amount=1000
        )
        proposal_id = self.governance.create_proposal(proposal)
        self.assertIsNotNone(proposal_id)

        vote_started = self.governance.start_voting(proposal_id)
        self.assertTrue(vote_started)

        self.governance.cast_vote(proposal_id, "Yes", self.test_dids[1].generate_did(), 1)
        self.governance.cast_vote(proposal_id, "Yes", self.test_dids[2].generate_did(), 1)

        initial_funds = self.governance.get_cooperative_funds()
        proposal_finalized = self.governance.finalize_proposal(proposal_id)
        self.assertTrue(proposal_finalized)
        self.assertEqual(self.governance.get_cooperative_funds(), initial_funds - 1000)

    def test_marketplace(self):
        seller_did = self.test_dids[0].generate_did()
        buyer_did = self.test_dids[1].generate_did()

        # Test listing creation
        listing_id = self.marketplace.create_listing("test_listing", seller_did, "Test Item", 100)
        self.assertIsNotNone(listing_id)

        # Test order placement and completion
        order_id = "test_order"
        order_placed = self.marketplace.place_order(order_id, buyer_did, listing_id)
        self.assertTrue(order_placed)

        completed_order = self.marketplace.complete_order(order_id)
        self.assertIsNotNone(completed_order)
        self.assertEqual(completed_order.status, "completed")

    def test_storage(self):
        test_data = b"This is a test file content."
        file_hash = self.storage.store_file("test_file.txt", test_data)
        self.assertIsNotNone(file_hash)

        # Test file retrieval and deletion
        retrieved_data = self.storage.retrieve_file(file_hash)
        self.assertEqual(retrieved_data, test_data)

        deleted = self.storage.delete_file(file_hash)
        self.assertTrue(deleted)
        self.assertIsNone(self.storage.retrieve_file(file_hash))

if __name__ == "__main__":
    unittest.main()

# ==================== /home/matt/icn-prototype/system/marketplace.py ====================

from typing import Dict

class Listing:
    def __init__(self, id, seller, item, price):
        self.id = id
        self.seller = seller
        self.item = item
        self.price = price

class Order:
    def __init__(self, id, buyer, listing):
        self.id = id
        self.buyer = buyer
        self.listing = listing
        self.status = "pending"

class Marketplace:
    def __init__(self, blockchain, did_registry):
        self.blockchain = blockchain
        self.did_registry = did_registry
        self.listings: Dict[str, Listing] = {}
        self.orders: Dict[str, Order] = {}

    def create_listing(self, listing_id, seller_did, item, price):
        seller = self.did_registry.resolve_did(seller_did)
        if not seller:
            return None
        
        listing = Listing(listing_id, seller_did, item, price)
        self.listings[listing_id] = listing
        self.blockchain.add_new_block(f"Listing created: {listing_id}", 1)  # Assume shard 1 for marketplace
        return listing_id

    def remove_listing(self, listing_id, seller_did):
        listing = self.listings.get(listing_id)
        if listing and listing.seller == seller_did:
            del self.listings[listing_id]
            self.blockchain.add_new_block(f"Listing removed: {listing_id}", 1)
            return True
        return False

    def place_order(self, order_id, buyer_did, listing_id):
        listing = self.listings.get(listing_id)
        buyer = self.did_registry.resolve_did(buyer_did)
        if not listing or not buyer:
            return False
        
        order = Order(order_id, buyer_did, listing)
        self.orders[order_id] = order
        self.blockchain.add_new_block(f"Order placed: {order_id}", 1)
        return True

    def complete_order(self, order_id):
        order = self.orders.get(order_id)
        if not order:
            return None
        
        # In a real system, you'd implement escrow release here
        order.status = "completed"
        self.blockchain.add_new_block(f"Order completed: {order_id}", 1)
        return order

    def get_listing(self, listing_id):
        return self.listings.get(listing_id)

    def get_order(self, order_id):
        return self.orders.get(order_id)

    def list_listings(self):
        return self.listings

    def list_orders(self):
        return self.orders

    def get_seller_reputation(self, seller_did):
        seller = self.did_registry.resolve_did(seller_did)
        if seller:
            return seller.get_reputation_scores().get("marketplace", 0)
        return 0

# ==================== /home/matt/icn-prototype/system/reputation.py ====================

# system/reputation.py

from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
import logging
from dataclasses import dataclass, field
import math

logger = logging.getLogger(__name__)

@dataclass
class ReputationEvent:
    """Represents a reputation-changing event."""
    category: str
    score: float
    timestamp: datetime
    evidence: Optional[Dict] = None
    decay_rate: float = 0.1

    def get_current_value(self, current_time: datetime) -> float:
        """Calculate the current value of the reputation event with decay."""
        age = (current_time - self.timestamp).total_seconds() / (24 * 3600)  # age in days
        return self.score * math.exp(-self.decay_rate * age)

class ReputationCategory:
    """Manages reputation for a specific category."""
    
    def __init__(self, name: str, weight: float = 1.0, 
                 decay_rate: float = 0.1):
        self.name = name
        self.weight = weight
        self.decay_rate = decay_rate
        self.events: List[ReputationEvent] = []
        self.minimum_score = 0.0
        self.maximum_score = float('inf')

    def add_event(self, score: float, evidence: Optional[Dict] = None) -> None:
        """Add a new reputation event."""
        event = ReputationEvent(
            category=self.name,
            score=score,
            timestamp=datetime.now(),
            evidence=evidence,
            decay_rate=self.decay_rate
        )
        self.events.append(event)

    def get_current_score(self) -> float:
        """Calculate current score with decay."""
        current_time = datetime.now()
        total_score = sum(event.get_current_value(current_time) 
                         for event in self.events)
        return max(min(total_score, self.maximum_score), self.minimum_score)

    def prune_old_events(self, max_age_days: int = 30) -> None:
        """Remove events older than specified age."""
        cutoff_time = datetime.now() - timedelta(days=max_age_days)
        self.events = [event for event in self.events 
                      if event.timestamp >= cutoff_time]

class ReputationSystem:
    """Enhanced reputation system for ICN."""
    
    def __init__(self):
        self.categories: Dict[str, ReputationCategory] = {
            "validation": ReputationCategory("validation", 1.0, 0.1),
            "voting": ReputationCategory("voting", 1.2, 0.05),
            "proposal_creation": ReputationCategory("proposal_creation", 1.5, 0.03),
            "development": ReputationCategory("development", 2.0, 0.02),
            "budget_management": ReputationCategory("budget_management", 1.8, 0.08),
            "community_building": ReputationCategory("community_building", 1.3, 0.04),
            "resource_sharing": ReputationCategory("resource_sharing", 1.4, 0.06),
            "cooperative_growth": ReputationCategory("cooperative_growth", 1.6, 0.03),
            "conflict_resolution": ReputationCategory("conflict_resolution", 1.7, 0.05),
            "sustainability": ReputationCategory("sustainability", 1.5, 0.04),
            "participation": ReputationCategory("participation", 1.1, 0.07),
            "innovation": ReputationCategory("innovation", 1.9, 0.02),
        }
        self.user_reputations: Dict[str, Dict[str, ReputationCategory]] = {}
        self.user_metadata: Dict[str, Dict] = {}
        self.registered_users: Set[str] = set()
        
    def add_user(self, user_id: str, metadata: Optional[Dict] = None) -> None:
        """Initialize reputation categories for a new user."""
        if user_id not in self.user_reputations:
            self.user_reputations[user_id] = {
                name: ReputationCategory(name, cat.weight, cat.decay_rate)
                for name, cat in self.categories.items()
            }
            self.user_metadata[user_id] = metadata or {}
            self.registered_users.add(user_id)
            logger.info(f"Initialized reputation for user: {user_id}")

    def remove_user(self, user_id: str) -> bool:
        """Remove a user from the reputation system."""
        if user_id in self.user_reputations:
            del self.user_reputations[user_id]
            del self.user_metadata[user_id]
            self.registered_users.remove(user_id)
            logger.info(f"Removed user: {user_id}")
            return True
        return False

    def get_all_users(self) -> List[str]:
        """Get list of all registered users."""
        return list(self.registered_users)

    def update_reputation(self, user_id: str, score: float, 
                         category: str, evidence: Optional[Dict] = None) -> bool:
        """Update a user's reputation with evidence."""
        if user_id not in self.user_reputations:
            logger.warning(f"Unknown user: {user_id}")
            return False
        
        if category not in self.user_reputations[user_id]:
            logger.warning(f"Unknown category: {category}")
            return False

        if score == 0:
            return True

        self.user_reputations[user_id][category].add_event(score, evidence)
        logger.info(f"Updated reputation for {user_id} in {category}: {score}")
        
        # Update participation category automatically
        if category != "participation":
            self.user_reputations[user_id]["participation"].add_event(
                abs(score) * 0.1,  # Small participation score for any activity
                {"source_category": category}
            )
        
        return True

    def get_reputation(self, user_id: str) -> Dict[str, float]:
        """Get current reputation scores for a user."""
        if user_id not in self.user_reputations:
            return {}
        
        return {
            category: rep_category.get_current_score()
            for category, rep_category in self.user_reputations[user_id].items()
        }

    def get_total_reputation(self, user_id: str) -> float:
        """Calculate total weighted reputation score."""
        if user_id not in self.user_reputations:
            return 0.0
        
        scores = self.get_reputation(user_id)
        weighted_scores = [
            score * self.categories[category].weight
            for category, score in scores.items()
        ]
        return sum(weighted_scores)

    def get_user_ranking(self, category: Optional[str] = None) -> List[tuple]:
        """Get users ranked by reputation in a category or overall."""
        if category and category not in self.categories:
            return []

        rankings = []
        for user_id in self.registered_users:
            if category:
                score = self.get_reputation(user_id).get(category, 0)
            else:
                score = self.get_total_reputation(user_id)
            rankings.append((user_id, score))

        return sorted(rankings, key=lambda x: x[1], reverse=True)

    def apply_decay(self) -> None:
        """Apply reputation decay to all users."""
        current_time = datetime.now()
        for user_reputations in self.user_reputations.values():
            for category in user_reputations.values():
                category.prune_old_events()

    def get_reputation_history(self, user_id: str, category: str,
                             days: int = 30) -> List[Dict]:
        """Get historical reputation events for a category."""
        if user_id not in self.user_reputations:
            return []
        
        category_rep = self.user_reputations[user_id].get(category)
        if not category_rep:
            return []

        cutoff_time = datetime.now() - timedelta(days=days)
        history = []
        
        for event in category_rep.events:
            if event.timestamp >= cutoff_time:
                history.append({
                    'timestamp': event.timestamp,
                    'score': event.score,
                    'evidence': event.evidence,
                    'current_value': event.get_current_value(datetime.now())
                })
                
        return sorted(history, key=lambda x: x['timestamp'])

    def get_category_thresholds(self, category: str) -> Optional[Dict[str, float]]:
        """Get the minimum and maximum thresholds for a category."""
        if category not in self.categories:
            return None
            
        return {
            'minimum': self.categories[category].minimum_score,
            'maximum': self.categories[category].maximum_score
        }

    def set_category_thresholds(self, category: str, 
                              minimum: float, maximum: float) -> bool:
        """Set the minimum and maximum thresholds for a category."""
        if category not in self.categories:
            return False
            
        if minimum > maximum:
            return False
            
        self.categories[category].minimum_score = minimum
        self.categories[category].maximum_score = maximum
        return True

    def get_system_stats(self) -> Dict:
        """Get system-wide reputation statistics."""
        stats = {
            'total_users': len(self.registered_users),
            'total_events': 0,
            'category_averages': {},
            'top_users': self.get_user_ranking()[:10]
        }
        
        for category in self.categories:
            scores = []
            total_events = 0
            for user_id in self.registered_users:
                user_rep = self.user_reputations.get(user_id, {}).get(category)
                if user_rep:
                    scores.append(user_rep.get_current_score())
                    total_events += len(user_rep.events)
            
            if scores:
                stats['category_averages'][category] = sum(scores) / len(scores)
            else:
                stats['category_averages'][category] = 0
            
            stats['total_events'] += total_events
        
        return stats

# ==================== /home/matt/icn-prototype/system/governance.py ====================

# system/governance.py

from typing import Dict, List, Optional, Union
from datetime import datetime, timedelta
import logging
from dataclasses import dataclass, field
import math
import json

logger = logging.getLogger(__name__)

@dataclass
class Proposal:
    """Represents a governance proposal in the ICN system."""
    id: str
    title: str
    description: str
    creator: str
    proposal_type: str
    options: List[str]
    amount: Optional[float] = None
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    status: str = "pending"
    metadata: Dict = field(default_factory=dict)
    votes: Dict[str, int] = field(default_factory=dict)
    vote_weights: Dict[str, float] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """Convert proposal to dictionary format."""
        return {
            'id': self.id,
            'title': self.title,
            'description': self.description,
            'creator': self.creator,
            'type': self.proposal_type,
            'options': self.options,
            'amount': self.amount,
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'status': self.status,
            'metadata': self.metadata,
            'votes': self.votes,
            'vote_weights': self.vote_weights
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Proposal':
        """Create proposal from dictionary."""
        proposal = cls(
            id=data['id'],
            title=data['title'],
            description=data['description'],
            creator=data['creator'],
            proposal_type=data['type'],
            options=data['options'],
            amount=data.get('amount'),
            start_time=datetime.fromisoformat(data['start_time']),
            status=data['status'],
            metadata=data.get('metadata', {})
        )
        if data.get('end_time'):
            proposal.end_time = datetime.fromisoformat(data['end_time'])
        proposal.votes = data.get('votes', {})
        proposal.vote_weights = data.get('vote_weights', {})
        return proposal

class VotingSystem:
    """Manages voting mechanics for proposals."""
    
    def __init__(self, quorum_percentage: float = 0.4):
        self.quorum_percentage = quorum_percentage
        self.vote_records: Dict[str, Dict[str, Dict]] = {}

    def cast_vote(self, proposal_id: str, voter_id: str, choice: str,
                  weight: float = 1.0) -> bool:
        """Cast a weighted vote on a proposal."""
        if proposal_id not in self.vote_records:
            self.vote_records[proposal_id] = {}
            
        self.vote_records[proposal_id][voter_id] = {
            'choice': choice,
            'weight': weight,
            'timestamp': datetime.now()
        }
        return True

    def get_results(self, proposal_id: str) -> Dict[str, float]:
        """Calculate weighted voting results."""
        if proposal_id not in self.vote_records:
            return {}
            
        results = {}
        for vote_info in self.vote_records[proposal_id].values():
            choice = vote_info['choice']
            weight = vote_info['weight']
            results[choice] = results.get(choice, 0) + weight
            
        return results

    def has_quorum(self, proposal_id: str, total_voters: int) -> bool:
        """Check if proposal has reached quorum."""
        if proposal_id not in self.vote_records:
            return False
            
        participation = len(self.vote_records[proposal_id]) / total_voters
        return participation >= self.quorum_percentage

class Governance:
    """Main governance system for the ICN."""
    
    def __init__(self, blockchain, reputation_system):
        self.blockchain = blockchain
        self.reputation_system = reputation_system
        self.proposals: Dict[str, Proposal] = {}
        self.voting_system = VotingSystem()
        self.bylaws: Dict[str, str] = {}
        self.funds: float = 0
        self.approval_thresholds = {
            "constitution": 0.75,  # Constitutional changes require 75% approval
            "bylaw": 0.66,        # Bylaw changes require 66% approval
            "budget": 0.60,       # Budget proposals require 60% approval
            "standard": 0.51      # Standard proposals require simple majority
        }

    def create_proposal(self, proposal: Proposal) -> bool:
        """Create a new governance proposal."""
        try:
            # Validate creator's reputation
            creator_rep = self.reputation_system.get_reputation(proposal.creator)
            if creator_rep.get('proposal_creation', 0) < 10:
                logger.warning(f"Insufficient reputation for proposal creation: {proposal.creator}")
                return False

            # Validate proposal type
            if proposal.proposal_type not in self.approval_thresholds:
                logger.error(f"Invalid proposal type: {proposal.proposal_type}")
                return False

            self.proposals[proposal.id] = proposal
            
            # Create blockchain transaction
            transaction = {
                'type': 'proposal_creation',
                'proposal_id': proposal.id,
                'creator': proposal.creator,
                'timestamp': datetime.now().isoformat()
            }
            
            self.blockchain.add_transaction(transaction)
            logger.info(f"Created proposal: {proposal.id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create proposal: {e}")
            return False

    def start_voting(self, proposal_id: str, duration_days: int = 7) -> bool:
        """Start the voting period for a proposal."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "pending":
            return False

        proposal.status = "active"
        proposal.start_time = datetime.now()
        proposal.end_time = proposal.start_time + timedelta(days=duration_days)

        transaction = {
            'type': 'voting_start',
            'proposal_id': proposal_id,
            'start_time': proposal.start_time.isoformat(),
            'end_time': proposal.end_time.isoformat()
        }

        self.blockchain.add_transaction(transaction)
        logger.info(f"Started voting for proposal: {proposal_id}")
        return True

    def cast_vote(self, proposal_id: str, voter_id: str, choice: str) -> bool:
        """Cast a vote on an active proposal."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "active":
            return False

        if datetime.now() > proposal.end_time:
            logger.warning(f"Voting period ended for proposal: {proposal_id}")
            return False

        # Calculate voting power based on reputation
        reputation = self.reputation_system.get_reputation(voter_id)
        voting_power = self._calculate_voting_power(reputation)

        # Record vote
        if self.voting_system.cast_vote(proposal_id, voter_id, choice, voting_power):
            transaction = {
                'type': 'vote_cast',
                'proposal_id': proposal_id,
                'voter': voter_id,
                'choice': choice,
                'weight': voting_power
            }
            self.blockchain.add_transaction(transaction)

            # Update voter's reputation
            self.reputation_system.update_reputation(
                voter_id,
                1.0,
                'voting',
                {'proposal_id': proposal_id}
            )

            logger.info(f"Recorded vote from {voter_id} on proposal {proposal_id}")
            return True

        return False

    def _calculate_voting_power(self, reputation: Dict[str, float]) -> float:
        """Calculate voting power based on reputation scores."""
        # Calculate base voting power from reputation
        base_power = sum(reputation.values()) / len(reputation)
        
        # Apply square root to prevent excessive concentration of power
        return math.sqrt(max(1.0, base_power))

    def finalize_proposal(self, proposal_id: str) -> bool:
        """Finalize a proposal after voting period."""
        proposal = self.proposals.get(proposal_id)
        if not proposal or proposal.status != "active":
            return False

        if datetime.now() < proposal.end_time:
            logger.warning(f"Voting period still active for proposal: {proposal_id}")
            return False

        results = self.voting_system.get_results(proposal_id)
        if not results:
            proposal.status = "failed"
            return False

        total_voters = len(self.reputation_system.get_all_users())
        if not self.voting_system.has_quorum(proposal_id, total_voters):
            proposal.status = "failed"
            logger.info(f"Proposal {proposal_id} failed due to lack of quorum")
            return False

        # Calculate approval percentage
        total_votes = sum(results.values())
        approval_percentage = results.get("approve", 0) / total_votes

        # Get required threshold
        threshold = self.approval_thresholds[proposal.proposal_type]

        if approval_percentage >= threshold:
            proposal.status = "approved"
            self._implement_proposal(proposal)
        else:
            proposal.status = "rejected"

        transaction = {
            'type': 'proposal_finalization',
            'proposal_id': proposal_id,
            'status': proposal.status,
            'results': results
        }
        self.blockchain.add_transaction(transaction)

        logger.info(f"Finalized proposal {proposal_id} with status: {proposal.status}")
        return True

    def _implement_proposal(self, proposal: Proposal) -> None:
        """Implement an approved proposal."""
        implementation_handlers = {
            "budget": self._implement_budget_proposal,
            "bylaw": self._implement_bylaw_proposal,
            "constitution": self._implement_constitution_proposal,
        }
        
        handler = implementation_handlers.get(proposal.proposal_type)
        if handler:
            handler(proposal)

    def _implement_budget_proposal(self, proposal: Proposal) -> None:
        """Implement a budget proposal."""
        if proposal.amount and self.funds >= proposal.amount:
            self.funds -= proposal.amount
            transaction = {
                'type': 'budget_execution',
                'proposal_id': proposal.id,
                'amount': proposal.amount
            }
            self.blockchain.add_transaction(transaction)

    def _implement_bylaw_proposal(self, proposal: Proposal) -> None:
        """Implement a bylaw proposal."""
        self.bylaws[proposal.title] = proposal.description
        transaction = {
            'type': 'bylaw_update',
            'proposal_id': proposal.id,
            'title': proposal.title
        }
        self.blockchain.add_transaction(transaction)

    def _implement_constitution_proposal(self, proposal: Proposal) -> None:
        """Implement a constitutional proposal."""
        transaction = {
            'type': 'constitution_update',
            'proposal_id': proposal.id,
            'changes': proposal.metadata.get('changes', {})
        }
        self.blockchain.add_transaction(transaction)

    def get_proposal(self, proposal_id: str) -> Optional[Proposal]:
        """Get a specific proposal."""
        return self.proposals.get(proposal_id)

    def get_active_proposals(self) -> List[Proposal]:
        """Get all currently active proposals."""
        return [p for p in self.proposals.values() if p.status == "active"]

    def get_proposal_metrics(self) -> Dict:
        """Get metrics about proposal activity."""
        return {
            'total_proposals': len(self.proposals),
            'active_proposals': len([p for p in self.proposals.values() if p.status == "active"]),
            'approved_proposals': len([p for p in self.proposals.values() if p.status == "approved"]),
            'rejected_proposals': len([p for p in self.proposals.values() if p.status == "rejected"]),
            'average_participation': self._calculate_average_participation()
        }

    def _calculate_average_participation(self) -> float:
        """Calculate average participation rate in voted proposals."""
        voted_proposals = [p for p in self.proposals.values() 
                         if p.status in ["approved", "rejected"]]
        if not voted_proposals:
            return 0.0

        total_users = len(self.reputation_system.get_all_users())
        participation_rates = []

        for proposal in voted_proposals:
            if proposal.id in self.voting_system.vote_records:
                participation = len(self.voting_system.vote_records[proposal.id]) / total_users
                participation_rates.append(participation)

        return sum(participation_rates) / len(participation_rates) if participation_rates else 0.0

# ==================== /home/matt/icn-prototype/system/storage.py ====================

import hashlib
from typing import Dict, List

class DataChunk:
    def __init__(self, data: bytes):
        self.data = data
        self.hash = hashlib.sha256(data).hexdigest()

class DistributedStorage:
    def __init__(self, blockchain):
        self.blockchain = blockchain
        self.data_chunks: Dict[str, DataChunk] = {}
        self.file_mappings: Dict[str, List[str]] = {}

    def store_file(self, file_name: str, data: bytes) -> str:
        chunk_size = 1024 * 1024  # 1 MB chunks
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        
        chunk_hashes = []
        for chunk in chunks:
            data_chunk = DataChunk(chunk)
            self.data_chunks[data_chunk.hash] = data_chunk
            chunk_hashes.append(data_chunk.hash)
        
        file_hash = hashlib.sha256(("".join(chunk_hashes)).encode()).hexdigest()
        self.file_mappings[file_hash] = chunk_hashes
        
        self.blockchain.add_new_block(f"File stored: {file_hash}", 2)  # Assume shard 2 for storage
        return file_hash

    def retrieve_file(self, file_hash: str) -> bytes:
        chunk_hashes = self.file_mappings.get(file_hash)
        if not chunk_hashes:
            return None
        
        file_data = b""
        for chunk_hash in chunk_hashes:
            chunk = self.data_chunks.get(chunk_hash)
            if chunk:
                file_data += chunk.data
            else:
                return None  # File is incomplete
        
        return file_data

    def delete_file(self, file_hash: str) -> bool:
        chunk_hashes = self.file_mappings.get(file_hash)
        if not chunk_hashes:
            return False
        
        for chunk_hash in chunk_hashes:
            if chunk_hash in self.data_chunks:
                del self.data_chunks[chunk_hash]
        
        del self.file_mappings[file_hash]
        self.blockchain.add_new_block(f"File deleted: {file_hash}", 2)
        return True

# ==================== /home/matt/icn-prototype/system/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/blockchain.py ====================

# blockchain/blockchain.py

import hashlib
import time
import math
import random
import json
import signal
import logging
from typing import Dict, List, Optional, Tuple, Set, Any, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from cryptography.exceptions import InvalidKey
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)

@dataclass
class Transaction:
    """Represents a transaction in the ICN blockchain."""
    sender: str
    receiver: str
    action: str
    data: Dict
    timestamp: datetime = field(default_factory=datetime.now)
    signature: Optional[bytes] = None
    shard_id: Optional[int] = None
    transaction_id: str = field(init=False)
    
    def __post_init__(self):
        """Initialize transaction ID after creation."""
        self.transaction_id = self.calculate_id()
    
    def calculate_id(self) -> str:
        """Calculate unique transaction ID."""
        tx_data = {
            'sender': self.sender,
            'receiver': self.receiver,
            'action': self.action,
            'data': self.data,
            'timestamp': self.timestamp.isoformat(),
            'shard_id': self.shard_id
        }
        return hashlib.sha256(json.dumps(tx_data, sort_keys=True).encode()).hexdigest()
    
    def to_dict(self) -> Dict:
        """Convert transaction to dictionary format."""
        return {
            'transaction_id': self.transaction_id,
            'sender': self.sender,
            'receiver': self.receiver,
            'action': self.action,
            'data': self.data,
            'timestamp': self.timestamp.isoformat(),
            'signature': self.signature.hex() if self.signature else None,
            'shard_id': self.shard_id
        }
        
    @classmethod
    def from_dict(cls, data: Dict) -> 'Transaction':
        """Create transaction from dictionary."""
        timestamp = datetime.fromisoformat(data['timestamp'])
        signature = bytes.fromhex(data['signature']) if data.get('signature') else None
        
        return cls(
            sender=data['sender'],
            receiver=data['receiver'],
            action=data['action'],
            data=data['data'],
            timestamp=timestamp,
            signature=signature,
            shard_id=data.get('shard_id')
        )

    def validate(self) -> bool:
        """Validate transaction structure and data."""
        try:
            # Validate basic structure
            if not all([self.sender, self.receiver, self.action]):
                return False
            
            # Validate timestamp
            if self.timestamp > datetime.now() + timedelta(minutes=5):
                return False
                
            # Validate data structure
            if not isinstance(self.data, dict):
                return False
                
            # Validate transaction ID
            if self.transaction_id != self.calculate_id():
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Transaction validation failed: {e}")
            return False

@dataclass
class Block:
    """Represents a block in the ICN blockchain."""
    index: int
    previous_hash: str
    timestamp: datetime
    transactions: List[Transaction]
    validator: str
    shard_id: int
    hash: str = ""
    nonce: int = 0
    merkle_root: str = ""
    cross_shard_refs: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    version: str = "1.0"
    
    def __post_init__(self):
        """Initialize block after creation."""
        if not self.merkle_root:
            self.merkle_root = self.calculate_merkle_root()
        if not self.hash:
            self.hash = self.calculate_hash()
        self.metadata['created_at'] = datetime.now().isoformat()

    def calculate_merkle_root(self) -> str:
        """Calculate the Merkle root of transactions."""
        if not self.transactions:
            return hashlib.sha256(b"empty").hexdigest()
        
        leaves = [hashlib.sha256(json.dumps(tx.to_dict()).encode()).hexdigest()
                 for tx in self.transactions]
        
        while len(leaves) > 1:
            if len(leaves) % 2 == 1:
                leaves.append(leaves[-1])
            leaves = [hashlib.sha256((a + b).encode()).hexdigest()
                     for a, b in zip(leaves[::2], leaves[1::2])]
        
        return leaves[0]

    def calculate_hash(self) -> str:
        """Calculate the hash of the block."""
        block_dict = {
            'index': self.index,
            'previous_hash': self.previous_hash,
            'timestamp': self.timestamp.isoformat(),
            'merkle_root': self.merkle_root,
            'validator': self.validator,
            'nonce': self.nonce,
            'shard_id': self.shard_id,
            'cross_shard_refs': self.cross_shard_refs,
            'version': self.version
        }
        return hashlib.sha256(json.dumps(block_dict, sort_keys=True).encode()).hexdigest()

    def to_dict(self) -> Dict:
        """Convert block to dictionary format."""
        return {
            'index': self.index,
            'previous_hash': self.previous_hash,
            'timestamp': self.timestamp.isoformat(),
            'transactions': [tx.to_dict() for tx in self.transactions],
            'validator': self.validator,
            'hash': self.hash,
            'nonce': self.nonce,
            'merkle_root': self.merkle_root,
            'shard_id': self.shard_id,
            'cross_shard_refs': self.cross_shard_refs,
            'metadata': self.metadata,
            'version': self.version
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Block':
        """Create block from dictionary."""
        transactions = [Transaction.from_dict(tx) for tx in data['transactions']]
        timestamp = datetime.fromisoformat(data['timestamp'])
        
        return cls(
            index=data['index'],
            previous_hash=data['previous_hash'],
            timestamp=timestamp,
            transactions=transactions,
            validator=data['validator'],
            shard_id=data['shard_id'],
            hash=data['hash'],
            nonce=data['nonce'],
            merkle_root=data['merkle_root'],
            cross_shard_refs=data.get('cross_shard_refs', []),
            metadata=data.get('metadata', {}),
            version=data.get('version', "1.0")
        )

    def validate(self, previous_block: Optional['Block'] = None) -> bool:
        """Validate block structure and consistency."""
        try:
            # Validate hash
            if self.hash != self.calculate_hash():
                return False
                
            # Validate merkle root
            if self.merkle_root != self.calculate_merkle_root():
                return False
                
            # Validate timestamp
            if self.timestamp > datetime.now() + timedelta(minutes=5):
                return False
                
            # Validate transactions
            if not all(tx.validate() for tx in self.transactions):
                return False
                
            # Validate against previous block if provided
            if previous_block:
                if self.previous_hash != previous_block.hash:
                    return False
                if self.index != previous_block.index + 1:
                    return False
                if self.timestamp <= previous_block.timestamp:
                    return False
                    
            return True
            
        except Exception as e:
            logger.error(f"Block validation failed: {e}")
            return False
            class Shard:
    """Represents a blockchain shard."""
    
    def __init__(self, shard_id: int, max_transactions_per_block: int = 100):
        self.shard_id = shard_id
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.height = 0
        self.max_transactions_per_block = max_transactions_per_block
        self.last_block_time = datetime.now()
        self.state: Dict = {}
        self.metrics: Dict = {
            'total_transactions': 0,
            'average_block_time': 0,
            'blocks_created': 0,
            'pending_count': 0
        }
        self._create_genesis_block()

    def _create_genesis_block(self) -> None:
        """Create genesis block for this shard."""
        genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=self.shard_id
        )
        self.chain.append(genesis_block)
        self.height = 1
        self.last_block_time = genesis_block.timestamp
        self.metrics['blocks_created'] = 1

    def add_transaction(self, transaction: Transaction) -> bool:
        """Add a new transaction to pending pool."""
        if transaction.shard_id != self.shard_id:
            return False
            
        if len(self.pending_transactions) >= self.max_transactions_per_block * 2:
            return False
            
        if not transaction.validate():
            return False
            
        self.pending_transactions.append(transaction)
        self.metrics['pending_count'] = len(self.pending_transactions)
        return True

    def create_block(self, validator: str) -> Optional[Block]:
        """Create a new block from pending transactions."""
        if not self.pending_transactions:
            return None
            
        transactions = self.pending_transactions[:self.max_transactions_per_block]
        
        new_block = Block(
            index=self.height,
            previous_hash=self.chain[-1].hash,
            timestamp=datetime.now(),
            transactions=transactions,
            validator=validator,
            shard_id=self.shard_id
        )
        
        return new_block

    def add_block(self, block: Block) -> bool:
        """Add a validated block to the shard chain."""
        if block.shard_id != self.shard_id:
            return False
            
        if block.index != self.height:
            return False
            
        if not block.validate(self.chain[-1]):
            return False
            
        # Update metrics
        block_time = (block.timestamp - self.last_block_time).total_seconds()
        self.metrics['average_block_time'] = (
            (self.metrics['average_block_time'] * self.metrics['blocks_created'] + block_time) /
            (self.metrics['blocks_created'] + 1)
        )
        self.metrics['blocks_created'] += 1
        self.metrics['total_transactions'] += len(block.transactions)
        
        # Remove included transactions from pending pool
        tx_ids = {tx.transaction_id for tx in block.transactions}
        self.pending_transactions = [
            tx for tx in self.pending_transactions 
            if tx.transaction_id not in tx_ids
        ]
        self.metrics['pending_count'] = len(self.pending_transactions)
        
        # Add block to chain
        self.chain.append(block)
        self.height += 1
        self.last_block_time = block.timestamp
        
        return True

    def get_latest_block(self) -> Block:
        """Get the latest block in this shard."""
        return self.chain[-1]

    def validate_chain(self) -> bool:
        """Validate the entire shard chain."""
        for i in range(1, len(self.chain)):
            if not self.chain[i].validate(self.chain[i-1]):
                return False
        return True

    def get_metrics(self) -> Dict:
        """Get shard metrics and statistics."""
        return {
            'shard_id': self.shard_id,
            'height': self.height,
            'pending_transactions': len(self.pending_transactions),
            'last_block_time': self.last_block_time.isoformat(),
            **self.metrics
        }


@dataclass
class Node:
    """Represents a node in the ICN network."""
    
    def __init__(self, node_id: str, cooperative_id: Optional[str] = None,
                 initial_stake: float = 10.0):
        self.node_id = node_id
        self.cooperative_id = cooperative_id
        self.reputation_scores = {
            'validation': 0.0,
            'proposal_creation': 0.0,
            'voting': 0.0,
            'resource_sharing': 0.0,
            'cooperative_growth': 0.0,
            'community_building': 0.0,
            'conflict_resolution': 0.0,
            'transaction_validation': 0.0,
            'data_availability': 0.0,
            'network_stability': 0.0,
            'innovation': 0.0,
            'sustainability': 0.0
        }
        self.stake = initial_stake
        self.cooperative_interactions: List[str] = []
        self.validation_history: List[Dict] = []
        self.resource_usage: Dict[str, float] = {
            'computation': 0.0,
            'storage': 0.0,
            'bandwidth': 0.0,
            'memory': 0.0,
            'energy': 0.0
        }
        self.shard_assignments: Set[int] = set()
        self.active_shards: Dict[int, datetime] = {}
        self.last_validation = 0
        self.total_validations = 0
        self.cooldown = 0
        self.total_cycles = 0
        self.cycles_since_update: Dict[str, int] = {}
        self.performance_metrics: Dict[str, float] = {
            'response_time': 0.0,
            'availability': 100.0,
            'validation_success_rate': 100.0,
            'network_reliability': 100.0
        }
        self.metadata: Dict = {
            'creation_time': datetime.now(),
            'last_active': datetime.now(),
            'version': "1.0",
            'capabilities': set(),
            'status': "active"
        }

    def update_reputation(self, category: str, score: float, 
                         cooperative_id: Optional[str] = None,
                         evidence: Optional[Dict] = None) -> None:
        """Update reputation score for a category with evidence."""
        if category in self.reputation_scores:
            old_score = self.reputation_scores[category]
            self.reputation_scores[category] = max(0, old_score + score)
            
            if cooperative_id:
                self.cooperative_interactions.append(cooperative_id)
                
            if evidence:
                self.validation_history.append({
                    'timestamp': datetime.now(),
                    'category': category,
                    'score_change': score,
                    'evidence': evidence
                })
            
            self.metadata['last_active'] = datetime.now()
            
            # Trim interaction history to last 1000 interactions
            if len(self.cooperative_interactions) > 1000:
                self.cooperative_interactions = self.cooperative_interactions[-1000:]

    def assign_to_shard(self, shard_id: int) -> bool:
        """Assign node to a shard."""
        if len(self.active_shards) >= 3:  # Maximum 3 active shards per node
            return False
            
        self.shard_assignments.add(shard_id)
        self.active_shards[shard_id] = datetime.now()
        return True

    def remove_from_shard(self, shard_id: int) -> bool:
        """Remove node from a shard."""
        if shard_id in self.active_shards:
            del self.active_shards[shard_id]
            self.shard_assignments.discard(shard_id)
            return True
        return False

    def can_validate(self, shard_id: Optional[int] = None) -> bool:
        """Check if node can validate blocks."""
        current_time = time.time()
        
        # Basic validation checks
        if self.cooldown > 0:
            return False
        if current_time - self.last_validation < 10:  # 10 second minimum between validations
            return False
        if self.metadata['status'] != "active":
            return False
            
        # Shard-specific validation
        if shard_id is not None:
            if shard_id not in self.active_shards:
                return False
            if (datetime.now() - self.active_shards[shard_id]).total_seconds() > 3600:  # 1 hour timeout
                return False
                
        return True

    def enter_cooldown(self, cooldown_period: int) -> None:
        """Put node into cooldown period."""
        self.cooldown = cooldown_period
        self.metadata['status'] = "cooldown"

    def update_metrics(self, metrics: Dict[str, float]) -> None:
        """Update node performance metrics."""
        self.performance_metrics.update(metrics)
        self.metadata['last_active'] = datetime.now()

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def to_dict(self) -> Dict:
        """Convert node state to dictionary."""
        return {
            'node_id': self.node_id,
            'cooperative_id': self.cooperative_id,
            'reputation_scores': self.reputation_scores,
            'stake': self.stake,
            'shard_assignments': list(self.shard_assignments),
            'performance_metrics': self.performance_metrics,
            'resource_usage': self.resource_usage,
            'metadata': self.metadata,
            'status': self.metadata['status']
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Node':
        """Create node from dictionary."""
        node = cls(
            node_id=data['node_id'],
            cooperative_id=data['cooperative_id'],
            initial_stake=data['stake']
        )
        node.reputation_scores = data['reputation_scores']
        node.shard_assignments = set(data['shard_assignments'])
        node.performance_metrics = data['performance_metrics']
        node.resource_usage = data['resource_usage']
        node.metadata = data['metadata']
        
        return node
        class ProofOfCooperation:
    """Implements the Proof of Cooperation consensus mechanism."""
    
    def __init__(self, min_reputation: float = 10.0, cooldown_blocks: int = 3):
        self.min_reputation = min_reputation
        self.cooldown_blocks = cooldown_blocks
        self.cooperation_scores: Dict[str, float] = {}
        self.reputation_weights = {
            'cooperative_growth': 1.5,
            'proposal_participation': 1.2,
            'transaction_validation': 1.0,
            'resource_sharing': 1.3,
            'conflict_resolution': 1.1,
            'community_building': 1.4,
            'sustainability': 1.2,
            'innovation': 1.3,
            'network_stability': 1.1,
            'data_availability': 1.2
        }
        self.validation_thresholds = {
            'min_participation': 0.1,
            'min_success_rate': 0.8,
            'min_availability': 0.95,
            'max_consecutive_validations': 3
        }
        self.reputation_decay_factor = 0.99
        self.collusion_threshold = 0.8
        self.validator_history: List[Tuple[str, datetime, int]] = []  # node_id, timestamp, shard_id
        self.validation_stats: Dict[str, Dict] = {}
        self.performance_metrics: Dict[str, float] = {
            'average_block_time': 0.0,
            'total_validations': 0,
            'successful_validations': 0,
            'collusion_detections': 0
        }

    def calculate_cooperation_score(self, node: Node, shard_id: Optional[int] = None) -> float:
        """Calculate a node's cooperation score based on multiple factors."""
        if not node.can_validate(shard_id):
            return 0.0

        base_score = sum(
            score * self.reputation_weights.get(category, 1.0)
            for category, score in node.reputation_scores.items()
        )
        
        diversity_factor = self._calculate_diversity_factor(node)
        consistency_factor = self._calculate_consistency_factor(node)
        performance_factor = self._calculate_performance_factor(node)
        shard_factor = self._calculate_shard_factor(node, shard_id) if shard_id else 1.0
        
        final_score = (base_score * diversity_factor * consistency_factor * 
                      performance_factor * shard_factor)
                      
        return max(0, final_score)

    def _calculate_diversity_factor(self, node: Node) -> float:
        """Calculate diversity factor based on cooperative interactions."""
        recent_interactions = node.cooperative_interactions[-100:]  # Last 100 interactions
        if not recent_interactions:
            return 1.0
            
        unique_coops = len(set(recent_interactions))
        total_interactions = len(recent_interactions)
        
        diversity_score = unique_coops / total_interactions
        normalized_score = 1.0 + math.log(diversity_score + 1)
        
        return max(self.validation_thresholds['min_participation'], normalized_score)

    def _calculate_consistency_factor(self, node: Node) -> float:
        """Calculate consistency factor based on validation history."""
        if not node.validation_history:
            return 1.0
            
        recent_validations = node.validation_history[-50:]  # Last 50 validations
        successful = sum(1 for v in recent_validations 
                        if v.get('evidence', {}).get('success', False))
        
        success_rate = successful / len(recent_validations)
        return max(self.validation_thresholds['min_success_rate'], success_rate)

    def _calculate_performance_factor(self, node: Node) -> float:
        """Calculate performance factor based on node metrics."""
        metrics = node.performance_metrics
        if not metrics:
            return 1.0

        factors = [
            metrics.get('availability', 0) / 100,
            metrics.get('validation_success_rate', 0) / 100,
            metrics.get('network_reliability', 0) / 100
        ]
        
        avg_performance = sum(factors) / len(factors)
        return max(self.validation_thresholds['min_availability'], avg_performance)

    def _calculate_shard_factor(self, node: Node, shard_id: int) -> float:
        """Calculate shard-specific performance factor."""
        if shard_id not in node.active_shards:
            return 0.0
            
        # Consider time spent in shard
        time_in_shard = (datetime.now() - node.active_shards[shard_id]).total_seconds()
        shard_experience = min(1.0, time_in_shard / (24 * 3600))  # Max out at 1 day
        
        return 0.5 + (0.5 * shard_experience)

    def select_validator(self, nodes: List[Node], shard_id: Optional[int] = None) -> Optional[Node]:
        """Select the next validator using weighted random selection."""
        eligible_nodes = [
            node for node in nodes 
            if self._is_eligible_validator(node, shard_id)
        ]
        
        if not eligible_nodes:
            return None
            
        # Calculate scores for eligible nodes
        scores = [
            self.calculate_cooperation_score(node, shard_id) 
            for node in eligible_nodes
        ]
        total_score = sum(scores)
        
        if total_score <= 0:
            # Fallback to random selection if all scores are 0
            selected = random.choice(eligible_nodes)
        else:
            # Weighted random selection
            selection_point = random.uniform(0, total_score)
            current_sum = 0
            selected = eligible_nodes[-1]  # Default to last node
            
            for node, score in zip(eligible_nodes, scores):
                current_sum += score
                if current_sum >= selection_point:
                    selected = node
                    break
        
        # Record selection
        self._record_validator_selection(selected, shard_id)
        selected.enter_cooldown(self.cooldown_blocks)
        
        return selected

    def _is_eligible_validator(self, node: Node, shard_id: Optional[int] = None) -> bool:
        """Check if a node is eligible to validate blocks."""
        if not node.can_validate(shard_id):
            return False
            
        # Check minimum reputation requirement
        if node.get_total_reputation() < self.min_reputation:
            return False
            
        # Check performance factors
        performance_factor = self._calculate_performance_factor(node)
        if performance_factor < self.validation_thresholds['min_availability']:
            return False
            
        # Check recent selections to prevent concentration
        recent_validations = [
            v[0] for v in self.validator_history[-10:]
            if v[0] == node.node_id
        ]
        if len(recent_validations) >= self.validation_thresholds['max_consecutive_validations']:
            return False
            
        return True

    def _record_validator_selection(self, node: Node, shard_id: Optional[int]) -> None:
        """Record validator selection for statistics."""
        self.validator_history.append((node.node_id, datetime.now(), shard_id))
        if len(self.validator_history) > 1000:
            self.validator_history = self.validator_history[-1000:]
            
        if node.node_id not in self.validation_stats:
            self.validation_stats[node.node_id] = {
                'selections': 0,
                'successful_validations': 0,
                'last_selected': None,
                'shard_validations': {}
            }
            
        stats = self.validation_stats[node.node_id]
        stats['selections'] += 1
        stats['last_selected'] = datetime.now()
        
        if shard_id is not None:
            shard_stats = stats['shard_validations'].setdefault(shard_id, {
                'selections': 0,
                'successful': 0
            })
            shard_stats['selections'] += 1

    def validate_block(self, block: Block, previous_block: Optional[Block], 
                      validator: Node) -> bool:
        """Validate a proposed block."""
        try:
            # Verify validator eligibility
            if not self._is_eligible_validator(validator, block.shard_id):
                return False
                
            # Perform block validation
            if not block.validate(previous_block):
                return False
                
            # Verify cross-shard references if present
            if block.cross_shard_refs and not self._validate_cross_shard_refs(block):
                return False
                
            # Update statistics
            self._update_validation_stats(validator, block, True)
            
            return True
            
        except Exception as e:
            logger.error(f"Block validation failed: {e}")
            self._update_validation_stats(validator, block, False)
            return False

    def _validate_cross_shard_refs(self, block: Block) -> bool:
        """Validate cross-shard references in a block."""
        # This would include validation logic for cross-shard references
        # Implementation depends on specific cross-shard protocol
        return True

    def _update_validation_stats(self, validator: Node, block: Block, 
                               success: bool) -> None:
        """Update validation statistics."""
        stats = self.validation_stats.get(validator.node_id, {
            'selections': 0,
            'successful_validations': 0,
            'shard_validations': {}
        })
        
        if success:
            stats['successful_validations'] += 1
            
        if block.shard_id is not None:
            shard_stats = stats['shard_validations'].setdefault(block.shard_id, {
                'selections': 0,
                'successful': 0
            })
            if success:
                shard_stats['successful'] += 1
                
        self.validation_stats[validator.node_id] = stats

class SmartContract:
    """Represents a smart contract in the ICN blockchain."""
    
    def __init__(self, contract_id: str, code: str, creator: str, 
                 mana_cost: int = 10, version: str = "1.0"):
        self.contract_id = contract_id
        self.code = code
        self.creator = creator
        self.state: Dict = {}
        self.mana_cost = mana_cost
        self.version = version
        self.created_at = datetime.now()
        self.last_executed = None
        self.execution_count = 0
        self.total_mana_consumed = 0
        self.execution_history: List[Dict] = []
        self.metadata: Dict = {
            'created_at': self.created_at,
            'version': version,
            'creator': creator,
            'description': '',
            'tags': set()
        }
        self.dependencies: Set[str] = set()
        self.allowed_callers: Set[str] = {creator}
        self.restrictions: Dict = {
            'max_state_size': 1024 * 1024,  # 1MB
            'max_execution_time': 5,  # seconds
            'max_mana_per_execution': 100,
            'max_daily_executions': 1000
        }
        self.daily_executions = 0
        self.last_reset = datetime.now()

    def execute(self, input_data: Dict, available_mana: int) -> Dict:
        """Execute the smart contract code with safety checks."""
        # Reset daily execution counter if needed
        self._reset_daily_executions()
        
        # Validate execution conditions
        validation_result = self._validate_execution(input_data, available_mana)
        if validation_result.get("error"):
            return validation_result
            
        execution_start = time.time()
        try:
            # Set up secure execution environment
            local_namespace = self._setup_execution_environment(input_data)
            
            # Execute contract code
            exec(self.code, {}, local_namespace)
            
            # Validate execution result
            if "execute" not in local_namespace:
                return {"error": "Contract missing execute function"}
                
            # Check execution time
            if time.time() - execution_start > self.restrictions['max_execution_time']:
                return {"error": "Execution time limit exceeded"}
                
            # Execute contract function
            result = local_namespace["execute"](input_data, self.state)
            
            # Update contract metrics
            self._update_execution_metrics(execution_start)
            
            return {
                "state": self.state,
                "result": result,
                "mana_used": self.mana_cost,
                "execution_time": time.time() - execution_start
            }
            
        except Exception as e:
            logger.error(f"Contract execution failed: {e}")
            return {"error": str(e)}

    def _validate_execution(self, input_data: Dict, available_mana: int) -> Dict:
        """Validate execution conditions."""
        if self.daily_executions >= self.restrictions['max_daily_executions']:
            return {"error": "Daily execution limit exceeded"}
            
        if available_mana < self.mana_cost:
            return {"error": "Insufficient mana"}
            
        if len(str(self.state)) > self.restrictions['max_state_size']:
            return {"error": "State size limit exceeded"}
            
        return {}

    def _setup_execution_environment(self, input_data: Dict) -> Dict:
        """Set up secure execution environment with allowed variables."""
        return {
            "input": input_data,
            "state": self.state.copy(),
            "contract_id": self.contract_id,
            "creator": self.creator,
            "version": self.version,
            "metadata": self.metadata
        }

    def _update_execution_metrics(self, execution_start: float) -> None:
        """Update contract execution metrics."""
        self.last_executed = datetime.now()
        self.execution_count += 1
        self.daily_executions += 1
        self.total_mana_consumed += self.mana_cost
        
        execution_record = {
            'timestamp': self.last_executed,
            'execution_time': time.time() - execution_start,
            'mana_used': self.mana_cost,
            'state_size': len(str(self.state))
        }
        
        self.execution_history.append(execution_record)
        if len(self.execution_history) > 1000:
            self.execution_history = self.execution_history[-1000:]

    def _reset_daily_executions(self) -> None:
        """Reset daily execution counter if needed."""
        current_time = datetime.now()
        if (current_time - self.last_reset).days >= 1:
            self.daily_executions = 0
            self.last_reset = current_time

    def update_metadata(self, metadata: Dict) -> bool:
        """Update contract metadata."""
        try:
            self.metadata.update(metadata)
            return True
        except Exception as e:
            logger.error(f"Failed to update metadata: {e}")
            return False

    def add_dependency(self, contract_id: str) -> bool:
        """Add a contract dependency."""
        self.dependencies.add(contract_id)
        return True

    def authorize_caller(self, caller_id: str) -> bool:
        """Add an authorized caller."""
        self.allowed_callers.add(caller_id)
        return True

    def revoke_caller(self, caller_id: str) -> bool:
        """Revoke caller authorization."""
        if caller_id == self.creator:
            return False
        self.allowed_callers.discard(caller_id)
        return True

    def get_metrics(self) -> Dict:
        """Get comprehensive contract metrics."""
        return {
            'contract_id': self.contract_id,
            'version': self.version,
            'creator': self.creator,
            'created_at': self.created_at.isoformat(),
            'last_executed': self.last_executed.isoformat() if self.last_executed else None,
            'execution_count': self.execution_count,
            'daily_executions': self.daily_executions,
            'total_mana_consumed': self.total_mana_consumed,
            'average_mana_per_execution': (
                self.total_mana_consumed / self.execution_count 
                if self.execution_count > 0 else 0
            ),
            'state_size': len(str(self.state)),
            'dependencies': list(self.dependencies),
            'authorized_callers': len(self.allowed_callers),
            'restrictions': self.restrictions
        }

    def to_dict(self) -> Dict:
        """Convert contract to dictionary format."""
        return {
            'contract_id': self.contract_id,
            'code': self.code,
            'creator': self.creator,
            'state': self.state,
            'mana_cost': self.mana_cost,
            'version': self.version,
            'metadata': self.metadata,
            'dependencies': list(self.dependencies),
            'allowed_callers': list(self.allowed_callers),
            'restrictions': self.restrictions,
            'metrics': self.get_metrics()
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'SmartContract':
        """Create contract from dictionary."""
        contract = cls(
            contract_id=data['contract_id'],
            code=data['code'],
            creator=data['creator'],
            mana_cost=data['mana_cost'],
            version=data['version']
        )
        contract.state = data['state']
        contract.metadata = data['metadata']
        contract.dependencies = set(data['dependencies'])
        contract.allowed_callers = set(data['allowed_callers'])
        contract.restrictions = data['restrictions']
        return contract


class Blockchain:
    """Main blockchain implementation for ICN."""
    
    def __init__(self, num_shards: int = 4, initial_mana: int = 1000, 
                 mana_regen_rate: int = 10):
        self.num_shards = num_shards
        self.shards: Dict[int, Shard] = {
            i: Shard(i) for i in range(num_shards)
        }
        self.nodes: List[Node] = []
        self.consensus = ProofOfCooperation()
        self.contracts: Dict[str, SmartContract] = {}
        self.cooperative_mana = initial_mana
        self.mana_regen_rate = mana_regen_rate
        self.cross_shard_queue: Dict[int, List[Transaction]] = {
            i: [] for i in range(num_shards)
        }
        self.metadata: Dict = {
            'creation_time': datetime.now(),
            'last_update': datetime.now(),
            'version': "1.0",
            'network_name': "ICN MainNet",
            'network_id': hashlib.sha256(str(time.time()).encode()).hexdigest()[:8]
        }
        self.metrics: Dict = {
            'total_transactions': 0,
            'total_blocks': 0,
            'average_block_time': 0,
            'active_nodes': 0,
            'total_mana_consumed': 0
        }
        self.state: str = "active"
        self._initialize_network()

    def _initialize_network(self) -> None:
        """Initialize network configuration."""
        logger.info(f"Initializing ICN network {self.metadata['network_id']}")
        self._update_metrics()

    def add_node(self, node: Node) -> bool:
        """Add a new node to the network."""
        if any(n.node_id == node.node_id for n in self.nodes):
            return False
            
        self.nodes.append(node)
        self.metrics['active_nodes'] = len(
            [n for n in self.nodes if n.metadata['status'] == "active"]
        )
        logger.info(f"Added node {node.node_id} to network")
        return True

    def remove_node(self, node_id: str) -> bool:
        """Remove a node from the network."""
        node = self._get_node(node_id)
        if not node:
            return False
            
        self.nodes = [n for n in self.nodes if n.node_id != node_id]
        self.metrics['active_nodes'] = len(
            [n for n in self.nodes if n.metadata['status'] == "active"]
        )
        logger.info(f"Removed node {node_id} from network")
        return True

    def _get_node(self, node_id: str) -> Optional[Node]:
        """Get a node by its ID."""
        return next((n for n in self.nodes if n.node_id == node_id), None)

    def add_transaction(self, transaction: Dict) -> bool:
        """Add a new transaction to the network."""
        # Determine shard for transaction
        shard_id = self._calculate_shard_id(transaction)
        
        tx = Transaction(
            sender=transaction['sender'],
            receiver=transaction['receiver'],
            action=transaction['action'],
            data=transaction['data'],
            shard_id=shard_id
        )
        
        # Add to appropriate shard
        if self.shards[shard_id].add_transaction(tx):
            self.metrics['total_transactions'] += 1
            return True
        return False

    def _calculate_shard_id(self, transaction: Dict) -> int:
        """Calculate which shard should handle a transaction."""
        # Simple hash-based sharding
        tx_hash = hashlib.sha256(
            json.dumps(transaction, sort_keys=True).encode()
        ).hexdigest()
        return int(tx_hash, 16) % self.num_shards

    def create_block(self, shard_id: int) -> Optional[Block]:
        """Create a new block in specified shard."""
        shard = self.shards.get(shard_id)
        if not shard:
            return None
            
        # Select validator
        validator = self.consensus.select_validator(self.nodes, shard_id)
        if not validator:
            return None
            
        # Create block
        block = shard.create_block(validator.node_id)
        if not block:
            return None
            
        # Process cross-shard references
        self._add_cross_shard_refs(block)
        
        return block

    def _add_cross_shard_refs(self, block: Block) -> None:
        """Add cross-shard references to block."""
        cross_shard_txs = [
            tx for tx in block.transactions 
            if self._is_cross_shard_transaction(tx)
        ]
        
        for tx in cross_shard_txs:
            ref = self._create_cross_shard_ref(tx)
            if ref:
                block.cross_shard_refs.append(ref)

    def _is_cross_shard_transaction(self, transaction: Transaction) -> bool:
        """Check if transaction involves multiple shards."""
        return 'target_shard' in transaction.data

    def _create_cross_shard_ref(self, transaction: Transaction) -> Optional[str]:
        """Create a reference for cross-shard transaction."""
        try:
            ref_data = {
                'transaction_id': transaction.transaction_id,
                'source_shard': transaction.shard_id,
                'target_shard': transaction.data.get('target_shard'),
                'timestamp': transaction.timestamp.isoformat()
            }
            return hashlib.sha256(
                json.dumps(ref_data, sort_keys=True).encode()
            ).hexdigest()
        except Exception as e:
            logger.error(f"Failed to create cross-shard reference: {e}")
            return None

    def add_block(self, block: Block) -> bool:
        """Add a validated block to the network."""
        shard = self.shards.get(block.shard_id)
        if not shard:
            return False
            
        # Validate block
        validator = self._get_node(block.validator)
        if not validator:
            return False
            
        if not self.consensus.validate_block(block, shard.chain[-1], validator):
            return False
            
        # Add block to shard
        if shard.add_block(block):
            self._process_block_addition(block)
            return True
            
        return False

    def _process_block_addition(self, block: Block) -> None:
        """Process successful block addition."""
        self.metrics['total_blocks'] += 1
        self._update_metrics()
        
        # Process cross-shard references
        if block.cross_shard_refs:
            self._process_cross_shard_refs(block)
            
        logger.info(
            f"Added block {block.index} to shard {block.shard_id}")
                def _process_cross_shard_refs(self, block: Block) -> None:
        """Process cross-shard references in a block."""
        for ref in block.cross_shard_refs:
            ref_data = self._parse_cross_shard_ref(ref)
            if ref_data:
                target_shard = self.shards.get(ref_data['target_shard'])
                if target_shard:
                    tx = self._create_cross_shard_transaction(ref_data)
                    target_shard.add_transaction(tx)

    def _parse_cross_shard_ref(self, ref: str) -> Optional[Dict]:
        """Parse cross-shard reference into transaction data."""
        try:
            ref_data = json.loads(hashlib.sha256(ref.encode()).hexdigest())
            return ref_data
        except Exception as e:
            logger.error(f"Failed to parse cross-shard reference: {e}")
            return None

    def _create_cross_shard_transaction(self, ref_data: Dict) -> Transaction:
        """Create a cross-shard transaction from reference data."""
        return Transaction(
            sender='cross-shard',
            receiver='target-shard',
            action='cross-shard-transfer',
            data=ref_data,
            shard_id=ref_data['target_shard']
        )

    def add_smart_contract(self, contract: SmartContract) -> bool:
        """Add a new smart contract to the network."""
        if contract.contract_id in self.contracts:
            return False

        self.contracts[contract.contract_id] = contract
        logger.info(f"Added smart contract {contract.contract_id} to network")
        return True

    def execute_smart_contract(self, contract_id: str, input_data: Dict) -> Dict:
        """Execute a smart contract with given input data."""
        contract = self.contracts.get(contract_id)
        if not contract:
            return {"error": "Contract not found"}
        
        # Check available mana
        if self.cooperative_mana < contract.mana_cost:
            return {"error": "Insufficient cooperative mana"}
        
        result = contract.execute(input_data, self.cooperative_mana)
        if "error" not in result:
            self.cooperative_mana -= contract.mana_cost
            self.metrics['total_mana_consumed'] += contract.mana_cost
        return result

    def regenerate_mana(self) -> None:
        """Regenerate cooperative mana over time."""
        self.cooperative_mana = min(
            self.cooperative_mana + self.mana_regen_rate,
            1000  # Max mana limit for demonstration purposes
        )
        self._update_metrics()

    def _update_metrics(self) -> None:
        """Update blockchain network metrics."""
        self.metadata['last_update'] = datetime.now().isoformat()
        self.metrics['average_block_time'] = sum(
            shard.metrics['average_block_time'] for shard in self.shards.values()
        ) / max(1, len(self.shards))

    def to_dict(self) -> Dict:
        """Convert blockchain to dictionary format."""
        return {
            'num_shards': self.num_shards,
            'nodes': [node.to_dict() for node in self.nodes],
            'contracts': {cid: contract.to_dict() for cid, contract in self.contracts.items()},
            'cooperative_mana': self.cooperative_mana,
            'metrics': self.metrics,
            'metadata': self.metadata
        }

    @classmethod
    def from_dict(cls, data: Dict) -> 'Blockchain':
        """Create blockchain from dictionary."""
        blockchain = cls(
            num_shards=data['num_shards'],
            initial_mana=data['cooperative_mana']
        )
        blockchain.nodes = [Node.from_dict(node) for node in data['nodes']]
        blockchain.contracts = {
            cid: SmartContract.from_dict(contract) 
            for cid, contract in data['contracts'].items()
        }
        blockchain.cooperative_mana = data['cooperative_mana']
        blockchain.metrics = data['metrics']
        blockchain.metadata = data['metadata']
        return blockchain




# ==================== /home/matt/icn-prototype/blockchain/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/utils/metrics.py ====================



# ==================== /home/matt/icn-prototype/blockchain/utils/validation.py ====================



# ==================== /home/matt/icn-prototype/blockchain/utils/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/utils/crypto.py ====================

# blockchain/utils/crypto.py

from typing import Tuple, Optional
import hashlib
import logging
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding, utils
from cryptography.hazmat.primitives import serialization
from cryptography.exceptions import InvalidSignature
from datetime import datetime

logger = logging.getLogger(__name__)


class CryptoUtils:
    """
    Utility class for cryptographic operations.

    Provides methods for:
    - Key generation and management
    - Signing and verification
    - Hashing
    - Encryption and decryption
    """

    @staticmethod
    def generate_key_pair(key_size: int = 2048) -> Tuple[bytes, bytes]:
        """
        Generate a new RSA key pair.

        Args:
            key_size: Size of the key in bits

        Returns:
            Tuple of (private_key, public_key) in PEM format
        """
        try:
            # Generate private key
            private_key = rsa.generate_private_key(
                public_exponent=65537, key_size=key_size
            )

            # Get public key
            public_key = private_key.public_key()

            # Serialize keys
            private_pem = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            )

            public_pem = public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo,
            )

            return private_pem, public_pem

        except Exception as e:
            logger.error(f"Key generation failed: {str(e)}")
            raise

    @staticmethod
    def sign_message(message: bytes, private_key_pem: bytes) -> bytes:
        """
        Sign a message using a private key.

        Args:
            message: Message to sign
            private_key_pem: Private key in PEM format

        Returns:
            bytes: Signature
        """
        try:
            # Load private key
            private_key = serialization.load_pem_private_key(
                private_key_pem, password=None
            )

            # Create signature
            signature = private_key.sign(
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH,
                ),
                hashes.SHA256(),
            )

            return signature

        except Exception as e:
            logger.error(f"Signing failed: {str(e)}")
            raise

    @staticmethod
    def verify_signature(
        message: bytes, signature: bytes, public_key_pem: bytes
    ) -> bool:
        """
        Verify a signature using a public key.

        Args:
            message: Original message
            signature: Signature to verify
            public_key_pem: Public key in PEM format

        Returns:
            bool: True if signature is valid
        """
        try:
            # Load public key
            public_key = serialization.load_pem_public_key(public_key_pem)

            # Verify signature
            public_key.verify(
                signature,
                message,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH,
                ),
                hashes.SHA256(),
            )

            return True

        except InvalidSignature:
            return False
        except Exception as e:
            logger.error(f"Verification failed: {str(e)}")
            return False

    @staticmethod
    def hash_data(data: bytes) -> str:
        """
        Create SHA-256 hash of data.

        Args:
            data: Data to hash

        Returns:
            str: Hexadecimal hash string
        """
        try:
            return hashlib.sha256(data).hexdigest()
        except Exception as e:
            logger.error(f"Hashing failed: {str(e)}")
            raise

    @staticmethod
    def double_hash(data: bytes) -> str:
        """
        Create double SHA-256 hash (as used in Bitcoin).

        Args:
            data: Data to hash

        Returns:
            str: Hexadecimal double hash string
        """
        try:
            return hashlib.sha256(hashlib.sha256(data).digest()).hexdigest()
        except Exception as e:
            logger.error(f"Double hashing failed: {str(e)}")
            raise

    @staticmethod
    def merkle_root(hash_list: list) -> Optional[str]:
        """
        Calculate Merkle root from list of hashes.

        Args:
            hash_list: List of hash strings

        Returns:
            str: Merkle root hash or None if list is empty
        """
        try:
            if not hash_list:
                return None

            if len(hash_list) == 1:
                return hash_list[0]

            # Ensure even number of hashes
            if len(hash_list) % 2 == 1:
                hash_list.append(hash_list[-1])

            # Pair hashes and hash together
            new_hash_list = []
            for i in range(0, len(hash_list), 2):
                combined = hash_list[i] + hash_list[i + 1]
                new_hash = hashlib.sha256(combined.encode()).hexdigest()
                new_hash_list.append(new_hash)

            # Recurse until single hash remains
            return CryptoUtils.merkle_root(new_hash_list)

        except Exception as e:
            logger.error(f"Merkle root calculation failed: {str(e)}")
            raise

    @staticmethod
    def create_timestamp() -> str:
        """Create RFC 3339 formatted timestamp."""
        try:
            return datetime.utcnow().isoformat() + "Z"
        except Exception as e:
            logger.error(f"Timestamp creation failed: {str(e)}")
            raise

    @classmethod
    def verify_proof_of_work(cls, block_header: bytes, difficulty: int) -> bool:
        """
        Verify proof of work for a block.

        Args:
            block_header: Block header data
            difficulty: Number of leading zeros required

        Returns:
            bool: True if proof of work is valid
        """
        try:
            block_hash = cls.hash_data(block_header)
            return block_hash.startswith("0" * difficulty)
        except Exception as e:
            logger.error(f"Proof of work verification failed: {str(e)}")
            return False


# ==================== /home/matt/icn-prototype/blockchain/core/node.py ====================

# blockchain/core/node.py

from __future__ import annotations
from datetime import datetime, timedelta
from typing import Dict, List, Set, Optional
import logging
import json

logger = logging.getLogger(__name__)


class Node:
    """
    Represents a node in the ICN network.

    A node is a participant in the network that can validate transactions,
    participate in consensus, and maintain portions of the blockchain.
    """

    def __init__(
        self,
        node_id: str,
        cooperative_id: Optional[str] = None,
        initial_stake: float = 10.0,
    ):
        self.node_id = node_id
        self.cooperative_id = cooperative_id
        self.reputation_scores = {
            "validation": 0.0,
            "proposal_creation": 0.0,
            "voting": 0.0,
            "resource_sharing": 0.0,
            "cooperative_growth": 0.0,
            "community_building": 0.0,
            "conflict_resolution": 0.0,
            "transaction_validation": 0.0,
            "data_availability": 0.0,
            "network_stability": 0.0,
            "innovation": 0.0,
            "sustainability": 0.0,
        }
        self.stake = initial_stake
        self.cooperative_interactions: List[str] = []
        self.validation_history: List[Dict] = []
        self.resource_usage: Dict[str, float] = {
            "computation": 0.0,
            "storage": 0.0,
            "bandwidth": 0.0,
            "memory": 0.0,
            "energy": 0.0,
        }
        self.shard_assignments: Set[int] = set()
        self.active_shards: Dict[int, datetime] = {}
        self.last_validation = datetime.now().timestamp()
        self.total_validations = 0
        self.cooldown = 0
        self.performance_metrics: Dict[str, float] = {
            "response_time": 0.0,
            "availability": 100.0,
            "validation_success_rate": 100.0,
            "network_reliability": 100.0,
        }
        self.metadata: Dict = {
            "creation_time": datetime.now(),
            "last_active": datetime.now(),
            "version": "1.0",
            "capabilities": set(),
            "status": "active",
        }

    def update_reputation(
        self,
        category: str,
        score: float,
        cooperative_id: Optional[str] = None,
        evidence: Optional[Dict] = None,
    ) -> bool:
        """Update reputation score for a category with evidence."""
        try:
            if category not in self.reputation_scores:
                logger.error(f"Invalid reputation category: {category}")
                return False

            old_score = self.reputation_scores[category]
            self.reputation_scores[category] = max(0, old_score + score)

            if cooperative_id:
                self.cooperative_interactions.append(cooperative_id)

            if evidence:
                self.validation_history.append(
                    {
                        "timestamp": datetime.now(),
                        "category": category,
                        "score_change": score,
                        "evidence": evidence,
                    }
                )

            self.metadata["last_active"] = datetime.now()

            # Trim history if needed
            if len(self.cooperative_interactions) > 1000:
                self.cooperative_interactions = self.cooperative_interactions[-1000:]
            if len(self.validation_history) > 1000:
                self.validation_history = self.validation_history[-1000:]

            return True

        except Exception as e:
            logger.error(f"Failed to update reputation: {str(e)}")
            return False

    def assign_to_shard(self, shard_id: int) -> bool:
        """Assign node to a shard."""
        if len(self.active_shards) >= 3:  # Maximum 3 active shards per node
            logger.warning(f"Node {self.node_id} already assigned to maximum shards")
            return False

        self.shard_assignments.add(shard_id)
        self.active_shards[shard_id] = datetime.now()
        logger.info(f"Node {self.node_id} assigned to shard {shard_id}")
        return True

    def remove_from_shard(self, shard_id: int) -> bool:
        """Remove node from a shard."""
        if shard_id in self.active_shards:
            del self.active_shards[shard_id]
            self.shard_assignments.discard(shard_id)
            logger.info(f"Node {self.node_id} removed from shard {shard_id}")
            return True
        return False

    def can_validate(self, shard_id: Optional[int] = None) -> bool:
        """Check if node can validate blocks."""
        current_time = datetime.now().timestamp()

        # Basic validation checks
        if self.cooldown > 0:
            return False

        if (
            current_time - self.last_validation < 10
        ):  # 10 second minimum between validations
            return False

        if self.metadata["status"] != "active":
            return False

        # Shard-specific validation
        if shard_id is not None:
            if shard_id not in self.active_shards:
                return False

            shard_time = self.active_shards[shard_id]
            if (datetime.now() - shard_time).total_seconds() > 3600:  # 1 hour timeout
                return False

        return True

    def enter_cooldown(self, cooldown_period: int) -> None:
        """Put node into cooldown period."""
        self.cooldown = cooldown_period
        self.metadata["status"] = "cooldown"
        logger.info(
            f"Node {self.node_id} entered cooldown for {cooldown_period} periods"
        )

    def update_metrics(self, metrics: Dict[str, float]) -> None:
        """Update node performance metrics."""
        self.performance_metrics.update(metrics)
        self.metadata["last_active"] = datetime.now()

        # Calculate validation success rate
        if self.total_validations > 0:
            success_rate = (
                len(
                    [
                        v
                        for v in self.validation_history
                        if v.get("evidence", {}).get("success", False)
                    ]
                )
                / self.total_validations
                * 100
            )
            self.performance_metrics["validation_success_rate"] = success_rate

    def get_total_reputation(self) -> float:
        """Calculate total reputation across all categories."""
        return sum(self.reputation_scores.values())

    def record_resource_usage(self, usage: Dict[str, float]) -> None:
        """Record resource usage metrics."""
        for resource, amount in usage.items():
            if resource in self.resource_usage:
                self.resource_usage[resource] += amount

        # Update availability based on resource usage
        total_usage = sum(self.resource_usage.values())
        self.performance_metrics["availability"] = max(0, 100 - (total_usage / 5))

    def to_dict(self) -> Dict:
        """Convert node state to dictionary."""
        return {
            "node_id": self.node_id,
            "cooperative_id": self.cooperative_id,
            "reputation_scores": self.reputation_scores,
            "stake": self.stake,
            "shard_assignments": list(self.shard_assignments),
            "active_shards": {k: v.isoformat() for k, v in self.active_shards.items()},
            "performance_metrics": self.performance_metrics,
            "resource_usage": self.resource_usage,
            "metadata": {
                **self.metadata,
                "creation_time": self.metadata["creation_time"].isoformat(),
                "last_active": self.metadata["last_active"].isoformat(),
                "capabilities": list(self.metadata["capabilities"]),
            },
            "status": self.metadata["status"],
        }

    @classmethod
    def from_dict(cls, data: Dict) -> Node:
        """Create node from dictionary."""
        try:
            node = cls(
                node_id=data["node_id"],
                cooperative_id=data["cooperative_id"],
                initial_stake=data["stake"],
            )
            node.reputation_scores = data["reputation_scores"]
            node.shard_assignments = set(data["shard_assignments"])
            node.active_shards = {
                int(k): datetime.fromisoformat(v)
                for k, v in data["active_shards"].items()
            }
            node.performance_metrics = data["performance_metrics"]
            node.resource_usage = data["resource_usage"]

            # Restore metadata
            node.metadata.update(data["metadata"])
            node.metadata["creation_time"] = datetime.fromisoformat(
                data["metadata"]["creation_time"]
            )
            node.metadata["last_active"] = datetime.fromisoformat(
                data["metadata"]["last_active"]
            )
            node.metadata["capabilities"] = set(data["metadata"]["capabilities"])

            return node

        except Exception as e:
            logger.error(f"Failed to create node from dictionary: {str(e)}")
            raise ValueError("Invalid node data")

    def __str__(self) -> str:
        """Return a human-readable string representation of the node."""
        return (
            f"Node(id={self.node_id}, "
            f"coop={self.cooperative_id}, "
            f"status={self.metadata['status']}, "
            f"rep={self.get_total_reputation():.2f})"
        )


# ==================== /home/matt/icn-prototype/blockchain/core/block.py ====================

# blockchain/core/block.py

from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Dict, Optional
import hashlib
import json
import logging
from .transaction import Transaction

logger = logging.getLogger(__name__)


@dataclass
class Block:
    """
    Represents a block in the ICN blockchain.

    A block contains a list of transactions and forms part of the blockchain.
    Each block includes cryptographic links to the previous block to maintain
    chain integrity.
    """

    index: int
    previous_hash: str
    timestamp: datetime
    transactions: List[Transaction]
    validator: str
    shard_id: int
    hash: str = ""
    nonce: int = 0
    merkle_root: str = ""
    cross_shard_refs: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    version: str = "1.0"

    def __post_init__(self) -> None:
        """Initialize block after creation."""
        if not self.merkle_root:
            self.merkle_root = self.calculate_merkle_root()
        if not self.hash:
            self.hash = self.calculate_hash()
        self.metadata["created_at"] = datetime.now().isoformat()

    def calculate_merkle_root(self) -> str:
        """Calculate the Merkle root of transactions."""
        if not self.transactions:
            return hashlib.sha256(b"empty").hexdigest()

        leaves = [
            hashlib.sha256(json.dumps(tx.to_dict()).encode()).hexdigest()
            for tx in self.transactions
        ]

        while len(leaves) > 1:
            if len(leaves) % 2 == 1:
                leaves.append(leaves[-1])
            leaves = [
                hashlib.sha256((a + b).encode()).hexdigest()
                for a, b in zip(leaves[::2], leaves[1::2])
            ]

        return leaves[0]

    def calculate_hash(self) -> str:
        """Calculate the hash of the block."""
        block_dict = {
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp.isoformat(),
            "merkle_root": self.merkle_root,
            "validator": self.validator,
            "nonce": self.nonce,
            "shard_id": self.shard_id,
            "cross_shard_refs": self.cross_shard_refs,
            "version": self.version,
        }
        return hashlib.sha256(
            json.dumps(block_dict, sort_keys=True).encode()
        ).hexdigest()

    def validate(self, previous_block: Optional["Block"] = None) -> bool:
        """Validate block structure and consistency."""
        try:
            # Validate block hash
            if self.hash != self.calculate_hash():
                logger.error("Invalid block hash")
                return False

            # Validate merkle root
            if self.merkle_root != self.calculate_merkle_root():
                logger.error("Invalid merkle root")
                return False

            # Validate timestamp
            now = datetime.now()
            if self.timestamp > now + timedelta(minutes=5):
                logger.error("Block timestamp is in the future")
                return False

            # Validate transactions
            if not all(isinstance(tx, Transaction) for tx in self.transactions):
                logger.error("Invalid transaction type in block")
                return False

            if not all(tx.validate() for tx in self.transactions):
                logger.error("Invalid transaction in block")
                return False

            # Validate against previous block if provided
            if previous_block:
                if self.previous_hash != previous_block.hash:
                    logger.error("Block previous_hash doesn't match previous block")
                    return False

                if self.index != previous_block.index + 1:
                    logger.error("Block index is not sequential")
                    return False

                if self.timestamp <= previous_block.timestamp:
                    logger.error("Block timestamp is not after previous block")
                    return False

            return True

        except Exception as e:
            logger.error(f"Block validation failed: {str(e)}")
            return False

    def add_transaction(self, transaction: Transaction) -> bool:
        """Add a transaction to the block."""
        if not transaction.validate():
            logger.error("Cannot add invalid transaction to block")
            return False

        if transaction.shard_id != self.shard_id:
            logger.error("Transaction shard_id doesn't match block")
            return False

        self.transactions.append(transaction)
        self.merkle_root = self.calculate_merkle_root()
        self.hash = self.calculate_hash()
        return True

    def to_dict(self) -> Dict:
        """Convert block to dictionary format."""
        return {
            "index": self.index,
            "previous_hash": self.previous_hash,
            "timestamp": self.timestamp.isoformat(),
            "transactions": [tx.to_dict() for tx in self.transactions],
            "validator": self.validator,
            "hash": self.hash,
            "nonce": self.nonce,
            "merkle_root": self.merkle_root,
            "shard_id": self.shard_id,
            "cross_shard_refs": self.cross_shard_refs,
            "metadata": self.metadata,
            "version": self.version,
        }

    @classmethod
    def from_dict(cls, data: Dict) -> "Block":
        """Create block from dictionary."""
        try:
            transactions = [Transaction.from_dict(tx) for tx in data["transactions"]]
            timestamp = datetime.fromisoformat(data["timestamp"])

            return cls(
                index=data["index"],
                previous_hash=data["previous_hash"],
                timestamp=timestamp,
                transactions=transactions,
                validator=data["validator"],
                shard_id=data["shard_id"],
                hash=data["hash"],
                nonce=data["nonce"],
                merkle_root=data["merkle_root"],
                cross_shard_refs=data.get("cross_shard_refs", []),
                metadata=data.get("metadata", {}),
                version=data.get("version", "1.0"),
            )
        except Exception as e:
            logger.error(f"Failed to create block from dictionary: {str(e)}")
            raise ValueError("Invalid block data")

    def __str__(self) -> str:
        """Return a human-readable string representation of the block."""
        return (
            f"Block(index={self.index}, "
            f"hash={self.hash[:8]}..., "
            f"tx_count={len(self.transactions)}, "
            f"shard={self.shard_id})"
        )


# ==================== /home/matt/icn-prototype/blockchain/core/transaction.py ====================

# blockchain/core/transaction.py

from __future__ import annotations
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, Optional, Any
import hashlib
import json
import logging
from uuid import uuid4

logger = logging.getLogger(__name__)


@dataclass
class Transaction:
    """
    Represents a transaction in the ICN blockchain.

    A transaction is the fundamental unit of record in the blockchain, representing
    any action or data transfer between parties in the network.
    """

    sender: str
    receiver: str
    action: str
    data: Dict[str, Any]
    timestamp: datetime = field(default_factory=datetime.now)
    signature: Optional[bytes] = None
    shard_id: Optional[int] = None
    transaction_id: str = field(init=False)

    def __post_init__(self) -> None:
        """Initialize transaction ID and perform validation after creation."""
        self.transaction_id = self.calculate_id()
        if not self.validate():
            raise ValueError("Invalid transaction parameters")

    def calculate_id(self) -> str:
        """Calculate unique transaction ID using transaction data."""
        tx_data = {
            "sender": self.sender,
            "receiver": self.receiver,
            "action": self.action,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "shard_id": self.shard_id,
            "nonce": str(uuid4()),
        }
        serialized = json.dumps(tx_data, sort_keys=True)
        return hashlib.sha256(serialized.encode()).hexdigest()

    def validate(self) -> bool:
        """Validate the transaction's structure and data."""
        try:
            # Check required fields
            if not all([self.sender, self.receiver, self.action]):
                logger.error("Missing required transaction fields")
                return False

            # Validate timestamp
            now = datetime.now()
            if self.timestamp > now + timedelta(minutes=5):
                logger.error(f"Transaction timestamp {self.timestamp} is in the future")
                return False

            if self.timestamp < now - timedelta(days=1):
                logger.error(f"Transaction timestamp {self.timestamp} is too old")
                return False

            # Validate data structure
            if not isinstance(self.data, dict):
                logger.error("Transaction data must be a dictionary")
                return False

            # Validate action format
            if not self.action.isalnum() or len(self.action) > 64:
                logger.error("Invalid action format")
                return False

            # Validate IDs format
            if not all(isinstance(x, str) for x in [self.sender, self.receiver]):
                logger.error("Sender and receiver must be strings")
                return False

            # Validate shard_id if present
            if self.shard_id is not None and not isinstance(self.shard_id, int):
                logger.error("Invalid shard_id type")
                return False

            return True

        except Exception as e:
            logger.error(f"Transaction validation failed: {str(e)}")
            return False

    def to_dict(self) -> Dict[str, Any]:
        """Convert transaction to dictionary format."""
        return {
            "transaction_id": self.transaction_id,
            "sender": self.sender,
            "receiver": self.receiver,
            "action": self.action,
            "data": self.data,
            "timestamp": self.timestamp.isoformat(),
            "signature": self.signature.hex() if self.signature else None,
            "shard_id": self.shard_id,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Transaction:
        """Create a transaction instance from a dictionary."""
        try:
            timestamp = datetime.fromisoformat(data["timestamp"])
            signature = (
                bytes.fromhex(data["signature"]) if data.get("signature") else None
            )

            return cls(
                sender=data["sender"],
                receiver=data["receiver"],
                action=data["action"],
                data=data["data"],
                timestamp=timestamp,
                signature=signature,
                shard_id=data.get("shard_id"),
            )
        except Exception as e:
            logger.error(f"Failed to create transaction from dictionary: {str(e)}")
            raise ValueError("Invalid transaction data")

    def __str__(self) -> str:
        """Return a human-readable string representation of the transaction."""
        return (
            f"Transaction(id={self.transaction_id[:8]}..., "
            f"action={self.action}, "
            f"sender={self.sender[:8]}..., "
            f"receiver={self.receiver[:8]}...)"
        )


# ==================== /home/matt/icn-prototype/blockchain/core/shard.py ====================

# blockchain/core/shard.py

from datetime import datetime
from typing import List, Dict, Optional
import logging
from .transaction import Transaction
from .block import Block

logger = logging.getLogger(__name__)


class Shard:
    """
    Represents a blockchain shard.

    A shard is a partition of the blockchain that processes a subset of transactions,
    enabling parallel processing and improved scalability.
    """

    def __init__(self, shard_id: int, max_transactions_per_block: int = 100):
        self.shard_id = shard_id
        self.chain: List[Block] = []
        self.pending_transactions: List[Transaction] = []
        self.height = 0
        self.max_transactions_per_block = max_transactions_per_block
        self.last_block_time = datetime.now()
        self.state: Dict = {}  # Shard-specific state
        self.metrics: Dict = {
            "total_transactions": 0,
            "average_block_time": 0,
            "blocks_created": 0,
            "pending_count": 0,
        }
        self._create_genesis_block()

    def _create_genesis_block(self) -> None:
        """Create genesis block for this shard."""
        genesis_block = Block(
            index=0,
            previous_hash="0" * 64,
            timestamp=datetime.now(),
            transactions=[],
            validator="genesis",
            shard_id=self.shard_id,
        )
        self.chain.append(genesis_block)
        self.height = 1
        self.last_block_time = genesis_block.timestamp
        self.metrics["blocks_created"] = 1
        logger.info(f"Created genesis block for shard {self.shard_id}")

    def add_transaction(self, transaction: Transaction) -> bool:
        """Add a new transaction to pending pool."""
        try:
            if transaction.shard_id != self.shard_id:
                logger.error(
                    f"Transaction shard_id {transaction.shard_id} "
                    f"doesn't match shard {self.shard_id}"
                )
                return False

            if len(self.pending_transactions) >= self.max_transactions_per_block * 2:
                logger.warning(f"Shard {self.shard_id} transaction pool full")
                return False

            if not transaction.validate():
                logger.error("Invalid transaction")
                return False

            self.pending_transactions.append(transaction)
            self.metrics["pending_count"] = len(self.pending_transactions)
            return True

        except Exception as e:
            logger.error(f"Failed to add transaction: {str(e)}")
            return False

    def create_block(self, validator: str) -> Optional[Block]:
        """Create a new block from pending transactions."""
        if not self.pending_transactions:
            logger.debug(f"No pending transactions in shard {self.shard_id}")
            return None

        try:
            transactions = self.pending_transactions[: self.max_transactions_per_block]

            new_block = Block(
                index=self.height,
                previous_hash=self.chain[-1].hash,
                timestamp=datetime.now(),
                transactions=transactions,
                validator=validator,
                shard_id=self.shard_id,
            )

            return new_block

        except Exception as e:
            logger.error(f"Failed to create block: {str(e)}")
            return None

    def add_block(self, block: Block) -> bool:
        """Add a validated block to the shard chain."""
        try:
            if block.shard_id != self.shard_id:
                logger.error(
                    f"Block shard_id {block.shard_id} "
                    f"doesn't match shard {self.shard_id}"
                )
                return False

            if block.index != self.height:
                logger.error(
                    f"Block index {block.index} "
                    f"doesn't match current height {self.height}"
                )
                return False

            if not block.validate(self.chain[-1]):
                logger.error("Block validation failed")
                return False

            # Update metrics
            block_time = (block.timestamp - self.last_block_time).total_seconds()
            self.metrics["average_block_time"] = (
                self.metrics["average_block_time"] * self.metrics["blocks_created"]
                + block_time
            ) / (self.metrics["blocks_created"] + 1)
            self.metrics["blocks_created"] += 1
            self.metrics["total_transactions"] += len(block.transactions)

            # Remove included transactions from pending pool
            tx_ids = {tx.transaction_id for tx in block.transactions}
            self.pending_transactions = [
                tx
                for tx in self.pending_transactions
                if tx.transaction_id not in tx_ids
            ]
            self.metrics["pending_count"] = len(self.pending_transactions)

            # Add block to chain
            self.chain.append(block)
            self.height += 1
            self.last_block_time = block.timestamp

            logger.info(f"Added block {block.index} to shard {self.shard_id}")
            return True

        except Exception as e:
            logger.error(f"Failed to add block: {str(e)}")
            return False

    def get_latest_block(self) -> Block:
        """Get the latest block in this shard."""
        return self.chain[-1]

    # blockchain/core/shard.py (continued)

    def validate_chain(self) -> bool:
        """Validate the entire shard chain."""
        try:
            for i in range(1, len(self.chain)):
                current_block = self.chain[i]
                previous_block = self.chain[i - 1]

                # Validate block
                if not current_block.validate(previous_block):
                    logger.error(f"Invalid block at height {i}")
                    return False

                # Validate sequence
                if current_block.index != previous_block.index + 1:
                    logger.error(f"Non-sequential blocks at height {i}")
                    return False

                # Validate timestamps
                if current_block.timestamp <= previous_block.timestamp:
                    logger.error(f"Invalid timestamp at height {i}")
                    return False

            return True

        except Exception as e:
            logger.error(f"Chain validation failed: {str(e)}")
            return False

    def get_block_by_hash(self, block_hash: str) -> Optional[Block]:
        """Retrieve a block by its hash."""
        try:
            return next(
                (block for block in self.chain if block.hash == block_hash), None
            )
        except Exception as e:
            logger.error(f"Failed to retrieve block: {str(e)}")
            return None

    def get_block_by_height(self, height: int) -> Optional[Block]:
        """Retrieve a block by its height."""
        try:
            if 0 <= height < len(self.chain):
                return self.chain[height]
            return None
        except Exception as e:
            logger.error(f"Failed to retrieve block: {str(e)}")
            return None

    def get_transaction_by_id(self, transaction_id: str) -> Optional[Transaction]:
        """Find a transaction by its ID in the chain."""
        try:
            for block in reversed(self.chain):  # Search from newest to oldest
                for tx in block.transactions:
                    if tx.transaction_id == transaction_id:
                        return tx
            return None
        except Exception as e:
            logger.error(f"Failed to retrieve transaction: {str(e)}")
            return None

    def prune_pending_transactions(self, max_age_minutes: int = 60) -> None:
        """Remove old pending transactions."""
        try:
            current_time = datetime.now()
            self.pending_transactions = [
                tx
                for tx in self.pending_transactions
                if (current_time - tx.timestamp).total_seconds() < max_age_minutes * 60
            ]
            self.metrics["pending_count"] = len(self.pending_transactions)

        except Exception as e:
            logger.error(f"Failed to prune transactions: {str(e)}")

    def get_metrics(self) -> Dict:
        """Get comprehensive shard metrics."""
        try:
            return {
                "shard_id": self.shard_id,
                "height": self.height,
                "pending_transactions": len(self.pending_transactions),
                "last_block_time": self.last_block_time.isoformat(),
                "chain_size": len(self.chain),
                "total_transactions_in_chain": sum(
                    len(block.transactions) for block in self.chain
                ),
                **self.metrics,
            }
        except Exception as e:
            logger.error(f"Failed to get metrics: {str(e)}")
            return {}

    def to_dict(self) -> Dict:
        """Convert shard state to dictionary."""
        try:
            return {
                "shard_id": self.shard_id,
                "height": self.height,
                "chain": [block.to_dict() for block in self.chain],
                "pending_transactions": [
                    tx.to_dict() for tx in self.pending_transactions
                ],
                "max_transactions_per_block": self.max_transactions_per_block,
                "last_block_time": self.last_block_time.isoformat(),
                "state": self.state,
                "metrics": self.metrics,
            }
        except Exception as e:
            logger.error(f"Failed to convert shard to dictionary: {str(e)}")
            return {}

    @classmethod
    def from_dict(cls, data: Dict) -> "Shard":
        """Create shard from dictionary."""
        try:
            shard = cls(
                shard_id=data["shard_id"],
                max_transactions_per_block=data["max_transactions_per_block"],
            )

            # Restore chain
            shard.chain = [Block.from_dict(block) for block in data["chain"]]

            # Restore pending transactions
            shard.pending_transactions = [
                Transaction.from_dict(tx) for tx in data["pending_transactions"]
            ]

            # Restore other attributes
            shard.height = data["height"]
            shard.last_block_time = datetime.fromisoformat(data["last_block_time"])
            shard.state = data["state"]
            shard.metrics = data["metrics"]

            return shard

        except Exception as e:
            logger.error(f"Failed to create shard from dictionary: {str(e)}")
            raise ValueError("Invalid shard data")

    def __str__(self) -> str:
        """Return a human-readable string representation of the shard."""
        return (
            f"Shard(id={self.shard_id}, "
            f"height={self.height}, "
            f"pending_tx={len(self.pending_transactions)}, "
            f"blocks={len(self.chain)})"
        )


# ==================== /home/matt/icn-prototype/blockchain/core/blockchain.py ====================



# ==================== /home/matt/icn-prototype/blockchain/core/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/contracts/contract_executor.py ====================

# blockchain/contracts/contract_executor.py

from typing import Dict, List, Optional, Set
import logging
from datetime import datetime
import asyncio
from .smart_contract import SmartContract, ContractExecutionError

logger = logging.getLogger(__name__)


class ContractExecutor:
    """
    Manages smart contract deployment, execution, and lifecycle.

    This class handles the secure deployment of contracts, manages their
    dependencies, and coordinates their execution while enforcing
    resource limits and security constraints.
    """

    def __init__(self, initial_mana: int = 1000, mana_regen_rate: int = 10):
        self.contracts: Dict[str, SmartContract] = {}
        self.mana_pool = initial_mana
        self.mana_regen_rate = mana_regen_rate
        self.execution_queue: List[Dict] = []
        self.max_queue_size = 1000
        self.dependency_graph: Dict[str, Set[str]] = {}
        self.metrics: Dict = {
            "total_executions": 0,
            "failed_executions": 0,
            "total_mana_consumed": 0,
            "average_execution_time": 0,
            "contracts_deployed": 0,
        }
        self.execution_lock = asyncio.Lock()

    async def deploy_contract(self, contract: SmartContract) -> bool:
        """
        Deploy a new smart contract.

        Args:
            contract: SmartContract instance to deploy

        Returns:
            bool: True if deployment successful, False otherwise
        """
        try:
            # Check if contract already exists
            if contract.contract_id in self.contracts:
                logger.error(f"Contract {contract.contract_id} already exists")
                return False

            # Validate contract code (basic safety checks)
            if not self._validate_contract_code(contract.code):
                return False

            # Check dependencies
            if not self._validate_dependencies(contract.dependencies):
                return False

            # Update dependency graph
            self.dependency_graph[contract.contract_id] = contract.dependencies

            # Store contract
            self.contracts[contract.contract_id] = contract
            self.metrics["contracts_deployed"] += 1

            logger.info(f"Deployed contract {contract.contract_id}")
            return True

        except Exception as e:
            logger.error(f"Contract deployment failed: {str(e)}")
            return False

    async def execute_contract(
        self, contract_id: str, input_data: Dict, caller: str
    ) -> Dict:
        """
        Execute a smart contract.

        Args:
            contract_id: ID of contract to execute
            input_data: Input data for contract execution
            caller: ID of the calling entity

        Returns:
            Dict containing execution results

        Raises:
            ContractExecutionError: If execution fails
        """
        async with self.execution_lock:
            try:
                # Get contract
                contract = self.contracts.get(contract_id)
                if not contract:
                    raise ContractExecutionError(f"Contract {contract_id} not found")

                # Validate caller
                if caller not in contract.allowed_callers:
                    raise ContractExecutionError("Caller not authorized")

                # Check mana availability
                if self.mana_pool < contract.mana_cost:
                    raise ContractExecutionError("Insufficient mana in pool")

                # Execute contract
                execution_start = datetime.now()
                result = contract.execute(input_data, self.mana_pool)

                # Update mana pool
                self.mana_pool -= result["mana_used"]
                self.metrics["total_mana_consumed"] += result["mana_used"]

                # Update metrics
                execution_time = (datetime.now() - execution_start).total_seconds()
                self._update_metrics(execution_time, True)

                return result

            except Exception as e:
                self._update_metrics(0, False)
                raise ContractExecutionError(str(e))

    def _validate_contract_code(self, code: str) -> bool:
        """Validate contract code for basic safety."""
        try:
            # Check for dangerous imports
            dangerous_imports = ["os", "sys", "subprocess", "importlib"]
            for imp in dangerous_imports:
                if f"import {imp}" in code or f"from {imp}" in code:
                    logger.error(f"Dangerous import detected: {imp}")
                    return False

            # Check for dangerous built-ins
            dangerous_builtins = ["exec", "eval", "open", "__import__"]
            for builtin in dangerous_builtins:
                if builtin in code:
                    logger.error(f"Dangerous builtin detected: {builtin}")
                    # blockchain/contracts/contract_executor.py (continued)

                    return False

            # Validate code compiles
            compile(code, "<string>", "exec")

            return True

        except Exception as e:
            logger.error(f"Contract code validation failed: {str(e)}")
            return False

    def _validate_dependencies(self, dependencies: Set[str]) -> bool:
        """Validate contract dependencies exist and are cyclical."""
        try:
            # Check all dependencies exist
            for dep in dependencies:
                if dep not in self.contracts:
                    logger.error(f"Dependency not found: {dep}")
                    return False

            # Check for circular dependencies
            visited = set()
            path = []

            def check_cycle(contract_id: str) -> bool:
                if contract_id in path:
                    logger.error(
                        f"Circular dependency detected: {' -> '.join(path + [contract_id])}"
                    )
                    return False

                if contract_id in visited:
                    return True

                visited.add(contract_id)
                path.append(contract_id)

                for dep in self.dependency_graph.get(contract_id, set()):
                    if not check_cycle(dep):
                        return False

                path.pop()
                return True

            # Check each dependency
            for dep in dependencies:
                if not check_cycle(dep):
                    return False

            return True

        except Exception as e:
            logger.error(f"Dependency validation failed: {str(e)}")
            return False

    def _update_metrics(self, execution_time: float, success: bool) -> None:
        """Update executor metrics after contract execution."""
        try:
            self.metrics["total_executions"] += 1

            if not success:
                self.metrics["failed_executions"] += 1

            # Update average execution time
            total_time = self.metrics["average_execution_time"] * (
                self.metrics["total_executions"] - 1
            )
            self.metrics["average_execution_time"] = (
                total_time + execution_time
            ) / self.metrics["total_executions"]

        except Exception as e:
            logger.error(f"Failed to update metrics: {str(e)}")

    async def regenerate_mana(self) -> None:
        """Regenerate mana in the pool."""
        try:
            old_mana = self.mana_pool
            self.mana_pool = min(1000, self.mana_pool + self.mana_regen_rate)

            if self.mana_pool > old_mana:
                logger.debug(f"Regenerated mana: {self.mana_pool - old_mana}")

        except Exception as e:
            logger.error(f"Mana regeneration failed: {str(e)}")

    async def process_execution_queue(self) -> None:
        """Process pending contract executions."""
        while True:
            try:
                if not self.execution_queue:
                    await asyncio.sleep(1)
                    continue

                # Get next execution request
                request = self.execution_queue.pop(0)

                # Execute contract
                await self.execute_contract(
                    request["contract_id"], request["input_data"], request["caller"]
                )

                # Regenerate some mana
                await self.regenerate_mana()

            except Exception as e:
                logger.error(f"Queue processing error: {str(e)}")
                await asyncio.sleep(1)

    async def queue_execution(
        self, contract_id: str, input_data: Dict, caller: str
    ) -> bool:
        """Queue a contract for execution."""
        try:
            if len(self.execution_queue) >= self.max_queue_size:
                logger.error("Execution queue full")
                return False

            self.execution_queue.append(
                {
                    "contract_id": contract_id,
                    "input_data": input_data,
                    "caller": caller,
                    "timestamp": datetime.now(),
                }
            )

            return True

        except Exception as e:
            logger.error(f"Failed to queue execution: {str(e)}")
            return False

    def get_contract(self, contract_id: str) -> Optional[SmartContract]:
        """Get a contract by ID."""
        return self.contracts.get(contract_id)

    def list_contracts(self) -> List[Dict]:
        """Get list of all deployed contracts."""
        return [
            {
                "contract_id": contract.contract_id,
                "creator": contract.creator,
                "version": contract.version,
                "dependencies": list(contract.dependencies),
                "metrics": contract.get_metrics(),
            }
            for contract in self.contracts.values()
        ]

    def get_metrics(self) -> Dict:
        """Get executor metrics."""
        return {
            **self.metrics,
            "current_mana": self.mana_pool,
            "queue_length": len(self.execution_queue),
            "active_contracts": len(self.contracts),
        }

    async def start(self) -> None:
        """Start the contract executor."""
        logger.info("Starting contract executor")
        asyncio.create_task(self.process_execution_queue())
        asyncio.create_task(self._mana_regeneration_loop())

    async def _mana_regeneration_loop(self) -> None:
        """Continuously regenerate mana."""
        while True:
            await self.regenerate_mana()
            await asyncio.sleep(60)  # Regenerate every minute

    def __str__(self) -> str:
        """Return a human-readable string representation of the executor."""
        return (
            f"ContractExecutor(contracts={len(self.contracts)}, "
            f"mana={self.mana_pool}, "
            f"queue={len(self.execution_queue)})"
        )


# ==================== /home/matt/icn-prototype/blockchain/contracts/smart_contract.py ====================

# blockchain/contracts/smart_contract.py

from __future__ import annotations
from datetime import datetime, timedelta
from typing import Dict, List, Set, Optional, Any
import time
import logging
import hashlib
import json
import sys
from io import StringIO

logger = logging.getLogger(__name__)


class ContractExecutionError(Exception):
    """Custom exception for contract execution errors."""

    pass


class SmartContract:
    """
    Represents a smart contract in the ICN blockchain.

    Smart contracts are self-executing contracts with terms directly
    written into code. They run in a sandboxed environment with
    restricted capabilities for security.
    """

    def __init__(
        self,
        contract_id: str,
        code: str,
        creator: str,
        mana_cost: int = 10,
        version: str = "1.0",
    ):
        self.contract_id = contract_id
        self.code = code
        self.creator = creator
        self.state: Dict = {}
        self.mana_cost = mana_cost
        self.version = version
        self.created_at = datetime.now()
        self.last_executed = None
        self.execution_count = 0
        self.total_mana_consumed = 0
        self.execution_history: List[Dict] = []
        self.metadata: Dict = {
            "created_at": self.created_at,
            "version": version,
            "creator": creator,
            "description": "",
            "tags": set(),
        }
        self.dependencies: Set[str] = set()
        self.allowed_callers: Set[str] = {creator}
        self.restrictions: Dict = {
            "max_state_size": 1024 * 1024,  # 1MB
            "max_execution_time": 5,  # seconds
            "max_mana_per_execution": 100,
            "max_daily_executions": 1000,
        }
        self.daily_executions = 0
        self.last_reset = datetime.now()

    def execute(self, input_data: Dict, available_mana: int) -> Dict:
        """
        Execute the smart contract code with safety checks.

        Args:
            input_data: Data passed to the contract
            available_mana: Available mana for execution

        Returns:
            Dict containing execution results and new state

        Raises:
            ContractExecutionError: If execution fails or violates restrictions
        """
        # Reset daily execution counter if needed
        self._reset_daily_executions()

        # Validate execution conditions
        validation_result = self._validate_execution(input_data, available_mana)
        if validation_result.get("error"):
            raise ContractExecutionError(validation_result["error"])

        execution_start = time.time()
        stdout_capture = StringIO()
        original_stdout = sys.stdout
        sys.stdout = stdout_capture

        try:
            # Set up secure execution environment
            local_namespace = self._setup_execution_environment(input_data)

            # Execute contract code
            exec(self.code, {}, local_namespace)

            # Validate execution result
            if "execute" not in local_namespace:
                raise ContractExecutionError("Contract missing execute function")

            # Check execution time
            if time.time() - execution_start > self.restrictions["max_execution_time"]:
                raise ContractExecutionError("Execution time limit exceeded")

            # Execute contract function
            result = local_namespace["execute"](input_data, self.state)

            # Update contract metrics
            self._update_execution_metrics(execution_start)

            # Capture any output
            output = stdout_capture.getvalue()

            return {
                "state": self.state,
                "result": result,
                "mana_used": self.mana_cost,
                "execution_time": time.time() - execution_start,
                "output": output,
            }

        except Exception as e:
            logger.error(f"Contract execution failed: {str(e)}")
            raise ContractExecutionError(str(e))

        finally:
            sys.stdout = original_stdout

    def _validate_execution(self, input_data: Dict, available_mana: int) -> Dict:
        """Validate execution conditions."""
        try:
            if self.daily_executions >= self.restrictions["max_daily_executions"]:
                return {"error": "Daily execution limit exceeded"}

            if available_mana < self.mana_cost:
                return {"error": "Insufficient mana"}

            if len(str(self.state)) > self.restrictions["max_state_size"]:
                return {"error": "State size limit exceeded"}

            if not isinstance(input_data, dict):
                return {"error": "Invalid input data format"}

            return {}

        except Exception as e:
            return {"error": f"Validation failed: {str(e)}"}

    def _setup_execution_environment(self, input_data: Dict) -> Dict:
        """Set up secure execution environment with allowed variables."""
        # Basic built-ins that are safe to use
        safe_builtins = {
            "abs": abs,
            "bool": bool,
            "dict": dict,
            "float": float,
            "int": int,
            "len": len,
            "list": list,
            "max": max,
            "min": min,
            "round": round,
            "sorted": sorted,
            "str": str,
            "sum": sum,
        }

        return {
            "input": input_data,
            "state": self.state.copy(),
            "contract_id": self.contract_id,
            "creator": self.creator,
            "version": self.version,
            "metadata": self.metadata,
            "__builtins__": safe_builtins,
        }

    def _update_execution_metrics(self, execution_start: float) -> None:
        """Update contract execution metrics."""
        self.last_executed = datetime.now()
        self.execution_count += 1
        self.daily_executions += 1
        self.total_mana_consumed += self.mana_cost

        execution_record = {
            "timestamp": self.last_executed,
            "execution_time": time.time() - execution_start,
            "mana_used": self.mana_cost,
            "state_size": len(str(self.state)),
        }

        self.execution_history.append(execution_record)
        if len(self.execution_history) > 1000:
            self.execution_history = self.execution_history[-1000:]

    def _reset_daily_executions(self) -> None:
        """Reset daily execution counter if needed."""
        current_time = datetime.now()
        if (current_time - self.last_reset).days >= 1:
            self.daily_executions = 0
            self.last_reset = current_time

    def authorize_caller(self, caller_id: str) -> bool:
        """Add an authorized caller."""
        self.allowed_callers.add(caller_id)
        return True

    def revoke_caller(self, caller_id: str) -> bool:
        """Revoke caller authorization."""
        if caller_id == self.creator:
            return False
        self.allowed_callers.discard(caller_id)
        return True

    def update_restrictions(self, new_restrictions: Dict) -> bool:
        """Update contract restrictions."""
        try:
            # Validate new restrictions
            if not all(k in self.restrictions for k in new_restrictions):
                return False

            # Update only valid restrictions
            self.restrictions.update(new_restrictions)
            return True

        except Exception as e:
            logger.error(f"Failed to update restrictions: {str(e)}")
            return False

    def get_metrics(self) -> Dict:
        """Get comprehensive contract metrics."""
        return {
            "contract_id": self.contract_id,
            "version": self.version,
            "creator": self.creator,
            "created_at": self.created_at.isoformat(),
            "last_executed": (
                self.last_executed.isoformat() if self.last_executed else None
            ),
            "execution_count": self.execution_count,
            "daily_executions": self.daily_executions,
            "total_mana_consumed": self.total_mana_consumed,
            "average_mana_per_execution": (
                self.total_mana_consumed / self.execution_count
                if self.execution_count > 0
                else 0
            ),
            "state_size": len(str(self.state)),
            "dependencies": list(self.dependencies),
            "authorized_callers": len(self.allowed_callers),
            "restrictions": self.restrictions,
        }

    def to_dict(self) -> Dict:
        """Convert contract to dictionary format."""
        return {
            "contract_id": self.contract_id,
            "code": self.code,
            "creator": self.creator,
            "state": self.state,
            "mana_cost": self.mana_cost,
            "version": self.version,
            "metadata": {
                **self.metadata,
                "created_at": self.metadata["created_at"].isoformat(),
                "tags": list(self.metadata["tags"]),
            },
            "dependencies": list(self.dependencies),
            "allowed_callers": list(self.allowed_callers),
            "restrictions": self.restrictions,
            "metrics": self.get_metrics(),
        }

    @classmethod
    def from_dict(cls, data: Dict) -> "SmartContract":
        """Create contract from dictionary."""
        contract = cls(
            contract_id=data["contract_id"],
            code=data["code"],
            creator=data["creator"],
            mana_cost=data["mana_cost"],
            version=data["version"],
        )

        contract.state = data["state"]
        contract.metadata = {
            **data["metadata"],
            "created_at": datetime.fromisoformat(data["metadata"]["created_at"]),
            "tags": set(data["metadata"]["tags"]),
        }
        contract.dependencies = set(data["dependencies"])
        contract.allowed_callers = set(data["allowed_callers"])
        contract.restrictions = data["restrictions"]

        return contract

    def __str__(self) -> str:
        """Return a human-readable string representation of the contract."""
        return (
            f"Contract(id={self.contract_id}, "
            f"creator={self.creator}, "
            f"executions={self.execution_count}, "
            f"mana_cost={self.mana_cost})"
        )


# ==================== /home/matt/icn-prototype/blockchain/contracts/__init__.py ====================



# ==================== /home/matt/icn-prototype/blockchain/consensus/proof_of_cooperation.py ====================

# blockchain/consensus/proof_of_cooperation.py

from __future__ import annotations
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Set
import math
import random
import logging
from ..core.node import Node
from ..core.block import Block

logger = logging.getLogger(__name__)


class ProofOfCooperation:
    """
    Implements the Proof of Cooperation consensus mechanism.

    This consensus mechanism prioritizes cooperative behavior and community
    contribution over computational power or stake. It uses reputation scores,
    diversity of cooperation, and historical performance to select validators.
    """

    def __init__(self, min_reputation: float = 10.0, cooldown_blocks: int = 3):
        self.min_reputation = min_reputation
        self.cooldown_blocks = cooldown_blocks
        self.cooperation_scores: Dict[str, float] = {}
        self.reputation_weights = {
            "cooperative_growth": 1.5,  # Cooperative development and expansion
            "proposal_participation": 1.2,  # Governance participation
            "transaction_validation": 1.0,  # Basic validation work
            "resource_sharing": 1.3,  # Contributing resources
            "conflict_resolution": 1.1,  # Helping resolve disputes
            "community_building": 1.4,  # Community engagement
            "sustainability": 1.2,  # Long-term contribution
            "innovation": 1.3,  # New features/improvements
            "network_stability": 1.1,  # Reliable operation
            "data_availability": 1.2,  # Data provision
        }
        self.validation_thresholds = {
            "min_participation": 0.1,  # Minimum participation rate
            "min_success_rate": 0.8,  # Minimum validation success rate
            "min_availability": 0.95,  # Minimum node availability
            "max_consecutive_validations": 3,  # Max blocks in a row
        }
        self.reputation_decay_factor = 0.99  # Daily reputation decay
        self.collusion_threshold = 0.8  # Threshold for detecting collusion
        self.validator_history: List[Tuple[str, datetime, int]] = []
        self.validation_stats: Dict[str, Dict] = {}
        self.performance_metrics: Dict[str, float] = {
            "average_block_time": 0.0,
            "total_validations": 0,
            "successful_validations": 0,
            "collusion_detections": 0,
        }

    def calculate_cooperation_score(
        self, node: Node, shard_id: Optional[int] = None
    ) -> float:
        """Calculate a node's cooperation score based on multiple factors."""
        if not node.can_validate(shard_id):
            return 0.0

        try:
            # Calculate base score from weighted reputation
            base_score = sum(
                score * self.reputation_weights.get(category, 1.0)
                for category, score in node.reputation_scores.items()
            )

            # Apply modifiers
            diversity_factor = self._calculate_diversity_factor(node)
            consistency_factor = self._calculate_consistency_factor(node)
            performance_factor = self._calculate_performance_factor(node)
            shard_factor = (
                self._calculate_shard_factor(node, shard_id) if shard_id else 1.0
            )

            # Combine factors
            final_score = (
                base_score
                * diversity_factor
                * consistency_factor
                * performance_factor
                * shard_factor
            )

            return max(0, final_score)

        except Exception as e:
            logger.error(f"Failed to calculate cooperation score: {str(e)}")
            return 0.0

    def _calculate_diversity_factor(self, node: Node) -> float:
        """Calculate diversity factor based on cooperative interactions."""
        try:
            recent_interactions = node.cooperative_interactions[-100:]
            if not recent_interactions:
                return 1.0

            unique_coops = len(set(recent_interactions))
            total_interactions = len(recent_interactions)

            diversity_score = unique_coops / total_interactions
            normalized_score = 1.0 + math.log(diversity_score + 1)

            return max(
                self.validation_thresholds["min_participation"], normalized_score
            )

        except Exception as e:
            logger.error(f"Failed to calculate diversity factor: {str(e)}")
            return self.validation_thresholds["min_participation"]

    def _calculate_consistency_factor(self, node: Node) -> float:
        """Calculate consistency factor based on validation history."""
        try:
            if not node.validation_history:
                return 1.0

            recent_validations = node.validation_history[-50:]
            successful = sum(
                1
                for v in recent_validations
                if v.get("evidence", {}).get("success", False)
            )

            success_rate = successful / len(recent_validations)
            return max(self.validation_thresholds["min_success_rate"], success_rate)

        except Exception as e:
            logger.error(f"Failed to calculate consistency factor: {str(e)}")
            return self.validation_thresholds["min_success_rate"]

    def _calculate_performance_factor(self, node: Node) -> float:
        """Calculate performance factor based on node metrics."""
        try:
            metrics = node.performance_metrics
            if not metrics:
                return 1.0

            factors = [
                metrics.get("availability", 0) / 100,
                metrics.get("validation_success_rate", 0) / 100,
                metrics.get("network_reliability", 0) / 100,
            ]

            avg_performance = sum(factors) / len(factors)
            return max(self.validation_thresholds["min_availability"], avg_performance)

        except Exception as e:
            logger.error(f"Failed to calculate performance factor: {str(e)}")
            return self.validation_thresholds["min_availability"]

    def _calculate_shard_factor(self, node: Node, shard_id: int) -> float:
        """Calculate shard-specific performance factor."""
        try:
            if shard_id not in node.active_shards:
                return 0.0

            # Consider time spent in shard
            time_in_shard = (
                datetime.now() - node.active_shards[shard_id]
            ).total_seconds()
            shard_experience = min(1.0, time_in_shard / (24 * 3600))

            return 0.5 + (0.5 * shard_experience)

        except Exception as e:
            logger.error(f"Failed to calculate shard factor: {str(e)}")
            return 0.0

    def select_validator(
        self, nodes: List[Node], shard_id: Optional[int] = None
    ) -> Optional[Node]:
        """Select the next validator using weighted random selection."""
        try:
            eligible_nodes = [
                node for node in nodes if self._is_eligible_validator(node, shard_id)
            ]

            if not eligible_nodes:
                logger.warning("No eligible validators available")
                return None

            # Calculate scores for eligible nodes
            scores = [
                self.calculate_cooperation_score(node, shard_id)
                for node in eligible_nodes
            ]
            total_score = sum(scores)

            if total_score <= 0:
                logger.warning("No nodes with positive cooperation scores")
                selected = random.choice(eligible_nodes)
            else:
                # Weighted random selection
                selection_point = random.uniform(0, total_score)
                current_sum = 0
                selected = eligible_nodes[-1]

                for node, score in zip(eligible_nodes, scores):
                    current_sum += score
                    if current_sum >= selection_point:
                        selected = node
                        break

            # Record selection and apply cooldown
            self._record_validator_selection(selected, shard_id)
            selected.enter_cooldown(self.cooldown_blocks)

            return selected

        except Exception as e:
            logger.error(f"Failed to select validator: {str(e)}")
            return None

    def _is_eligible_validator(
        self, node: Node, shard_id: Optional[int] = None
    ) -> bool:
        """Check if a node is eligible to validate blocks."""
        try:
            if not node.can_validate(shard_id):
                return False

            # Check minimum reputation requirement
            if node.get_total_reputation() < self.min_reputation:
                return False

            # Check performance factors
            performance_factor = self._calculate_performance_factor(node)
            if performance_factor < self.validation_thresholds["min_availability"]:
                return False

            # Check recent selections to prevent concentration
            recent_validations = [
                v[0] for v in self.validator_history[-10:] if v[0] == node.node_id
            ]
            if (
                len(recent_validations)
                >= self.validation_thresholds["max_consecutive_validations"]
            ):
                return False

            return True

        except Exception as e:
            logger.error(f"Failed to check validator eligibility: {str(e)}")
            return False

    def _record_validator_selection(self, node: Node, shard_id: Optional[int]) -> None:
        """Record validator selection for statistics."""
        try:
            self.validator_history.append((node.node_id, datetime.now(), shard_id))
            if len(self.validator_history) > 1000:
                self.validator_history = self.validator_history[-1000:]

            if node.node_id not in self.validation_stats:
                self.validation_stats[node.node_id] = {
                    "selections": 0,
                    "successful_validations": 0,
                    "last_selected": None,
                    "shard_validations": {},
                }

            stats = self.validation_stats[node.node_id]
            stats["selections"] += 1
            stats["last_selected"] = datetime.now()

            if shard_id is not None:
                shard_stats = stats["shard_validations"].setdefault(
                    shard_id, {"selections": 0, "successful": 0}
                )
                shard_stats["selections"] += 1

        except Exception as e:
            logger.error(f"Failed to record validator selection: {str(e)}")

    def validate_block(
        self, block: Block, previous_block: Optional[Block], validator: Node
    ) -> bool:
        """Validate a proposed block."""
        try:
            # Verify validator eligibility
            if not self._is_eligible_validator(validator, block.shard_id):
                logger.error("Validator not eligible")
                return False

            # Perform block validation
            if not block.validate(previous_block):
                logger.error("Block validation failed")
                return False

            # Update statistics
            self._update_validation_stats(validator, block, True)

            return True

        except Exception as e:
            logger.error(f"Block validation failed: {str(e)}")
            self._update_validation_stats(validator, block, False)
            return False

    def _update_validation_stats(
        self, validator: Node, block: Block, success: bool
    ) -> None:
        """Update validation statistics."""
        try:
            stats = self.validation_stats.get(
                validator.node_id,
                {"selections": 0, "successful_validations": 0, "shard_validations": {}},
            )

            if success:
                stats["successful_validations"] += 1

            if block.shard_id is not None:
                shard_stats = stats["shard_validations"].setdefault(
                    block.shard_id, {"selections": 0, "successful": 0}
                )
                if success:
                    shard_stats["successful"] += 1

            self.validation_stats[validator.node_id] = stats

        except Exception as e:
            logger.error(f"Failed to update validation stats: {str(e)}")

    def detect_collusion(self, validator: Node, block: Block) -> bool:
        """Detect potential collusion patterns."""
        try:
            # Check for repeated validations with same actors
            recent_validations = validator.validation_history[-20:]
            interaction_counts: Dict[str, int] = {}

            for validation in recent_validations:
                for tx in block.transactions:
                    interaction_counts[tx.sender] = (
                        interaction_counts.get(tx.sender, 0) + 1
                    )
                    interaction_counts[tx.receiver] = (
                        interaction_counts.get(tx.receiver, 0) + 1
                    )

            # Check if any actor appears too frequently
            max_interactions = max(interaction_counts.values(), default=0)
            if max_interactions / len(recent_validations) > self.collusion_threshold:
                logger.warning(
                    f"Potential collusion detected for validator {validator.node_id}"
                )
                self.performance_metrics["collusion_detections"] += 1
                return True

            return False

        except Exception as e:
            logger.error(f"Failed to detect collusion: {str(e)}")
            return False

    def get_metrics(self) -> Dict:
        """Get consensus mechanism metrics."""
        try:
            return {
                "active_validators": len(self.validation_stats),
                "total_validations": self.performance_metrics["total_validations"],
                "successful_validations": self.performance_metrics[
                    "successful_validations"
                ],
                "average_block_time": self.performance_metrics["average_block_time"],
                "collusion_detections": self.performance_metrics[
                    "collusion_detections"
                ],
            }
        except Exception as e:
            logger.error(f"Failed to get metrics: {str(e)}")
            return {}


# ==================== /home/matt/icn-prototype/blockchain/consensus/__init__.py ====================

