# Project Context:
The InterCooperative Network (ICN) is a decentralized cooperative management system designed to support global governance, privacy-preserving identity, and resource sharing. It uses blockchain technology for consensus and DIDs for secure identities, with modules designed for scalable, democratic interaction. The ICN promotes cooperative-based decision-making, transparent governance, and equitable resource distribution.

# Module: tests
# Purpose: Ensures the reliability and performance of ICN components through comprehensive testing.
# Vision Alignment: Maintains system integrity by validating that all modules perform as expected, supporting ICNâ€™s stability and trustworthiness.
# Interaction with Other Modules: Covers tests for 'blockchain,' 'did,' 'api,' and 'system' components.


# Code Files for Module: tests


# File: /home/matt/icn-prototype/tests/__init__.py

```py
    # tests/__init__.py
    """Test suite for the ICN blockchain."""
```

# File: /home/matt/icn-prototype/tests/integration/test_cooldown_management.py

```py
    import unittest
    from datetime import datetime, timedelta
    from blockchain.consensus.proof_of_cooperation.cooldown_manager import CooldownManager
    from blockchain.core.node import Node
    
    class TestCooldownManagement(unittest.TestCase):
        def setUp(self):
            self.cooldown_manager = CooldownManager(base_cooldown=3, max_cooldown=10)
            self.node1 = Node(node_id="node1", cooperative_id="coop1", initial_stake=100.0)
            self.node1.reputation = 20.0
    
        def test_dynamic_cooldown_increase(self):
            # Simulate high participation rate to trigger dynamic cooldown increase
            for _ in range(5):
                self.cooldown_manager._track_activity(self.node1)
            
            self.cooldown_manager.apply_cooldown(self.node1)
            self.assertGreater(self.node1.cooldown, 3)  # Cooldown should increase
    
        def test_cooldown_decay(self):
            # Test that cooldown decreases gradually over time
            self.node1.cooldown = 5
            self.cooldown_manager.reset_cooldown(self.node1)
            self.assertEqual(self.node1.cooldown, 4)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/test_consensus_mechanism.py

```py
    import unittest
    from datetime import datetime, timedelta
    from typing import List
    
    # Adjust imports based on your project structure
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    from blockchain.core.node import Node
    from blockchain.core.block import Block
    from blockchain.core.transaction import Transaction
    
    class TestConsensusMechanism(unittest.TestCase):
        """Test suite for the ICN Proof of Cooperation consensus mechanism."""
    
        def setUp(self):
            """Set up the consensus mechanism and initial test data."""
            self.consensus = ProofOfCooperation(min_reputation=10.0, cooldown_blocks=3)
            self.nodes = self._create_test_nodes()
            
            # Create a genesis block
            self.genesis_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now() - timedelta(minutes=10),
                transactions=[],
                validator="genesis",
                shard_id=1
            )
    
        def _create_test_node(self, node_id: str, reputation_score: float = 25.0) -> Node:
            """Create a test node with predefined characteristics."""
            node = Node(node_id=node_id, cooperative_id="test_coop", initial_stake=100.0)
    
            # Assign reputation scores
            for category in node.reputation_scores:
                node.reputation_scores[category] = reputation_score
    
            # Assign validation history
            node.validation_history = [
                {"timestamp": datetime.now() - timedelta(minutes=i),
                 "category": "validation", "score_change": 1.0, "evidence": {"success": True}}
                for i in range(20)
            ]
    
            # Assign performance metrics
            node.performance_metrics = {
                "availability": 98.0,
                "validation_success_rate": 95.0,
                "network_reliability": 97.0
            }
    
            # Set node state
            node.metadata["status"] = "active"
            node.cooldown = 0
    
            # Assign shard
            node.assign_to_shard(1)
    
            # Add cooperative interactions
            node.cooperative_interactions = [f"coop_{i}" for i in range(30)]
    
            return node
    
        def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
            """Create a list of test nodes with varying characteristics."""
            nodes = []
            for i in range(num_nodes):
                reputation = 25.0 + (i * 5.0)
                node = self._create_test_node(f"node_{i}", reputation)
                nodes.append(node)
            return nodes
    
        def _create_test_block(self, transactions: List[Transaction]) -> Block:
            """Create a test block with predefined transactions."""
            return Block(
                index=self.genesis_block.index + 1,
                previous_hash=self.genesis_block.hash,
                timestamp=datetime.now(),
                transactions=transactions,
                validator="test_validator",
                shard_id=1
            )
    
        def test_initialization(self):
            """Test initialization of the consensus mechanism."""
            self.assertEqual(self.consensus.min_reputation, 10.0)
            self.assertEqual(self.consensus.cooldown_blocks, 3)
            self.assertGreater(len(self.consensus.reputation_weights), 0)
            self.assertGreater(len(self.consensus.validation_thresholds), 0)
    
        def test_validator_selection(self):
            """Test the process of selecting a validator."""
            validator = self.consensus.select_validator(self.nodes)
            self.assertIsNotNone(validator)
            self.assertIn(validator, self.nodes)
    
            # Test selection with specific shard
            shard_validator = self.consensus.select_validator(self.nodes, shard_id=1)
            self.assertIsNotNone(shard_validator)
    
            # Test selection when all nodes are in cooldown
            for node in self.nodes:
                node.enter_cooldown(3)
            no_validator = self.consensus.select_validator(self.nodes)
            self.assertIsNone(no_validator)
    
            # Test selection with varying reputation scores
            for node in self.nodes:
                node.cooldown = 0
            high_rep_node = self._create_test_node("high_rep", 100.0)
            self.nodes.append(high_rep_node)
    
            selection_counts = {node.node_id: 0 for node in self.nodes}
            for _ in range(100):
                selected = self.consensus.select_validator(self.nodes)
                if selected:
                    selection_counts[selected.node_id] += 1
    
            self.assertGreater(selection_counts["high_rep"], selection_counts["node_0"])
    
        def test_cooperation_score_calculation(self):
            """Test calculation of cooperation scores."""
            node = self._create_test_node("test_node")
    
            score = self.consensus.calculate_cooperation_score(node)
            self.assertGreater(score, 0)
    
            # Test with lower reputation
            for category in node.reputation_scores:
                node.reputation_scores[category] = 5.0
            low_score = self.consensus.calculate_cooperation_score(node)
            self.assertLess(low_score, score)
    
            # Test with limited cooperative interactions
            node.cooperative_interactions = ["coop_1"] * 30
            limited_score = self.consensus.calculate_cooperation_score(node)
            self.assertLess(limited_score, score)
    
            # Test with lower performance metrics
            node.performance_metrics["availability"] = 50.0
            poor_score = self.consensus.calculate_cooperation_score(node)
            self.assertLess(poor_score, score)
    
        def test_block_validation(self):
            """Test the block validation process."""
            validator = self._create_test_node("test_validator")
    
            transactions = [
                Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                ) for i in range(3)
            ]
    
            valid_block = self._create_test_block(transactions)
            self.assertTrue(self.consensus.validate_block(valid_block, self.genesis_block, validator))
    
            # Test with an invalid timestamp
            invalid_block = self._create_test_block(transactions)
            invalid_block.timestamp = datetime.now() + timedelta(hours=1)
            self.assertFalse(self.consensus.validate_block(invalid_block, self.genesis_block, validator))
    
            # Test with a validator having insufficient reputation
            invalid_validator = self._create_test_node("invalid_validator", reputation_score=5.0)
            self.assertFalse(self.consensus.validate_block(valid_block, self.genesis_block, invalid_validator))
    
        def test_collusion_detection(self):
            """Test detection of collusion in transactions."""
            validator = self._create_test_node("test_validator")
    
            normal_transactions = [
                Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                ) for i in range(10)
            ]
            normal_block = self._create_test_block(normal_transactions)
    
            suspicious_transactions = [
                Transaction(
                    sender="suspicious_sender",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                ) for i in range(10)
            ]
            suspicious_block = self._create_test_block(suspicious_transactions)
    
            self.assertFalse(self.consensus.detect_collusion(validator, normal_block))
            self.assertTrue(self.consensus.detect_collusion(validator, suspicious_block))
    
        def test_cooldown_mechanism(self):
            """Test the cooldown mechanism for validators."""
            validator = self._create_test_node("test_validator")
    
            selected = self.consensus.select_validator([validator])
            self.assertIsNotNone(selected)
            self.assertEqual(selected.cooldown, self.consensus.cooldown_blocks)
    
            # Ensure validator cannot be selected during cooldown
            new_selection = self.consensus.select_validator([validator])
            self.assertIsNone(new_selection)
    
            # Reset cooldown and test selection again
            validator.cooldown = 0
            final_selection = self.consensus.select_validator([validator])
            self.assertIsNotNone(final_selection)
    
        def test_validation_metrics(self):
            """Test tracking of validation metrics."""
            validator = self._create_test_node("test_validator")
            transactions = [
                Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                ) for i in range(3)
            ]
    
            for i in range(5):
                block = self._create_test_block(transactions)
                self.consensus.validate_block(block, self.genesis_block, validator)
    
            metrics = self.consensus.get_metrics()
            self.assertGreater(metrics["total_validations"], 0)
            self.assertGreater(metrics["successful_validations"], 0)
            self.assertGreaterEqual(metrics["success_rate"], 0)
    
        def test_shard_specific_validation(self):
            """Test validation in a shard-specific context."""
            validator = self._create_test_node("test_validator")
    
            self.assertTrue(validator.can_validate(shard_id=1))
            self.assertFalse(validator.can_validate(shard_id=2))
    
            # Ensure validator selection for a specific shard
            selected = self.consensus.select_validator(self.nodes, shard_id=1)
            if selected:
                self.assertIn(1, selected.shard_assignments)
    
        def test_progressive_reputation_requirements(self):
            """Test progressive reputation requirements for new nodes."""
            new_node = self._create_test_node("new_node")
            new_node.total_validations = 0
    
            # Set lower reputation
            for category in new_node.reputation_scores:
                new_node.reputation_scores[category] = self.consensus.min_reputation * 0.6
    
            self.assertTrue(self.consensus._can_participate(new_node))
    
            # Increase validations and recheck eligibility
            new_node.total_validations = 20
            self.assertFalse(self.consensus._can_participate(new_node))
    
        def test_validator_history(self):
            """Test tracking of validator history."""
            for _ in range(5):
                validator = self.consensus.select_validator(self.nodes)
                if validator:
                    self.assertIn(
                        validator.node_id,
                        [record[0] for record in self.consensus.validator_history]
                    )
    
            # Ensure history length is capped
            for _ in range(1000):
                self.consensus.validator_history.append(("test_node", datetime.now(), 1))
            self.assertLessEqual(len(self.consensus.validator_history), 1000)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/test_block_creation.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List, Dict, Optional
    import hashlib
    import json
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.block import Block
    from blockchain.core.transaction import Transaction
    from blockchain.core.shard import Shard
    from blockchain.core.node import Node
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    class TestBlockCreation(unittest.TestCase):
        """Integration tests for block creation in the ICN blockchain."""
    
        def setUp(self):
            """Set up test environment before each test."""
            self.shard = Shard(shard_id=1, max_transactions_per_block=5)
            self.consensus = ProofOfCooperation()
            self.validator = self._create_test_validator()
            self.test_transactions = self._create_test_transactions()
    
        def _create_test_validator(self) -> Node:
            """Create a test validator node."""
            validator = Node(
                node_id="test_validator",
                cooperative_id="test_coop",
                initial_stake=100.0
            )
            validator.reputation_scores = {
                "validation": 25.0,
                "transaction_validation": 25.0,
                "resource_sharing": 25.0,
                "cooperative_growth": 25.0
            }
            validator.performance_metrics = {
                "availability": 98.0,
                "validation_success_rate": 95.0,
                "network_reliability": 97.0
            }
            validator.assign_to_shard(1)
            return validator
    
        def _create_test_transactions(self) -> List[Transaction]:
            """Create test transactions with varied characteristics."""
            transactions = []
            for i in range(10):
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0 * (i + 1)},
                    shard_id=1,
                    priority=min(i % 5 + 1, 5),
                    cooperative_tags={f"tag_{i}"}
                )
                transactions.append(tx)
            return transactions
    
        def test_basic_block_creation(self):
            """Test creation of a basic valid block."""
            # Add some transactions to the shard
            for tx in self.test_transactions[:3]:
                self.shard.add_transaction(tx)
    
            # Create block
            block = self.shard.create_block(validator="test_validator")
            
            # Verify block properties
            self.assertIsNotNone(block)
            self.assertEqual(block.index, self.shard.height)
            self.assertEqual(block.validator, "test_validator")
            self.assertEqual(block.shard_id, self.shard.shard_id)
            self.assertEqual(len(block.transactions), 3)
            self.assertIsNotNone(block.merkle_root)
            self.assertIsNotNone(block.hash)
            
            # Verify block can be added to shard
            self.assertTrue(self.shard.add_block(block))
            self.assertEqual(self.shard.height, block.index + 1)
    
        def test_transaction_ordering_in_block(self):
            """Test that transactions are properly ordered in block by priority."""
            # Add transactions with different priorities
            for tx in self.test_transactions[:5]:
                self.shard.add_transaction(tx)
    
            block = self.shard.create_block(validator="test_validator")
            self.assertIsNotNone(block)
    
            # Verify transactions are ordered by priority
            for i in range(len(block.transactions) - 1):
                self.assertGreaterEqual(
                    block.transactions[i].priority,
                    block.transactions[i + 1].priority
                )
    
        def test_block_size_limits(self):
            """Test enforcement of block size limits."""
            # Add maximum number of transactions
            for tx in self.test_transactions[:self.shard.max_transactions_per_block]:
                self.shard.add_transaction(tx)
    
            # Create block
            block = self.shard.create_block(validator="test_validator")
            self.assertIsNotNone(block)
            self.assertEqual(len(block.transactions), self.shard.max_transactions_per_block)
    
            # Try to add one more transaction
            extra_tx = self.test_transactions[self.shard.max_transactions_per_block]
            self.shard.add_transaction(extra_tx)
            
            block = self.shard.create_block(validator="test_validator")
            self.assertEqual(len(block.transactions), self.shard.max_transactions_per_block)
    
        def test_cross_shard_block_creation(self):
            """Test creation of blocks with cross-shard transactions."""
            # Create cross-shard transaction
            cross_shard_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0, "target_shard": 2},
                shard_id=1,
                cross_shard_refs=["ref_1"]
            )
            
            # Add transactions
            self.shard.add_transaction(cross_shard_tx)
            for tx in self.test_transactions[:2]:
                self.shard.add_transaction(tx)
    
            # Create block
            block = self.shard.create_block(validator="test_validator")
            self.assertIsNotNone(block)
            
            # Verify cross-shard references
            self.assertIn(cross_shard_tx.transaction_id, 
                         [tx.transaction_id for tx in block.transactions])
            self.assertTrue(block.cross_shard_refs)
    
        def test_block_validation(self):
            """Test comprehensive block validation."""
            # Add transactions
            for tx in self.test_transactions[:3]:
                self.shard.add_transaction(tx)
    
            # Create valid block
            valid_block = self.shard.create_block(validator="test_validator")
            self.assertTrue(valid_block.validate(self.shard.chain[-1]))
    
            # Test with invalid previous hash
            invalid_block = Block(
                index=valid_block.index,
                previous_hash="invalid_hash",
                timestamp=datetime.now(),
                transactions=valid_block.transactions.copy(),
                validator="test_validator",
                shard_id=1
            )
            self.assertFalse(invalid_block.validate(self.shard.chain[-1]))
    
            # Test with future timestamp
            future_block = Block(
                index=valid_block.index,
                previous_hash=valid_block.previous_hash,
                timestamp=datetime.now() + timedelta(hours=1),
                transactions=valid_block.transactions.copy(),
                validator="test_validator",
                shard_id=1
            )
            self.assertFalse(future_block.validate(self.shard.chain[-1]))
    
        def test_merkle_root_calculation(self):
            """Test Merkle root calculation with different transaction sets."""
            # Test with no transactions
            empty_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now(),
                transactions=[],
                validator="test_validator",
                shard_id=1
            )
            self.assertIsNotNone(empty_block.merkle_root)
    
            # Test with one transaction
            single_tx_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now(),
                transactions=[self.test_transactions[0]],
                validator="test_validator",
                shard_id=1
            )
            self.assertIsNotNone(single_tx_block.merkle_root)
            self.assertNotEqual(single_tx_block.merkle_root, empty_block.merkle_root)
    
            # Test with multiple transactions
            multi_tx_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now(),
                transactions=self.test_transactions[:3],
                validator="test_validator",
                shard_id=1
            )
            self.assertIsNotNone(multi_tx_block.merkle_root)
            self.assertNotEqual(multi_tx_block.merkle_root, single_tx_block.merkle_root)
    
        def test_block_metadata(self):
            """Test block metadata handling."""
            # Add transactions
            for tx in self.test_transactions[:3]:
                self.shard.add_transaction(tx)
    
            # Create block with metadata
            block = self.shard.create_block(validator="test_validator")
            block.metadata["test_key"] = "test_value"
    
            # Verify metadata serialization
            block_dict = block.to_dict()
            restored_block = Block.from_dict(block_dict)
            self.assertEqual(restored_block.metadata["test_key"], "test_value")
    
        def test_sequential_block_creation(self):
            """Test creation of sequential blocks."""
            created_blocks = []
            
            # Create several blocks sequentially
            for i in range(3):
                # Add new transactions
                for tx in self.test_transactions[i*3:(i+1)*3]:
                    self.shard.add_transaction(tx)
                    
                # Create and add block
                block = self.shard.create_block(validator="test_validator")
                self.assertTrue(self.shard.add_block(block))
                created_blocks.append(block)
    
            # Verify block sequence
            for i in range(1, len(created_blocks)):
                self.assertEqual(
                    created_blocks[i].previous_hash,
                    created_blocks[i-1].hash
                )
                self.assertEqual(
                    created_blocks[i].index,
                    created_blocks[i-1].index + 1
                )
                self.assertGreater(
                    created_blocks[i].timestamp,
                    created_blocks[i-1].timestamp
                )
    
        def test_resource_impact_tracking(self):
            """Test tracking of resource impact in blocks."""
            # Add transactions with varying resource impacts
            for tx in self.test_transactions[:3]:
                self.shard.add_transaction(tx)
    
            block = self.shard.create_block(validator="test_validator")
            self.assertIsNotNone(block)
    
            # Calculate total resource impact
            total_computation = sum(tx.resource_cost["computation"] for tx in block.transactions)
            total_storage = sum(tx.resource_cost["storage"] for tx in block.transactions)
            total_bandwidth = sum(tx.resource_cost["bandwidth"] for tx in block.transactions)
    
            # Verify reasonable resource usage
            self.assertGreater(total_computation, 0)
            self.assertGreater(total_storage, 0)
            self.assertGreater(total_bandwidth, 0)
    
        def test_cooperative_score_aggregation(self):
            """Test aggregation of cooperative scores in blocks."""
            # Add transactions with varying cooperative scores
            for tx in self.test_transactions[:3]:
                self.shard.add_transaction(tx)
    
            block = self.shard.create_block(validator="test_validator")
            self.assertIsNotNone(block)
    
            # Calculate total cooperative impact
            total_score = sum(tx.get_cooperative_score() for tx in block.transactions)
            
            # Verify positive cooperative impact
            self.assertGreater(total_score, 0)
            self.assertGreater(total_score, len(block.transactions))  # Should be higher than just count
    
    if __name__ == "__main__":
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/test_shard_management.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List, Dict, Set
    import hashlib
    import json
    import random
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.shard import Shard
    from blockchain.core.transaction import Transaction
    from blockchain.core.block import Block
    from blockchain.core.node import Node
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    class TestShardManagement(unittest.TestCase):
        """Integration tests for shard management in the ICN blockchain."""
    
        def setUp(self):
            """Set up test environment before each test."""
            self.main_shard = Shard(shard_id=0, max_transactions_per_block=5)
            self.nodes = self._create_test_nodes()
            self.consensus = ProofOfCooperation()
            self.test_transactions = self._create_test_transactions()
    
        def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
            """Create test nodes with varied capabilities."""
            nodes = []
            for i in range(num_nodes):
                node = Node(
                    node_id=f"node_{i}",
                    cooperative_id="test_coop",
                    initial_stake=100.0
                )
                # Vary node capabilities for modular shards
                node.reputation_scores = {
                    "validation": 20.0 + i * 2,
                    "resource_sharing": 20.0 + i * 2,
                    "cooperative_growth": 20.0 + i * 2,
                    "innovation": 20.0 + i * 2
                }
                node.performance_metrics = {
                    "availability": 95.0 + i,
                    "validation_success_rate": 95.0 + i,
                    "network_reliability": 95.0 + i
                }
                node.assign_to_shard(i % 3)  # Modular shard assignment
                nodes.append(node)
            return nodes
    
        def _create_test_transactions(self, num_transactions: int = 10) -> List[Transaction]:
            """Create test transactions with modular shard adaptation."""
            transactions = []
            for i in range(num_transactions):
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0 * (i + 1)},
                    shard_id=i % 3,  # Adapted for modular shard
                    priority=min(i % 5 + 1, 5),
                    cooperative_tags={f"tag_{i}"}
                )
                transactions.append(tx)
            return transactions
    
        def test_shard_creation_and_initialization(self):
            """Test basic shard creation and initialization."""
            shard = Shard(shard_id=1, max_transactions_per_block=5)
            
            # Verify basic properties
            self.assertEqual(shard.shard_id, 1)
            self.assertEqual(shard.max_transactions_per_block, 5)
            self.assertEqual(shard.height, 1)  # Should start at 1 after genesis
            self.assertTrue(shard.chain)  # Should have genesis block
            
            # Verify genesis block
            genesis = shard.chain[0]
            self.assertEqual(genesis.index, 0)
            self.assertEqual(genesis.previous_hash, "0" * 64)
            self.assertEqual(genesis.validator, "genesis")
            self.assertEqual(genesis.shard_id, 1)
    
        def test_node_shard_assignment(self):
            """Test assigning nodes to shards."""
            shard_1 = Shard(shard_id=1)
            shard_2 = Shard(shard_id=2)
    
            # Assign nodes to shards
            for node in self.nodes[:3]:
                self.assertTrue(node.assign_to_shard(1))
                self.assertIn(1, node.shard_assignments)
    
            for node in self.nodes[2:]:  # Overlapping assignment for node_2
                self.assertTrue(node.assign_to_shard(2))
                self.assertIn(2, node.shard_assignments)
    
            # Verify node can't be assigned to too many shards
            node = self.nodes[0]
            for i in range(5):  # Try to assign to more shards than allowed
                node.assign_to_shard(i)
            self.assertLessEqual(len(node.shard_assignments), 3)
    
        def test_transaction_distribution(self):
            """Test transaction distribution across shards."""
            shards = {i: Shard(shard_id=i) for i in range(3)}
            
            # Add transactions to appropriate shards
            for tx in self.test_transactions:
                shard = shards[tx.shard_id]
                self.assertTrue(shard.add_transaction(tx))
                
            # Verify distribution
            for shard_id, shard in shards.items():
                shard_txs = len(shard.pending_transactions)
                self.assertGreaterEqual(shard_txs, 0)
                self.assertLessEqual(shard_txs, shard.max_transactions_per_block * 2)
    
        def test_cross_shard_transaction_handling(self):
            """Test handling of cross-shard transactions."""
            shard_1 = Shard(shard_id=1)
            shard_2 = Shard(shard_id=2)
    
            # Create cross-shard transaction
            cross_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={
                    "amount": 100.0,
                    "target_shard": 2
                },
                shard_id=1,
                cross_shard_refs=["ref_1"]
            )
    
            # Add to source shard
            self.assertTrue(shard_1.add_transaction(cross_tx))
            
            # Create and verify block with cross-shard transaction
            block = shard_1.create_block("test_validator")
            self.assertIsNotNone(block)
            self.assertTrue(block.cross_shard_refs)
            
            # Verify cross-shard reference tracking
            self.assertIn(2, shard_1.cross_shard_references)
    
        def test_shard_load_balancing(self):
            """Test shard load balancing mechanisms."""
            shards = {i: Shard(shard_id=i) for i in range(3)}
            
            # Add varied load to shards
            for i, tx in enumerate(self.test_transactions):
                # Deliberately overload shard 0
                if i < 5:
                    shards[0].add_transaction(tx)
                else:
                    shard_id = i % 3
                    shards[shard_id].add_transaction(tx)
    
            # Verify load distribution
            load_stats = {
                shard_id: len(shard.pending_transactions) 
                for shard_id, shard in shards.items()
            }
            
            # Check that no shard is overloaded
            for load in load_stats.values():
                self.assertLessEqual(load, Shard.max_transactions_per_block * 2)
    
        def test_shard_state_management(self):
            """Test shard state management and persistence."""
            # Add transactions and create blocks
            for tx in self.test_transactions[:3]:
                self.main_shard.add_transaction(tx)
                
            initial_state = self.main_shard.state.copy()
            
            # Create block
            block = self.main_shard.create_block("test_validator")
            self.assertTrue(self.main_shard.add_block(block))
            
            # Verify state updates
            self.assertNotEqual(self.main_shard.state, initial_state)
            self.assertEqual(self.main_shard.height, 2)  # Genesis + 1
    
            # Test state rollback
            self.main_shard.state = initial_state
            self.assertEqual(self.main_shard.state, initial_state)
    
        def test_shard_synchronization(self):
            """Test synchronization between shards."""
            shard_1 = Shard(shard_id=1)
            shard_2 = Shard(shard_id=2)
    
            # Create cross-shard transaction
            cross_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={
                    "amount": 100.0,
                    "target_shard": 2
                },
                shard_id=1
            )
    
            # Process in source shard
            shard_1.add_transaction(cross_tx)
            block_1 = shard_1.create_block("test_validator")
            shard_1.add_block(block_1)
    
            # Verify target shard can validate cross-shard references
            self.assertIn(2, shard_1.cross_shard_references)
            reference = list(shard_1.cross_shard_references[2])[0]
            self.assertTrue(shard_2.validate_cross_shard_ref(reference))
    
        def test_shard_metrics_and_monitoring(self):
            """Test shard performance metrics and monitoring."""
            # Generate some activity
            for tx in self.test_transactions[:5]:
                self.main_shard.add_transaction(tx)
            
            block = self.main_shard.create_block("test_validator")
            self.main_shard.add_block(block)
    
            # Get metrics
            metrics = self.main_shard.get_metrics()
            
            # Verify metric fields
            self.assertIn("total_transactions", metrics)
            self.assertIn("average_block_time", metrics)
            self.assertIn("pending_count", metrics)
            self.assertIn("chain_size", metrics)
            
            # Verify metric values
            self.assertEqual(metrics["shard_id"], self.main_shard.shard_id)
            self.assertGreater(metrics["total_transactions"], 0)
            self.assertGreaterEqual(metrics["chain_size"], 2)  # Genesis + 1
    
        def test_shard_recovery(self):
            """Test shard recovery from invalid states."""
            # Create some valid state
            for tx in self.test_transactions[:3]:
                self.main_shard.add_transaction(tx)
            
            valid_block = self.main_shard.create_block("test_validator")
            self.main_shard.add_block(valid_block)
            
            # Save valid state
            valid_state = self.main_shard.to_dict()
            
            # Corrupt shard state
            self.main_shard.chain.append("invalid_block")
            self.assertFalse(self.main_shard.validate_chain())
            
            # Recover from valid state
            recovered_shard = Shard.from_dict(valid_state)
            self.assertTrue(recovered_shard.validate_chain())
            self.assertEqual(recovered_shard.height, 2)  # Genesis + 1
    
        def test_shard_consensus_integration(self):
            """Test integration between shard management and consensus."""
            # Assign validators to shard
            validators = self.nodes[:3]
            for node in validators:
                node.assign_to_shard(self.main_shard.shard_id)
    
            # Add transactions
            for tx in self.test_transactions[:3]:
                self.main_shard.add_transaction(tx)
    
            # Select validator and create block
            validator = self.consensus.select_validator(validators, self.main_shard.shard_id)
            self.assertIsNotNone(validator)
            
            block = self.main_shard.create_block(validator.node_id)
            self.assertIsNotNone(block)
            
            # Validate and add block
            self.assertTrue(self.consensus.validate_block(block, self.main_shard.chain[-1], validator))
            self.assertTrue(self.main_shard.add_block(block))
    
    if __name__ == "__main__":
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/test_transaction_processing.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List, Dict, Optional
    import json
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.transaction import Transaction
    from blockchain.core.block import Block
    from blockchain.core.node import Node
    from blockchain.core.blockchain import Blockchain
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    class TestTransactionProcessing(unittest.TestCase):
        """Integration tests for transaction processing in the ICN blockchain."""
    
        def setUp(self):
            """Set up test environment before each test."""
            self.test_transactions = self._create_test_transactions()
    
        def _create_test_transactions(self, num_transactions: int = 5) -> List[Transaction]:
            """Create test transactions with varied characteristics."""
            transactions = []
            for i in range(num_transactions):
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={"amount": 10.0 * (i + 1)},
                    shard_id=i % 3,  # Use fixed number of shards for testing
                    priority=min(i + 1, 5),
                    cooperative_tags={f"tag_{i}"},
                    cross_shard_refs=[f"ref_{j}" for j in range(i % 3)]
                )
                transactions.append(tx)
            return transactions
    
        def test_transaction_creation_and_validation(self):
            """Test basic transaction creation and validation."""
            # Test valid transaction
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                priority=1
            )
            self.assertTrue(tx.validate())
            self.assertIsNotNone(tx.transaction_id)
    
            # Test invalid action
            with self.assertRaises(ValueError):
                Transaction(
                    sender="user1",
                    receiver="user2",
                    action="invalid_action",
                    data={"amount": 100.0},
                    shard_id=0
                )
    
            # Test invalid priority
            with self.assertRaises(ValueError):
                Transaction(
                    sender="user1",
                    receiver="user2",
                    action="transfer",
                    data={"amount": 100.0},
                    shard_id=0,
                    priority=10  # Invalid priority
                )
    
        def test_transaction_data_limits(self):
            """Test transaction data size limits."""
            # Test transaction with data at limit
            large_data = {"data": "x" * (Transaction.MAX_DATA_SIZE - 100)}  # Leave room for other fields
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="store",
                data=large_data,
                shard_id=0
            )
            self.assertTrue(tx.validate())
    
            # Test transaction exceeding data limit
            too_large_data = {"data": "x" * (Transaction.MAX_DATA_SIZE + 1000)}
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="store",
                data=too_large_data,
                shard_id=0
            )
            self.assertFalse(tx.validate())
    
        def test_cross_shard_functionality(self):
            """Test cross-shard transaction handling."""
            # Create cross-shard transaction
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={
                    "amount": 100.0,
                    "target_shard": 1
                },
                shard_id=0,
                cross_shard_refs=["ref_1", "ref_2"]
            )
    
            # Test cross-shard detection
            self.assertTrue(tx.is_cross_shard())
            self.assertEqual(tx.get_target_shards(), {0, 1})
    
            # Test cross-shard reference limit
            tx_many_refs = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                cross_shard_refs=["ref_" + str(i) for i in range(Transaction.MAX_CROSS_SHARD_REFS + 1)]
            )
            self.assertFalse(tx_many_refs.validate())
    
        def test_resource_cost_calculation(self):
            """Test resource cost calculation."""
            # Test basic resource cost
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0
            )
            self.assertGreater(tx.get_resource_impact(), 0)
            
            # Test increased cost with large data
            large_data = {"data": "x" * 10000}
            tx_large = Transaction(
                sender="user1",
                receiver="user2",
                action="store",
                data=large_data,
                shard_id=0
            )
            self.assertGreater(tx_large.get_resource_impact(), tx.get_resource_impact())
    
            # Test cross-shard overhead
            tx_cross_shard = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                cross_shard_refs=["ref_1", "ref_2"]
            )
            self.assertGreater(tx_cross_shard.get_resource_impact(), tx.get_resource_impact())
    
        def test_cooperative_score(self):
            """Test cooperative score calculation."""
            # Basic transaction
            tx_basic = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0
            )
            base_score = tx_basic.get_cooperative_score()
    
            # Transaction with cooperative tags
            tx_cooperative = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                cooperative_tags={"sharing", "community"}
            )
            self.assertGreater(tx_cooperative.get_cooperative_score(), base_score)
    
            # Cross-shard transaction
            tx_cross_shard = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0, "target_shard": 1},
                shard_id=0
            )
            self.assertGreater(tx_cross_shard.get_cooperative_score(), base_score)
    
        def test_serialization(self):
            """Test transaction serialization and deserialization."""
            original_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                priority=2,
                cooperative_tags={"tag1", "tag2"},
                cross_shard_refs=["ref_1"]
            )
    
            # Convert to dictionary
            tx_dict = original_tx.to_dict()
    
            # Create new transaction from dictionary
            restored_tx = Transaction.from_dict(tx_dict)
    
            # Verify all attributes match
            self.assertEqual(restored_tx.transaction_id, original_tx.transaction_id)
            self.assertEqual(restored_tx.sender, original_tx.sender)
            self.assertEqual(restored_tx.receiver, original_tx.receiver)
            self.assertEqual(restored_tx.action, original_tx.action)
            self.assertEqual(restored_tx.data, original_tx.data)
            self.assertEqual(restored_tx.shard_id, original_tx.shard_id)
            self.assertEqual(restored_tx.priority, original_tx.priority)
            self.assertEqual(restored_tx.cooperative_tags, original_tx.cooperative_tags)
            self.assertEqual(restored_tx.cross_shard_refs, original_tx.cross_shard_refs)
    
        def test_metadata_handling(self):
            """Test transaction metadata handling."""
            tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0
            )
    
            # Verify required metadata fields
            self.assertIn("created_at", tx.metadata)
            self.assertIn("data_size", tx.metadata)
            self.assertIn("version", tx.metadata)
    
            # Verify metadata persistence through serialization
            tx_dict = tx.to_dict()
            restored_tx = Transaction.from_dict(tx_dict)
            
            # Compare metadata fields individually, ignoring timestamp precision
            self.assertEqual(
                tx.metadata["data_size"], 
                restored_tx.metadata["data_size"]
            )
            self.assertEqual(
                tx.metadata["version"], 
                restored_tx.metadata["version"]
            )
            
            # For timestamp, verify format and rough equality
            original_time = datetime.fromisoformat(tx.metadata["created_at"])
            restored_time = datetime.fromisoformat(restored_tx.metadata["created_at"])
            
            # Should be within 1 second of each other
            self.assertLess(
                abs((original_time - restored_time).total_seconds()),
                1.0
            )
            
        def test_timestamp_validation(self):
            """Test transaction timestamp validation."""
            # Current timestamp should be valid
            tx_current = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                timestamp=datetime.now()
            )
            self.assertTrue(tx_current.validate())
    
            # Future timestamp should be invalid
            tx_future = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                timestamp=datetime.now() + timedelta(minutes=10)
            )
            self.assertFalse(tx_future.validate())
    
            # Old timestamp should be invalid
            tx_old = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 100.0},
                shard_id=0,
                timestamp=datetime.now() - timedelta(days=2)
            )
            self.assertFalse(tx_old.validate())
    
        def test_transaction_ordering(self):
            """Test transaction ordering by priority."""
            # Create transactions with different priorities
            transactions = []
            for i in range(1, 6):
                tx = Transaction(
                    sender=f"user{i}",
                    receiver=f"user{i+1}",
                    action="transfer",
                    data={"amount": 100.0},
                    shard_id=0,
                    priority=i
                )
                transactions.append(tx)
    
            # Shuffle and sort by priority
            import random
            random.shuffle(transactions)
            sorted_transactions = sorted(transactions, key=lambda x: x.priority, reverse=True)
    
            # Verify order
            for i in range(len(sorted_transactions) - 1):
                self.assertGreaterEqual(
                    sorted_transactions[i].priority,
                    sorted_transactions[i + 1].priority
                )
    
    if __name__ == "__main__":
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/test_smart_contract_execution.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List, Dict, Optional
    import asyncio
    import json
    import hashlib
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.contracts.smart_contract import SmartContract, ContractExecutionError
    from blockchain.contracts.contract_executor import ContractExecutor
    from blockchain.core.node import Node
    from blockchain.core.shard import Shard
    
    class TestSmartContractExecution(unittest.TestCase):
        """Integration tests for smart contract execution in the ICN blockchain."""
    
        def setUp(self):
            """Set up test environment before each test."""
            self.executor = ContractExecutor(initial_mana=1000)
            self.test_node = self._create_test_node()
            
            # Basic test contract for reuse
            self.basic_contract = self._create_test_contract("basic_contract")
            
            # Set up async event loop
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
    
        def tearDown(self):
            """Clean up after tests."""
            self.loop.close()
    
        def _create_test_node(self) -> Node:
            """Create a test node for contract interactions."""
            node = Node(
                node_id="test_node",
                cooperative_id="test_coop",
                initial_stake=100.0
            )
            node.reputation_scores = {
                "validation": 25.0,
                "resource_sharing": 25.0,
                "cooperative_growth": 25.0,
                "innovation": 25.0
            }
            return node
    
        def _create_test_contract(self, contract_id: str, mana_cost: int = 10) -> SmartContract:
            """Create a test smart contract."""
            code = """
    def execute(input_data, state):
        # Initialize state if needed
        if 'count' not in state:
            state['count'] = 0
        if 'values' not in state:
            state['values'] = []
            
        # Process input
        value = input_data.get('value', 0)
        operation = input_data.get('operation', 'add')
        
        if operation == 'add':
            state['values'].append(value)
            state['count'] += 1
            return {'result': value, 'count': state['count']}
        elif operation == 'sum':
            total = sum(state['values'])
            return {'result': total, 'count': state['count']}
        elif operation == 'clear':
            state['values'] = []
            state['count'] = 0
            return {'result': None, 'count': 0}
        else:
            raise ValueError(f"Unknown operation: {operation}")
    """
            return SmartContract(
                contract_id=contract_id,
                code=code,
                creator="test_creator",
                mana_cost=mana_cost
            )
    
        async def test_basic_contract_execution(self):
            """Test basic contract deployment and execution."""
            # Deploy contract
            success = await self.executor.deploy_contract(self.basic_contract)
            self.assertTrue(success)
    
            # Execute contract with different operations
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"value": 42, "operation": "add"},
                "test_creator"
            )
            self.assertEqual(result["result"]["result"], 42)
            self.assertEqual(result["result"]["count"], 1)
    
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"value": 58, "operation": "add"},
                "test_creator"
            )
            self.assertEqual(result["result"]["count"], 2)
    
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"operation": "sum"},
                "test_creator"
            )
            self.assertEqual(result["result"]["result"], 100)
    
        async def test_mana_consumption(self):
            """Test mana consumption and regeneration."""
            initial_mana = self.executor.mana_pool
    
            # Deploy and execute contract
            await self.executor.deploy_contract(self.basic_contract)
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"value": 42, "operation": "add"},
                "test_creator"
            )
    
            # Verify mana consumption
            self.assertEqual(
                self.executor.mana_pool,
                initial_mana - self.basic_contract.mana_cost
            )
    
            # Test mana regeneration
            await self.executor.regenerate_mana()
            self.assertGreater(self.executor.mana_pool, initial_mana - self.basic_contract.mana_cost)
    
        async def test_state_persistence(self):
            """Test contract state persistence across executions."""
            await self.executor.deploy_contract(self.basic_contract)
    
            # Add values
            for i in range(3):
                await self.executor.execute_contract(
                    self.basic_contract.contract_id,
                    {"value": i * 10, "operation": "add"},
                    "test_creator"
                )
    
            # Verify state
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"operation": "sum"},
                "test_creator"
            )
            self.assertEqual(result["result"]["result"], 30)  # 0 + 10 + 20
            self.assertEqual(result["result"]["count"], 3)
    
            # Clear state
            result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"operation": "clear"},
                "test_creator"
            )
            self.assertEqual(result["result"]["count"], 0)
    
        async def test_concurrent_execution(self):
            """Test concurrent contract execution."""
            await self.executor.deploy_contract(self.basic_contract)
    
            # Create multiple execution tasks
            tasks = []
            for i in range(5):
                task = self.executor.execute_contract(
                    self.basic_contract.contract_id,
                    {"value": i * 10, "operation": "add"},
                    "test_creator"
                )
                tasks.append(task)
    
            # Execute concurrently
            results = await asyncio.gather(*tasks)
            
            # Verify results
            self.assertEqual(len(results), 5)
            
            # Verify final state
            sum_result = await self.executor.execute_contract(
                self.basic_contract.contract_id,
                {"operation": "sum"},
                "test_creator"
            )
            self.assertEqual(sum_result["result"]["result"], 100)  # 0 + 10 + 20 + 30 + 40
    
        async def test_error_handling(self):
            """Test contract error handling."""
            await self.executor.deploy_contract(self.basic_contract)
    
            # Test invalid operation
            with self.assertRaises(ContractExecutionError):
                await self.executor.execute_contract(
                    self.basic_contract.contract_id,
                    {"operation": "invalid_op"},
                    "test_creator"
                )
    
            # Test insufficient mana
            expensive_contract = self._create_test_contract("expensive", mana_cost=2000)
            await self.executor.deploy_contract(expensive_contract)
            
            with self.assertRaises(ContractExecutionError):
                await self.executor.execute_contract(
                    expensive_contract.contract_id,
                    {"value": 1, "operation": "add"},
                    "test_creator"
                )
    
        async def test_resource_limits(self):
            """Test contract resource limits."""
            # Create contract that tests limits
            resource_heavy_code = """
    def execute(input_data, state):
        # Test memory limit
        if input_data.get('test_memory', False):
            big_list = list(range(1000000))  # Should exceed memory limit
            
        # Test computation limit
        if input_data.get('test_computation', False):
            n = 100
            result = [[i*j for j in range(n)] for i in range(n)]
            
        return {"status": "completed"}
    """
            resource_contract = SmartContract(
                contract_id="resource_test",
                code=resource_heavy_code,
                creator="test_creator",
                mana_cost=20
            )
    
            await self.executor.deploy_contract(resource_contract)
    
            # Test memory limit
            with self.assertRaises(ContractExecutionError):
                await self.executor.execute_contract(
                    resource_contract.contract_id,
                    {"test_memory": True},
                    "test_creator"
                )
    
            # Test computation limit
            with self.assertRaises(ContractExecutionError):
                await self.executor.execute_contract(
                    resource_contract.contract_id,
                    {"test_computation": True},
                    "test_creator"
                )
    
        async def test_cooperative_features(self):
            """Test cooperative aspects of contract execution."""
            # Create contract with cooperative features
            coop_code = """
    def execute(input_data, state):
        if 'shared_resources' not in state:
            state['shared_resources'] = {}
        
        action = input_data.get('action')
        resource = input_data.get('resource')
        amount = input_data.get('amount', 0)
        
        if action == 'share':
            if resource not in state['shared_resources']:
                state['shared_resources'][resource] = 0
            state['shared_resources'][resource] += amount
            return {
                'status': 'shared',
                'resource': resource,
                'total': state['shared_resources'][resource]
            }
        elif action == 'use':
            if resource not in state['shared_resources']:
                raise ValueError(f"Resource {resource} not available")
            if state['shared_resources'][resource] < amount:
                raise ValueError(f"Insufficient {resource}")
            state['shared_resources'][resource] -= amount
            return {
                'status': 'used',
                'resource': resource,
                'remaining': state['shared_resources'][resource]
            }
                
        return {'status': 'error', 'message': 'Invalid action'}
    """
            coop_contract = SmartContract(
                contract_id="cooperative_test",
                code=coop_code,
                creator="test_creator",
                mana_cost=15
            )
    
            await self.executor.deploy_contract(coop_contract)
    
            # Test resource sharing
            result = await self.executor.execute_contract(
                coop_contract.contract_id,
                {
                    "action": "share",
                    "resource": "cpu_time",
                    "amount": 100
                },
                "test_creator"
            )
            self.assertEqual(result["result"]["total"], 100)
    
            # Test resource usage
            result = await self.executor.execute_contract(
                coop_contract.contract_id,
                {
                    "action": "use",
                    "resource": "cpu_time",
                    "amount": 30
                },
                "test_creator"
            )
            self.assertEqual(result["result"]["remaining"], 70)
    
            # Test insufficient resources
            with self.assertRaises(ContractExecutionError):
                await self.executor.execute_contract(
                    coop_contract.contract_id,
                    {
                        "action": "use",
                        "resource": "cpu_time",
                        "amount": 100
                    },
                    "test_creator"
                )
    
        def test_contract_metrics(self):
            """Test contract execution metrics tracking."""
            async def run_metrics_test():
                await self.executor.deploy_contract(self.basic_contract)
    
                # Execute contract multiple times
                for i in range(5):
                    await self.executor.execute_contract(
                        self.basic_contract.contract_id,
                        {"value": i, "operation": "add"},
                        "test_creator"
                    )
    
                # Get metrics
                metrics = self.basic_contract.get_metrics()
                
                # Verify metrics
                self.assertEqual(metrics["execution_count"], 5)
                self.assertGreater(metrics["total_mana_consumed"], 0)
                self.assertIsNotNone(metrics["last_executed"])
                self.assertGreater(metrics["state_size"], 0)
    
            self.loop.run_until_complete(run_metrics_test())
    
        def test_contract_authorization(self):
            """Test contract authorization controls."""
            async def run_auth_test():
                await self.executor.deploy_contract(self.basic_contract)
    
                # Test unauthorized execution
                with self.assertRaises(ContractExecutionError):
                    await self.executor.execute_contract(
                        self.basic_contract.contract_id,
                        {"value": 1, "operation": "add"},
                        "unauthorized_user"
                    )
    
                # Add authorized user
                self.basic_contract.authorize_caller("new_user")
                
                # Test authorized execution
                result = await self.executor.execute_contract(
                    self.basic_contract.contract_id,
                    {"value": 1, "operation": "add"},
                    "new_user"
                )
                self.assertIsNotNone(result)
    
            self.loop.run_until_complete(run_auth_test())
    
    if __name__ == "__main__":
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/integration/__init__.py

```py

```

# File: /home/matt/icn-prototype/tests/performance/test_scalability.py

```py
    import unittest
    import sys
    import os
    import random
    from typing import List
    import time
    import tqdm
    from contextlib import contextmanager
    import psutil
    import gc
    import logging
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.shard import Shard, ShardConfig
    from blockchain.core.transaction import Transaction
    from blockchain.core.node import Node
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    class TestScalability(unittest.TestCase):
        """Test scalability characteristics of the ICN blockchain."""
    
        TIMEOUT_TRANSACTION_TEST = 30
        TIMEOUT_SHARD_TEST = 30
        TIMEOUT_CROSS_SHARD_TEST = 30
        MAX_MEMORY_PERCENT = 80  # Max memory usage threshold
        MAX_RETRIES = 1000  # Max retry limit for block creation
    
        def setUp(self):
            """Set up test environment."""
            logger.info("Setting up scalability test environment...")
            self.config = ShardConfig(
                max_transactions_per_block=100,
                max_pending_transactions=500,
                max_cross_shard_refs=10
            )
            self.shards = [Shard(shard_id=i, config=self.config) for i in range(3)]
            self.nodes = self._create_test_nodes(6)
            self.consensus = ProofOfCooperation()
            logger.info("Setup complete.")
    
        def tearDown(self):
            """Clean up after each test."""
            self.shards = None
            self.nodes = None
            self.consensus = None
            gc.collect()
    
        def _create_test_nodes(self, num_nodes: int) -> List[Node]:
            """Create test nodes with varied capabilities."""
            nodes = []
            for i in range(num_nodes):
                node = Node(
                    node_id=f"node_{i}",
                    cooperative_id=f"coop_{i % 2}",
                    initial_stake=100.0
                )
                node.reputation_scores = {
                    "validation": 20.0 + i,
                    "resource_sharing": 20.0 + i * 0.5,
                    "cooperative_growth": 20.0 + i * 0.3,
                    "innovation": 20.0 + i * 0.2
                }
                shard_id = i % len(self.shards)
                node.assign_to_shard(shard_id)
                nodes.append(node)
            return nodes
    
        def _check_memory_usage(self):
            """Check current memory usage and raise exception if too high."""
            process = psutil.Process(os.getpid())
            memory_percent = process.memory_percent()
            if memory_percent > self.MAX_MEMORY_PERCENT:
                raise MemoryError(f"Memory usage too high: {memory_percent:.1f}%")
            return memory_percent
    
        @contextmanager
        def timeout(self, seconds, test_name):
            """Context manager for test timeouts."""
            start_time = time.time()
            try:
                yield
            finally:
                elapsed_time = time.time() - start_time
                if elapsed_time > seconds:
                    logger.warning(f"{test_name} timed out after {seconds} seconds")
                else:
                    logger.info(f"{test_name} completed in {elapsed_time:.2f} seconds")
    
        def _process_transactions(self, transactions: List[Transaction], batch_size: int):
            """Process transactions in batches with memory checks."""
            with tqdm.tqdm(total=len(transactions), desc="Processing Transactions", leave=True, dynamic_ncols=True) as progress_bar:
                for i in range(0, len(transactions), batch_size):
                    batch = transactions[i:i + batch_size]
                    for tx in batch:
                        shard_id = tx.shard_id
                        self.shards[shard_id].add_transaction(tx)
                    self._check_memory_usage()
                    progress_bar.update(len(batch))
                    gc.collect()
    
        def _create_and_add_blocks(self, shard, validators):
            """Create and add blocks until no pending transactions remain."""
            retry_count = 0
            while shard.pending_transactions and retry_count < self.MAX_RETRIES:
                validator = self.consensus.select_validator(validators)
                if validator:
                    block = shard.create_block(validator.node_id)
                    if block:
                        shard.add_block(block)
                retry_count += 1
                gc.collect()
            if retry_count == self.MAX_RETRIES:
                logger.warning(f"Max retries reached for shard {shard.shard_id}, some transactions may remain unprocessed.")
    
        def test_transaction_throughput_scaling(self):
            """Test how transaction throughput scales with increasing load."""
            logger.info("\nTesting transaction throughput scaling...")
            transaction_counts = [50, 100, 200]
            results = {}
    
            for count in transaction_counts:
                logger.info(f"\nProcessing {count} transactions...")
                transactions = self._generate_test_transactions(count)
    
                with self.timeout(self.TIMEOUT_TRANSACTION_TEST, f"Transaction test (count: {count})"):
                    start_time = time.time()
                    self._process_transactions(transactions, batch_size=10)
    
                    for shard in self.shards:
                        validators = [n for n in self.nodes if shard.shard_id in n.shard_assignments]
                        self._create_and_add_blocks(shard, validators)
    
                    elapsed_time = time.time() - start_time
                    transactions_per_second = count / elapsed_time
                    results[count] = {
                        "elapsed_time": elapsed_time,
                        "tps": transactions_per_second
                    }
                    logger.info(f"Completed {count} transactions at {transactions_per_second:.2f} TPS")
    
            for i in range(len(transaction_counts) - 1):
                count_ratio = transaction_counts[i + 1] / transaction_counts[i]
                time_ratio = results[transaction_counts[i + 1]]["elapsed_time"] / results[transaction_counts[i]]["elapsed_time"]
                self.assertLess(time_ratio, count_ratio * 1.5)
    
        def test_shard_scaling(self):
            """Test how system performance scales with number of shards."""
            logger.info("\nTesting shard scaling...")
            transaction_count = 100
            shard_counts = [1, 2, 4]
            results = {}
    
            base_transactions = self._generate_test_transactions(transaction_count)
    
            for shard_count in shard_counts:
                logger.info(f"\nTesting with {shard_count} shards...")
                test_shards = [Shard(shard_id=i, config=self.config) for i in range(shard_count)]
                test_nodes = self._create_test_nodes(shard_count * 2)
    
                with self.timeout(self.TIMEOUT_SHARD_TEST, f"Shard test (count: {shard_count})"):
                    start_time = time.time()
    
                    self._process_transactions(base_transactions, batch_size=10)
    
                    for shard in test_shards:
                        validators = [n for n in test_nodes if shard.shard_id in n.shard_assignments]
                        self._create_and_add_blocks(shard, validators)
    
                    elapsed_time = time.time() - start_time
                    results[shard_count] = {
                        "elapsed_time": elapsed_time,
                        "tps": transaction_count / elapsed_time
                    }
                    logger.info(f"Completed test with {shard_count} shards at {transaction_count / elapsed_time:.2f} TPS")
    
            for i in range(len(shard_counts) - 1):
                shard_ratio = shard_counts[i + 1] / shard_counts[i]
                speedup = results[shard_counts[i]]["elapsed_time"] / results[shard_counts[i + 1]]["elapsed_time"]
                expected_speedup = shard_ratio * 0.4
                if speedup < expected_speedup:
                    logger.warning(f"Speedup of {speedup:.2f} is less than expected ({expected_speedup:.2f})")
                self.assertGreater(speedup, expected_speedup)
    
        def test_cross_shard_scalability(self):
            """Test scalability of cross-shard transactions."""
            logger.info("\nTesting cross-shard scalability...")
            transaction_count = 100
            cross_shard_percentages = [0, 20, 40]
            results = {}
    
            for percentage in cross_shard_percentages:
                logger.info(f"\nTesting with {percentage}% cross-shard transactions...")
                transactions = self._generate_test_transactions(transaction_count, cross_shard_percentage=percentage)
    
                with self.timeout(self.TIMEOUT_CROSS_SHARD_TEST, f"Cross-shard test (percentage: {percentage}%)"):
                    start_time = time.time()
                    self._process_transactions(transactions, batch_size=10)
    
                    for shard in self.shards:
                        validators = [n for n in self.nodes if shard.shard_id in n.shard_assignments]
                        self._create_and_add_blocks(shard, validators)
    
                    elapsed_time = time.time() - start_time
                    transactions_per_second = transaction_count / elapsed_time
                    results[percentage] = {
                        "elapsed_time": elapsed_time,
                        "tps": transactions_per_second
                    }
                    logger.info(f"Completed {percentage}% cross-shard test at {transactions_per_second:.2f} TPS")
    
            base_time = results[0]["elapsed_time"]
            for percentage in cross_shard_percentages[1:]:
                self.assertLess(results[percentage]["elapsed_time"] / base_time, 3.0)
    
        def _generate_test_transactions(self, count: int, cross_shard_percentage: int = 0) -> List[Transaction]:
            """Generate test transactions with specified cross-shard percentage."""
            transactions = []
            for i in range(count):
                is_cross_shard = random.randint(1, 100) <= cross_shard_percentage
    
                shard_id = random.randint(0, len(self.shards) - 1)
                target_shard = None
                cross_shard_refs = []
    
                if is_cross_shard:
                    target_shard = random.randint(0, len(self.shards) - 1)
                    while target_shard == shard_id:
                        target_shard = random.randint(0, len(self.shards) - 1)
                    cross_shard_refs = [f"ref_{i}"]
    
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={
                        "amount": random.uniform(1, 100),
                        "target_shard": target_shard
                    } if is_cross_shard else {
                        "amount": random.uniform(1, 100)
                    },
                    shard_id=shard_id,
                    priority=random.randint(1, 5),
                    cross_shard_refs=cross_shard_refs
                )
                transactions.append(tx)
    
            return transactions
    
    if __name__ == '__main__':
        unittest.main(verbosity=2)
```

# File: /home/matt/icn-prototype/tests/performance/test_stress_resilience.py

```py
    # tests/performance/test_scalability.py
    
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    import random
    from typing import List, Dict
    import time
    import tqdm
    from contextlib import contextmanager
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.shard import Shard, ShardConfig
    from blockchain.core.transaction import Transaction
    from blockchain.core.block import Block
    from blockchain.core.node import Node
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    class TestScalability(unittest.TestCase):
        """Test scalability characteristics of the ICN blockchain."""
        
        # Maximum time for each test in seconds
        TIMEOUT_TRANSACTION_TEST = 60
        TIMEOUT_SHARD_TEST = 60
        TIMEOUT_CROSS_SHARD_TEST = 60
    
        def setUp(self):
            """Set up test environment."""
            print("\nSetting up scalability test environment...")
            self.config = ShardConfig(
                max_transactions_per_block=1000,
                max_pending_transactions=5000,
                max_cross_shard_refs=100
            )
            self.shards = [Shard(shard_id=i, config=self.config) for i in range(5)]
            self.nodes = self._create_test_nodes(20)  # 20 nodes across shards
            self.consensus = ProofOfCooperation()
            print("Setup complete.")
    
        def _create_test_nodes(self, num_nodes: int) -> List[Node]:
            """Create test nodes with varied capabilities."""
            nodes = []
            for i in range(num_nodes):
                node = Node(
                    node_id=f"node_{i}",
                    cooperative_id=f"coop_{i % 3}",  # Distribute across 3 cooperatives
                    initial_stake=100.0
                )
                # Vary node capabilities
                node.reputation_scores = {
                    "validation": 20.0 + i,
                    "resource_sharing": 20.0 + i * 0.5,
                    "cooperative_growth": 20.0 + i * 0.3,
                    "innovation": 20.0 + i * 0.2
                }
                # Assign to random shard
                shard_id = random.randint(0, len(self.shards) - 1)
                node.assign_to_shard(shard_id)
                nodes.append(node)
            return nodes
    
        @contextmanager
        def timeout(self, seconds, test_name):
            """Context manager for test timeouts with progress bar."""
            start_time = time.time()
            progress_bar = tqdm.tqdm(total=seconds, desc=f"Running {test_name}", 
                                    unit="s", leave=True)
    
            def update_progress():
                elapsed = int(time.time() - start_time)
                if elapsed <= seconds:
                    progress_bar.n = elapsed
                    progress_bar.refresh()
    
            try:
                while True:
                    if time.time() - start_time > seconds:
                        raise TimeoutError(f"Test {test_name} timed out after {seconds} seconds")
                    update_progress()
                    yield
                    break
            finally:
                progress_bar.close()
    
        def test_transaction_throughput_scaling(self):
            """Test how transaction throughput scales with increasing load."""
            print("\nTesting transaction throughput scaling...")
            transaction_counts = [100, 500, 1000]  # Reduced counts for faster testing
            results = {}
    
            for count in transaction_counts:
                print(f"\nProcessing {count} transactions...")
                with self.timeout(self.TIMEOUT_TRANSACTION_TEST, f"Transaction test (count: {count})"):
                    # Generate test transactions
                    transactions = self._generate_test_transactions(count)
                    
                    # Measure processing time
                    start_time = time.time()
                    
                    # Process transactions with progress bar
                    for tx in tqdm.tqdm(transactions, desc="Adding transactions", leave=False):
                        shard_id = tx.shard_id
                        self.shards[shard_id].add_transaction(tx)
    
                    # Process blocks with progress bar
                    pending_blocks = True
                    while pending_blocks:
                        pending_blocks = False
                        for shard in self.shards:
                            if len(shard.pending_transactions) > 0:
                                pending_blocks = True
                                validator = self.consensus.select_validator(
                                    [n for n in self.nodes if shard.shard_id in n.shard_assignments]
                                )
                                if validator:
                                    block = shard.create_block(validator.node_id)
                                    if block:
                                        shard.add_block(block)
    
                    elapsed_time = time.time() - start_time
                    transactions_per_second = count / elapsed_time
                    
                    results[count] = {
                        "elapsed_time": elapsed_time,
                        "tps": transactions_per_second
                    }
                    print(f"Completed {count} transactions at {transactions_per_second:.2f} TPS")
    
            # Verify scaling characteristics
            for i in range(len(transaction_counts) - 1):
                count_ratio = transaction_counts[i + 1] / transaction_counts[i]
                time_ratio = results[transaction_counts[i + 1]]["elapsed_time"] / \
                            results[transaction_counts[i]]["elapsed_time"]
                
                # Time increase should be less than proportional to transaction increase
                self.assertLess(time_ratio, count_ratio * 1.5)
    
        def test_shard_scaling(self):
            """Test how system performance scales with number of shards."""
            print("\nTesting shard scaling...")
            transaction_count = 500  # Reduced for faster testing
            shard_counts = [1, 2, 4]  # Reduced counts for faster testing
            results = {}
    
            base_transactions = self._generate_test_transactions(transaction_count)
    
            for shard_count in shard_counts:
                print(f"\nTesting with {shard_count} shards...")
                with self.timeout(self.TIMEOUT_SHARD_TEST, f"Shard test (count: {shard_count})"):
                    test_shards = [Shard(shard_id=i, config=self.config) 
                                  for i in range(shard_count)]
                    test_nodes = self._create_test_nodes(shard_count * 4)
                    
                    start_time = time.time()
                    
                    # Process transactions with progress bar
                    for tx in tqdm.tqdm(base_transactions, desc="Processing transactions", leave=False):
                        tx.shard_id = random.randint(0, shard_count - 1)
                        test_shards[tx.shard_id].add_transaction(tx)
    
                    # Process blocks
                    pending_blocks = True
                    with tqdm.tqdm(desc="Processing blocks", leave=False) as pbar:
                        while pending_blocks:
                            pending_blocks = False
                            for shard in test_shards:
                                if len(shard.pending_transactions) > 0:
                                    pending_blocks = True
                                    validator = self.consensus.select_validator(
                                        [n for n in test_nodes if shard.shard_id in n.shard_assignments]
                                    )
                                    if validator:
                                        block = shard.create_block(validator.node_id)
                                        if block:
                                            shard.add_block(block)
                            pbar.update(1)
    
                    elapsed_time = time.time() - start_time
                    results[shard_count] = {
                        "elapsed_time": elapsed_time,
                        "tps": transaction_count / elapsed_time
                    }
                    print(f"Completed test with {shard_count} shards at {transaction_count / elapsed_time:.2f} TPS")
    
            # Verify scaling efficiency
            for i in range(len(shard_counts) - 1):
                shard_ratio = shard_counts[i + 1] / shard_counts[i]
                speedup = results[shard_counts[i]]["elapsed_time"] / \
                         results[shard_counts[i + 1]]["elapsed_time"]
                
                # Should achieve at least 50% of perfect linear speedup
                self.assertGreater(speedup, shard_ratio * 0.5)
    
        def test_cross_shard_scalability(self):
            """Test scalability of cross-shard transactions."""
            print("\nTesting cross-shard scalability...")
            transaction_count = 500  # Reduced for faster testing
            cross_shard_percentages = [0, 20, 50]  # Reduced for faster testing
            results = {}
    
            for percentage in cross_shard_percentages:
                print(f"\nTesting with {percentage}% cross-shard transactions...")
                with self.timeout(self.TIMEOUT_CROSS_SHARD_TEST, 
                                f"Cross-shard test (percentage: {percentage}%)"):
                    transactions = self._generate_test_transactions(
                        transaction_count, 
                        cross_shard_percentage=percentage
                    )
                    
                    start_time = time.time()
                    
                    # Process transactions with progress bar
                    for tx in tqdm.tqdm(transactions, desc="Processing transactions", leave=False):
                        shard_id = tx.shard_id
                        self.shards[shard_id].add_transaction(tx)
    
                    # Process blocks
                    pending_shards = set(range(len(self.shards)))
                    with tqdm.tqdm(desc="Processing blocks", leave=False) as pbar:
                        while pending_shards:
                            for shard_id in list(pending_shards):
                                shard = self.shards[shard_id]
                                if not shard.pending_transactions:
                                    pending_shards.remove(shard_id)
                                    continue
                                    
                                validator = self.consensus.select_validator(
                                    [n for n in self.nodes if shard_id in n.shard_assignments]
                                )
                                if validator:
                                    block = shard.create_block(validator.node_id)
                                    if block:
                                        shard.add_block(block)
                            pbar.update(1)
    
                    elapsed_time = time.time() - start_time
                    results[percentage] = {
                        "elapsed_time": elapsed_time,
                        "tps": transaction_count / elapsed_time
                    }
                    print(f"Completed {percentage}% cross-shard test at {transaction_count / elapsed_time:.2f} TPS")
    
            # Verify cross-shard scaling characteristics
            base_time = results[0]["elapsed_time"]
            for percentage in cross_shard_percentages[1:]:
                # Even at 50% cross-shard, shouldn't be more than 3x slower
                self.assertLess(
                    results[percentage]["elapsed_time"] / base_time,
                    3.0
                )
    
        def _generate_test_transactions(
            self, 
            count: int, 
            cross_shard_percentage: int = 0
        ) -> List[Transaction]:
            """Generate test transactions with specified cross-shard percentage."""
            transactions = []
            for i in range(count):
                # Determine if this should be a cross-shard transaction
                is_cross_shard = random.randint(1, 100) <= cross_shard_percentage
                
                shard_id = random.randint(0, len(self.shards) - 1)
                target_shard = None
                cross_shard_refs = []
                
                if is_cross_shard:
                    target_shard = random.randint(0, len(self.shards) - 1)
                    while target_shard == shard_id:
                        target_shard = random.randint(0, len(self.shards) - 1)
                    cross_shard_refs = [f"ref_{i}"]
    
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={
                        "amount": random.uniform(1, 100),
                        "target_shard": target_shard
                    } if is_cross_shard else {
                        "amount": random.uniform(1, 100)
                    },
                    shard_id=shard_id,
                    priority=random.randint(1, 5),
                    cross_shard_refs=cross_shard_refs
                )
                transactions.append(tx)
                
            return transactions
    
    if __name__ == '__main__':
        unittest.main(verbosity=2)
```

# File: /home/matt/icn-prototype/tests/performance/test_load_handling.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    import random
    import asyncio
    import time
    import signal
    from concurrent.futures import ThreadPoolExecutor, as_completed
    from typing import List, Dict, Set
    import logging
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.shard import Shard, ShardConfig
    from blockchain.core.transaction import Transaction
    from blockchain.core.block import Block
    from blockchain.core.node import Node
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    logger = logging.getLogger(__name__)
    
    def timeout_handler(signum, frame):
        """Handle timeout signal"""
        raise TimeoutError("Test execution timed out")
    
    class TestLoadHandling(unittest.TestCase):
        """Test suite for load handling capabilities of the ICN blockchain."""
        
        TIMEOUT = 10  # Reduced timeout to 10 seconds
        TRANSACTION_BATCH_SIZE = 50  # Further reduced batch size
        MAX_PROCESSING_TIME = 3  # Reduced processing time
    
        def setUp(self):
            """Set up test environment before each test."""
            # Configure logging
            logging.basicConfig(level=logging.INFO)
            
            self.config = ShardConfig(
                max_transactions_per_block=50,    # Further reduced
                max_pending_transactions=200,     # Further reduced
                max_cross_shard_refs=5,          # Further reduced
                pruning_interval=60,
                min_block_interval=0,
                max_block_size=1024 * 1024,
                max_state_size=10 * 1024 * 1024
            )
            
            self.num_shards = 2  # Reduced to minimum for testing
            self.shards = [Shard(shard_id=i, config=self.config) for i in range(self.num_shards)]
            self.nodes = self._create_test_nodes(6)  # Reduced number of nodes
            self.consensus = ProofOfCooperation()
    
            # Set up signal handler for timeouts
            signal.signal(signal.SIGALRM, timeout_handler)
    
        def tearDown(self):
            """Clean up after each test."""
            # Reset signal handler and clear any pending alarms
            signal.alarm(0)
            signal.signal(signal.SIGALRM, signal.SIG_DFL)
    
        def _create_test_nodes(self, num_nodes: int) -> List[Node]:
            """Create test nodes with varied capabilities."""
            nodes = []
            for i in range(num_nodes):
                node = Node(
                    node_id=f"node_{i}",
                    cooperative_id=f"coop_{i % 2}",  # Reduced cooperatives
                    initial_stake=100.0
                )
                node.reputation_scores = {
                    "validation": 20.0 + i * 0.5,
                    "resource_sharing": 20.0 + i * 0.3,
                    "cooperative_growth": 20.0 + i * 0.2,
                    "innovation": 20.0 + i * 0.1
                }
                shard_id = i % self.num_shards
                node.assign_to_shard(shard_id)
                nodes.append(node)
            return nodes
    
        def _generate_test_transactions(self, count: int) -> List[Transaction]:
            """Generate test transactions."""
            transactions = []
            for i in range(count):
                is_cross_shard = random.random() < 0.1  # Reduced cross-shard probability to 10%
                
                shard_id = random.randint(0, self.num_shards - 1)
                target_shard = None
                cross_shard_refs = []
                
                if is_cross_shard:
                    target_shard = (shard_id + 1) % self.num_shards
                    cross_shard_refs = [f"ref_{i}_{target_shard}"]
    
                tx = Transaction(
                    sender=f"sender_{i}",
                    receiver=f"receiver_{i}",
                    action="transfer",
                    data={
                        "amount": random.uniform(1, 100),
                        "target_shard": target_shard
                    } if is_cross_shard else {
                        "amount": random.uniform(1, 100)
                    },
                    shard_id=shard_id,
                    priority=random.randint(1, 5),
                    cross_shard_refs=cross_shard_refs
                )
                transactions.append(tx)
                
            logger.info(f"Generated {count} transactions")
            return transactions
    
        async def _process_transactions_async(self, transactions: List[Transaction]) -> None:
            """Process transactions asynchronously with timeout."""
            try:
                async with asyncio.timeout(self.MAX_PROCESSING_TIME):
                    for batch_start in range(0, len(transactions), self.TRANSACTION_BATCH_SIZE):
                        batch = transactions[batch_start:batch_start + self.TRANSACTION_BATCH_SIZE]
                        tasks = []
                        for tx in batch:
                            shard = self.shards[tx.shard_id]
                            tasks.append(asyncio.create_task(self._add_transaction_async(shard, tx)))
                        await asyncio.gather(*tasks)
                        logger.info(f"Processed batch of {len(batch)} transactions")
            except asyncio.TimeoutError:
                logger.warning("Transaction processing timed out")
    
        async def _add_transaction_async(self, shard: Shard, transaction: Transaction) -> None:
            """Add a transaction to a shard asynchronously."""
            try:
                shard.add_transaction(transaction)
            except Exception as e:
                logger.error(f"Error adding transaction: {e}")
    
        def _process_blocks(self, max_attempts: int = 100) -> None:
            """Process pending transactions into blocks with attempt limit."""
            attempts = 0
            processed_any = True
            
            while processed_any and attempts < max_attempts:
                processed_any = False
                attempts += 1
                
                for shard in self.shards:
                    if shard.pending_transactions:
                        validator = self.consensus.select_validator(self.nodes, shard.shard_id)
                        if validator:
                            block = shard.create_block(validator.node_id)
                            if block and shard.add_block(block):
                                processed_any = True
                                logger.info(f"Processed block in shard {shard.shard_id}")
                
                if attempts % 10 == 0:
                    logger.info(f"Block processing attempt {attempts}")
    
        def _validate_shard_blocks(self, shard: Shard) -> bool:
            """Validate all blocks in a shard."""
            try:
                for i in range(1, len(shard.chain)):
                    if not shard.chain[i].validate(shard.chain[i-1]):
                        return False
                return True
            except Exception as e:
                logger.error(f"Shard validation failed: {str(e)}")
                return False
    
        def _verify_system_state(self) -> None:
            """Verify overall system state consistency."""
            for shard in self.shards:
                self.assertTrue(shard.validate_chain())
                self.assertIsNotNone(shard.state_manager.state)
                self.assertGreaterEqual(len(shard.transaction_manager.processed_transactions), 0)
                self.assertIsNotNone(shard.validation_manager.validation_cache)
    
        def _verify_cross_shard_state(self) -> None:
            """Verify cross-shard reference consistency."""
            for shard in self.shards:
                cross_refs = shard.cross_shard_manager.get_metrics()
                self.assertGreaterEqual(cross_refs["cross_shard_operations"], 0)
                self.assertGreaterEqual(cross_refs["validated_refs"], 0)
    
        def _capture_shard_states(self) -> Dict[int, int]:
            """Capture current state sizes of all shards."""
            return {
                shard.shard_id: len(str(shard.state_manager.state))
                for shard in self.shards
            }
    
        def _reset_system_state(self) -> None:
            """Reset system state for next test."""
            for shard in self.shards:
                shard.transaction_manager.clear_all()
                shard.state_manager.state = {}
                shard.validation_manager.clear_cache()
    
        def test_high_transaction_load(self):
            """Test system performance under high transaction load."""
            transaction_counts = [20, 50]  # Further reduced counts
            
            for count in transaction_counts:
                with self.subTest(transaction_count=count):
                    signal.alarm(self.TIMEOUT)
                    try:
                        transactions = self._generate_test_transactions(count)
                        
                        start_time = time.time()
                        asyncio.run(self._process_transactions_async(transactions))
                        self._process_blocks()
                        
                        elapsed_time = time.time() - start_time
                        tps = count / elapsed_time
                        
                        logger.info(f"Processed {count} transactions in {elapsed_time:.2f} seconds ({tps:.2f} TPS)")
                        self._verify_system_state()
                        self._reset_system_state()
                    finally:
                        signal.alarm(0)
    
        def test_concurrent_validation(self):
            """Test concurrent block validation across shards."""
            signal.alarm(self.TIMEOUT)
            try:
                transactions = self._generate_test_transactions(20)  # Further reduced
                asyncio.run(self._process_transactions_async(transactions))
                
                with ThreadPoolExecutor(max_workers=self.num_shards) as executor:
                    futures = []
                    for shard in self.shards:
                        future = executor.submit(self._validate_shard_blocks, shard)
                        futures.append(future)
                    
                    for future in as_completed(futures):
                        result = future.result(timeout=self.TIMEOUT)
                        self.assertTrue(result)
            finally:
                signal.alarm(0)
    
        def test_cross_shard_load(self):
            """Test system performance with heavy cross-shard transactions."""
            signal.alarm(self.TIMEOUT)
            try:
                transactions = []
                for i in range(20):  # Further reduced
                    source_shard = i % self.num_shards
                    target_shard = (source_shard + 1) % self.num_shards
                    
                    tx = Transaction(
                        sender=f"sender_{i}",
                        receiver=f"receiver_{i}",
                        action="transfer",
                        data={
                            "amount": random.uniform(1, 100),
                            "target_shard": target_shard
                        },
                        shard_id=source_shard,
                        cross_shard_refs=[f"ref_{i}_{target_shard}"]
                    )
                    transactions.append(tx)
                
                start_time = time.time()
                asyncio.run(self._process_transactions_async(transactions))
                self._process_blocks()
                    
                elapsed_time = time.time() - start_time
                self._verify_cross_shard_state()
                
                tps = len(transactions) / elapsed_time
                logger.info(f"Cross-shard processing rate: {tps:.2f} TPS")
            finally:
                signal.alarm(0)
    
        def test_state_growth_under_load(self):
            """Test state management under continuous load."""
            signal.alarm(self.TIMEOUT)
            try:
                initial_states = self._capture_shard_states()
                
                for i in range(2):  # Further reduced iterations
                    transactions = self._generate_test_transactions(20)  # Further reduced
                    asyncio.run(self._process_transactions_async(transactions))
                    self._process_blocks()
                    
                    current_states = self._capture_shard_states()
                    for shard_id, state_size in current_states.items():
                        self.assertLess(
                            state_size, 
                            self.config.max_state_size,
                            f"Shard {shard_id} exceeded max state size"
                        )
            finally:
                signal.alarm(0)
    
    if __name__ == '__main__':
        unittest.main(verbosity=2)
```

# File: /home/matt/icn-prototype/tests/performance/__init__.py

```py

```

# File: /home/matt/icn-prototype/tests/unit/test_proof_of_cooperation.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List
    import random
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    from blockchain.core.node import Node
    from blockchain.core.block import Block
    from blockchain.core.transaction import Transaction
    
    class TestProofOfCooperation(unittest.TestCase):
        """Test cases for the ProofOfCooperation consensus mechanism."""
    
        def setUp(self):
            """Set up test fixtures before each test method."""
            self.poc = ProofOfCooperation(min_reputation=10.0, cooldown_blocks=3)
            self.test_nodes = self._create_test_nodes()
            
            # Create genesis block
            self.genesis_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now() - timedelta(minutes=10),
                transactions=[],
                validator="genesis",
                shard_id=1
            )
    
        def _initialize_test_node(self, node_id: str) -> Node:
            """Initialize a test node with all required attributes."""
            node = Node(
                node_id=node_id,
                cooperative_id="test_coop",
                initial_stake=100.0
            )
            
            # Ensure sufficient reputation
            base_score = 25.0  # Well above min_reputation
            for category in node.reputation_scores:
                node.reputation_scores[category] = base_score
                
            # Add successful validation history
            node.validation_history = [
                {
                    "timestamp": datetime.now() - timedelta(minutes=i),
                    "category": "validation",
                    "score_change": 1.0,
                    "evidence": {"success": True}
                }
                for i in range(20)
            ]
            
            # Set high performance metrics
            node.performance_metrics = {
                "availability": 98.0,
                "validation_success_rate": 95.0,
                "network_reliability": 97.0
            }
            
            # Set active state
            node.metadata["status"] = "active"
            node.cooldown = 0
            node.total_validations = 15  # Experienced node
            
            # Add shard assignment
            node.assign_to_shard(1)  # Assign to test shard
            node.active_shards[1] = datetime.now() - timedelta(hours=1)
            
            # Add diverse cooperative interactions
            node.cooperative_interactions = [
                f"coop_{i % 5}" for i in range(30)
            ]
            
            return node
    
        def _create_test_nodes(self, num_nodes: int = 5) -> List[Node]:
            """Create a list of test nodes."""
            return [
                self._initialize_test_node(f"node_{i}")
                for i in range(num_nodes)
            ]
    
        def _create_test_block(self, index: int, previous_block: Block, validator_id: str) -> Block:
            """Create a test block properly linked to previous block."""
            return Block(
                index=index,
                previous_hash=previous_block.hash,
                timestamp=datetime.now(),
                transactions=[
                    Transaction(
                        sender=f"user_{i}",
                        receiver=f"user_{i+1}",
                        action="transfer",
                        data={"amount": 10.0},
                        shard_id=1
                    )
                    for i in range(3)
                ],
                validator=validator_id,
                shard_id=1
            )
    
        def test_initialization(self):
            """Test ProofOfCooperation initialization."""
            self.assertEqual(self.poc.min_reputation, 10.0)
            self.assertEqual(self.poc.cooldown_blocks, 3)
            self.assertGreater(len(self.poc.reputation_weights), 0)
            self.assertGreater(len(self.poc.validation_thresholds), 0)
            self.assertTrue(0 < self.poc.reputation_decay_factor <= 1)
    
        def test_calculate_cooperation_score(self):
            """Test cooperation score calculation."""
            node = self._initialize_test_node("score_test_node")
            
            # Test basic score calculation
            score = self.poc.calculate_cooperation_score(node)
            self.assertGreater(score, 0)
            
            # Test with shard_id
            shard_score = self.poc.calculate_cooperation_score(node, shard_id=1)
            self.assertGreater(shard_score, 0)
            
            # Test node in cooldown
            node.enter_cooldown(3)
            cooldown_score = self.poc.calculate_cooperation_score(node)
            self.assertEqual(cooldown_score, 0)
    
        def test_validator_selection(self):
            """Test validator selection process."""
            nodes = [
                self._initialize_test_node(f"select_node_{i}")
                for i in range(5)
            ]
            
            # Test basic selection
            validator = self.poc.select_validator(nodes)
            self.assertIsNotNone(validator)
            self.assertIn(validator, nodes)
            
            # Test selection with shard_id
            shard_validator = self.poc.select_validator(nodes, shard_id=1)
            self.assertIsNotNone(shard_validator)
            
            # Test with all nodes in cooldown
            for node in nodes:
                node.enter_cooldown(3)
            no_validator = self.poc.select_validator(nodes)
            self.assertIsNone(no_validator)
    
        def test_block_validation(self):
            """Test block validation process."""
            validator = self._initialize_test_node("test_validator")
            
            # Create a valid test block
            test_block = self._create_test_block(1, self.genesis_block, validator.node_id)
            
            # Verify block validation
            is_valid = self.poc.validate_block(test_block, self.genesis_block, validator)
            self.assertTrue(is_valid)
            
            # Test invalid block (future timestamp)
            invalid_block = Block(
                index=1,
                previous_hash=self.genesis_block.hash,
                timestamp=datetime.now() + timedelta(hours=1),
                transactions=[],
                validator=validator.node_id,
                shard_id=1
            )
            is_invalid = self.poc.validate_block(invalid_block, self.genesis_block, validator)
            self.assertFalse(is_invalid)
    
        def test_collusion_detection(self):
            """Test collusion detection mechanism."""
            node = self._initialize_test_node("collusion_test_node")
            
            # Create block with diverse transactions
            diverse_block = Block(
                index=1,
                previous_hash=self.genesis_block.hash,
                timestamp=datetime.now(),
                transactions=[
                    Transaction(
                        sender=f"user_{i}",
                        receiver=f"user_{i+1}",
                        action="transfer",
                        data={"amount": 10.0},
                        shard_id=1
                    )
                    for i in range(5)
                ],
                validator=node.node_id,
                shard_id=1
            )
            
            # Create block with obvious collusion pattern
            collusion_transactions = [
                Transaction(
                    sender="colluding_user",
                    receiver=f"receiver_{i}",  # Fixed variable scope issue
                    action="transfer",
                    data={"amount": 10.0},
                    shard_id=1
                )
                for i in range(5)
            ]
            
            collusion_block = Block(
                index=2,
                previous_hash=self.genesis_block.hash,
                timestamp=datetime.now(),
                transactions=collusion_transactions,
                validator=node.node_id,
                shard_id=1
            )
            
            # Test detection
            diverse_collusion = self.poc.detect_collusion(node, diverse_block)
            self.assertFalse(diverse_collusion)
            
            repeated_collusion = self.poc.detect_collusion(node, collusion_block)
            self.assertTrue(repeated_collusion)
    
        def test_diversity_factor(self):
            """Test diversity factor calculation."""
            diverse_node = self._initialize_test_node("diverse_node")
            diverse_node.cooperative_interactions = [f"coop_{i}" for i in range(10)]
            diverse_factor = self.poc._calculate_diversity_factor(diverse_node)
            
            limited_node = self._initialize_test_node("limited_node")
            limited_node.cooperative_interactions = ["coop_1"] * 10
            limited_factor = self.poc._calculate_diversity_factor(limited_node)
            
            self.assertGreater(diverse_factor, limited_factor)
    
        def test_consistency_factor(self):
            """Test consistency factor calculation."""
            node = self._initialize_test_node("consistency_node")
            
            # Test with successful validations
            node.validation_history = [
                {"evidence": {"success": True}} for _ in range(10)
            ]
            high_consistency = self.poc._calculate_consistency_factor(node)
            
            # Test with mixed success
            node.validation_history = [
                {"evidence": {"success": i % 2 == 0}} for i in range(10)
            ]
            mixed_consistency = self.poc._calculate_consistency_factor(node)
            
            self.assertGreater(high_consistency, mixed_consistency)
    
        def test_performance_factor(self):
            """Test performance factor calculation."""
            node = self._initialize_test_node("performance_node")
            
            # Test high performance
            node.performance_metrics = {
                "availability": 98.0,
                "validation_success_rate": 95.0,
                "network_reliability": 97.0
            }
            high_performance = self.poc._calculate_performance_factor(node)
            
            # Test lower performance
            node.performance_metrics = {
                "availability": 85.0,
                "validation_success_rate": 82.0,
                "network_reliability": 88.0
            }
            lower_performance = self.poc._calculate_performance_factor(node)
            
            self.assertGreater(high_performance, lower_performance)
    
        def test_metrics(self):
            """Test consensus metrics collection."""
            # Record some validation activity
            for i in range(5):
                self.poc.performance_metrics["total_validations"] += 1
                self.poc.performance_metrics["successful_validations"] += (i % 2)
            
            metrics = self.poc.get_metrics()
            
            self.assertIn("total_validations", metrics)
            self.assertIn("successful_validations", metrics)
            self.assertIn("average_block_time", metrics)
            self.assertIn("collusion_detections", metrics)
            self.assertGreaterEqual(metrics["total_validations"], 5)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_contract_executor.py

```py
    """
    tests/unit/test_contract_executor.py
    
    Unit tests for the ContractExecutor class, handling contract deployment,
    execution, and lifecycle management.
    """
    
    import pytest
    from datetime import datetime, timedelta
    import sys
    import os
    import asyncio
    from typing import Dict, List
    import logging
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.contracts.contract_executor import ContractExecutor
    from blockchain.contracts.smart_contract import SmartContract, ContractExecutionError
    
    class TestContractExecutor:
        """Test cases for the ContractExecutor class."""
    
        @pytest.fixture(autouse=True)
        def setup(self):
            """Setup test instance with fresh ContractExecutor."""
            self.executor = ContractExecutor(initial_mana=1000, mana_regen_rate=10)
    
        @pytest.fixture
        def basic_contract_code(self):
            """Fixture providing basic test contract code."""
            return """
    def execute(input_data, state):
        a = input_data.get('a', 0)
        b = input_data.get('b', 0)
        result = a + b
        state['last_result'] = result
        return result
    """
    
        @pytest.fixture
        def test_contract(self, basic_contract_code):
            """Fixture providing a test contract instance."""
            return SmartContract(
                contract_id="test_contract",
                code=basic_contract_code,
                creator="test_creator",
                mana_cost=10
            )
    
        @pytest.mark.asyncio
        async def test_deploy_contract(self, test_contract):
            """Test contract deployment functionality."""
            # Test successful deployment
            success = await self.executor.deploy_contract(test_contract)
            assert success
            assert test_contract.contract_id in self.executor.contracts
            
            # Test duplicate deployment
            success = await self.executor.deploy_contract(test_contract)
            assert not success
            
            # Test contract with invalid code
            invalid_contract = SmartContract(
                contract_id="invalid_contract",
                code="invalid python code :",
                creator="test_creator"
            )
            success = await self.executor.deploy_contract(invalid_contract)
            assert not success
    
        @pytest.mark.asyncio
        async def test_execute_contract(self, test_contract):
            """Test contract execution."""
            await self.executor.deploy_contract(test_contract)
            
            result = await self.executor.execute_contract(
                test_contract.contract_id,
                {"a": 5, "b": 3},
                "test_creator"
            )
            assert result is not None
            assert result.get("result") == 8
            
            # Test insufficient mana
            self.executor.mana_pool = 5
            with pytest.raises(ContractExecutionError):
                await self.executor.execute_contract(
                    test_contract.contract_id,
                    {"a": 1, "b": 2},
                    "test_creator"
                )
    
        @pytest.mark.asyncio
        async def test_execution_queue(self, test_contract):
            """Test contract execution queue functionality."""
            await self.executor.deploy_contract(test_contract)
            
            queue_success = await self.executor.queue_execution(
                test_contract.contract_id,
                {"a": 1, "b": 2},
                "test_creator"
            )
            assert queue_success
    
            # Test queue size limit
            self.executor.max_queue_size = 1
            queue_success = await self.executor.queue_execution(
                test_contract.contract_id,
                {"a": 3, "b": 4},
                "test_creator"
            )
            assert not queue_success
    
        @pytest.mark.asyncio
        async def test_dependency_management(self, basic_contract_code):
            """Test contract dependency management."""
            base_contract = SmartContract(
                contract_id="base_contract",
                code=basic_contract_code,
                creator="test_creator"
            )
            
            dependent_contract = SmartContract(
                contract_id="dependent_contract",
                code="""
    def execute(input_data, state):
        value = input_data.get('value', 0)
        state['processed'] = value * 2
        return state['processed']
    """,
                creator="test_creator"
            )
            dependent_contract.dependencies.add(base_contract.contract_id)
            
            # Test deployment order validation
            with pytest.raises(ContractExecutionError):
                await self.executor.deploy_contract(dependent_contract)
            
            await self.executor.deploy_contract(base_contract)
            success = await self.executor.deploy_contract(dependent_contract)
            assert success
    
        @pytest.mark.asyncio
        async def test_mana_regeneration(self, test_contract):
            """Test mana regeneration functionality."""
            initial_mana = self.executor.mana_pool
            
            await self.executor.deploy_contract(test_contract)
            await self.executor.execute_contract(
                test_contract.contract_id,
                {"a": 1, "b": 2},
                "test_creator"
            )
            
            used_mana = initial_mana - self.executor.mana_pool
            await self.executor.regenerate_mana()
            assert self.executor.mana_pool > initial_mana - used_mana
    
        def test_metrics_collection(self):
            """Test metrics collection and reporting."""
            metrics = self.executor.get_metrics()
            
            assert "total_executions" in metrics
            assert "failed_executions" in metrics
            assert "total_mana_consumed" in metrics
            assert "average_execution_time" in metrics
            assert "contracts_deployed" in metrics
            assert "queue_length" in metrics
    
        @pytest.mark.asyncio
        async def test_execution_limits(self):
            """Test contract execution limits and restrictions."""
            long_running_contract = SmartContract(
                contract_id="long_running",
                code="""
    def execute(input_data, state):
        import time
        time.sleep(6)  # Exceed time limit
        return True
    """,
                creator="test_creator"
            )
            
            await self.executor.deploy_contract(long_running_contract)
            
            with pytest.raises(ContractExecutionError):
                await self.executor.execute_contract(
                    long_running_contract.contract_id,
                    {},
                    "test_creator"
                )
    
        @pytest.mark.asyncio
        async def test_concurrent_execution(self, test_contract):
            """Test concurrent contract execution handling."""
            await self.executor.deploy_contract(test_contract)
            
            tasks = []
            for i in range(5):
                task = self.executor.execute_contract(
                    test_contract.contract_id,
                    {"a": i, "b": i},
                    "test_creator"
                )
                tasks.append(task)
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            successful = [r for r in results if not isinstance(r, Exception)]
            assert len(successful) == 5
    
        @pytest.mark.asyncio
        async def test_error_recovery(self):
            """Test error recovery and state management."""
            failing_contract = SmartContract(
                contract_id="failing_contract",
                code="""
    def execute(input_data, state):
        if input_data.get('fail', False):
            raise ValueError('Intended failure')
        state['value'] = input_data.get('value', 0)
        return state['value']
    """,
                creator="test_creator"
            )
            
            await self.executor.deploy_contract(failing_contract)
            
            result = await self.executor.execute_contract(
                failing_contract.contract_id,
                {"value": 42},
                "test_creator"
            )
            assert result["result"] == 42
            
            with pytest.raises(ContractExecutionError):
                await self.executor.execute_contract(
                    failing_contract.contract_id,
                    {"fail": True},
                    "test_creator"
                )
            
            result = await self.executor.execute_contract(
                failing_contract.contract_id,
                {"value": 100},
                "test_creator"
            )
            assert result["result"] == 100
    
        @pytest.mark.asyncio
        async def test_authorization(self, test_contract):
            """Test contract authorization controls."""
            await self.executor.deploy_contract(test_contract)
            
            with pytest.raises(ContractExecutionError):
                await self.executor.execute_contract(
                    test_contract.contract_id,
                    {"a": 1, "b": 2},
                    "unauthorized_user"
                )
            
            test_contract.authorize_caller("new_user")
            result = await self.executor.execute_contract(
                test_contract.contract_id,
                {"a": 1, "b": 2},
                "new_user"
            )
            assert result is not None
    
        @pytest.mark.asyncio
        async def test_contract_cleanup(self, basic_contract_code):
            """Test contract cleanup and resource management."""
            contracts = []
            for i in range(5):
                contract = SmartContract(
                    contract_id=f"contract_{i}",
                    code=basic_contract_code,
                    creator="test_creator"
                )
                contracts.append(contract)
                await self.executor.deploy_contract(contract)
            
            metrics = self.executor.get_metrics()
            assert metrics["contracts_deployed"] == 5
            
            for contract in contracts:
                assert contract.contract_id in self.executor.contracts
```

# File: /home/matt/icn-prototype/tests/unit/test_credential.py

```py
    import unittest
    from datetime import datetime, timedelta
    from cryptography.hazmat.primitives.asymmetric import rsa
    from cryptography.hazmat.primitives import serialization
    
    # Import the Credential and CredentialTemplate classes
    from did.credential import Credential, CredentialTemplate
    
    class TestCredential(unittest.TestCase):
    
        def setUp(self):
            """Set up test environment, including RSA key generation."""
            self.private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
            self.public_key = self.private_key.public_key()
            
            self.issuer_did = "did:icn:issuer"
            self.subject_did = "did:icn:subject"
            self.claims = {"trustworthiness": 5, "participation": 8}
            self.dao_type = "cooperative"
            
            self.credential = Credential(
                issuer=self.issuer_did,
                subject=self.subject_did,
                claims=self.claims,
                dao_type=self.dao_type,
                expires_at=datetime.now() + timedelta(days=365)
            )
    
        def test_generate_proof(self):
            """Test generating cryptographic proof for a credential."""
            self.credential.generate_proof(self.private_key)
            self.assertIsNotNone(self.credential.proof)
            self.assertIn('signature', self.credential.proof)
            self.assertIn('data_hash', self.credential.proof)
    
        def test_verify_valid_credential(self):
            """Test verifying a valid credential."""
            self.credential.generate_proof(self.private_key)
            result = self.credential.verify(self.public_key)
            self.assertTrue(result)
    
        def test_verify_invalid_signature(self):
            """Test verification with an invalid signature."""
            # Tamper with the proof to simulate an invalid signature
            self.credential.generate_proof(self.private_key)
            self.credential.proof['signature'] = '00' * 128  # Invalid signature
            result = self.credential.verify(self.public_key)
            self.assertFalse(result)
    
        def test_revoke_credential(self):
            """Test revoking a credential."""
            self.credential.revoke()
            self.assertTrue(self.credential.is_expired())
    
        def test_expired_credential(self):
            """Test checking for expired credentials."""
            self.credential.expires_at = datetime.now() - timedelta(days=1)
            self.assertTrue(self.credential.is_expired())
    
        def test_non_expired_credential(self):
            """Test checking for non-expired credentials."""
            self.assertFalse(self.credential.is_expired())
    
        def test_selective_disclosure(self):
            """Test selective disclosure of credential claims."""
            disclosed_claims = self.credential.selective_disclosure(['trustworthiness'])
            self.assertEqual(disclosed_claims, {'trustworthiness': 5})
            self.assertNotIn('participation', disclosed_claims)
    
        def test_selective_disclosure_no_fields(self):
            """Test selective disclosure when no fields match."""
            disclosed_claims = self.credential.selective_disclosure(['nonexistent_field'])
            self.assertEqual(disclosed_claims, {})
    
    class TestCredentialTemplate(unittest.TestCase):
    
        def setUp(self):
            """Set up test environment, including RSA key generation."""
            self.private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
            self.issuer_did = "did:icn:issuer"
            self.subject_did = "did:icn:subject"
            self.claims = {"efficiency": 7, "collaboration": 9}
            self.dao_type = "community"
            
            self.template = CredentialTemplate(
                template_name="Community Engagement",
                claims=self.claims,
                dao_type=self.dao_type
            )
    
        def test_apply_template(self):
            """Test applying a template to create a credential."""
            credential = self.template.apply_template(self.subject_did, self.issuer_did, self.private_key)
            self.assertEqual(credential.issuer, self.issuer_did)
            self.assertEqual(credential.subject, self.subject_did)
            self.assertEqual(credential.claims, self.claims)
            self.assertEqual(credential.dao_type, self.dao_type)
            self.assertIsNotNone(credential.proof)
    
        def test_apply_template_and_verify(self):
            """Test creating a credential from a template and verifying it."""
            credential = self.template.apply_template(self.subject_did, self.issuer_did, self.private_key)
            result = credential.verify(self.private_key.public_key())
            self.assertTrue(result)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_block.py

```py
    # tests/unit/test_block.py
    
    import unittest
    from datetime import datetime, timedelta
    import json
    import hashlib
    import sys
    import os
    from typing import List
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.block import Block
    from blockchain.core.transaction import Transaction
    
    class TestBlock(unittest.TestCase):
        """Test cases for the Block class."""
    
        def setUp(self):
            """Set up test fixtures before each test method."""
            self.sample_transactions = self._create_sample_transactions()
            
            # Create previous block first
            self.previous_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now() - timedelta(minutes=5),
                transactions=[],
                validator="genesis",
                shard_id=1
            )
    
            # Create current block with correct previous hash
            self.block = Block(
                index=1,
                previous_hash=self.previous_block.hash,  # Use actual hash from previous block
                timestamp=datetime.now(),
                transactions=self.sample_transactions[:2],
                validator="node1",
                shard_id=1
            )
    
        def _create_sample_transactions(self) -> List[Transaction]:
            """Create sample transactions for testing."""
            transactions = []
            for i in range(1, 6):
                tx = Transaction(
                    sender=f"user{i}",
                    receiver=f"user{i+1}",
                    action="transfer",
                    data={"amount": 10.0 * i},
                    shard_id=1  # All transactions in same shard
                )
                transactions.append(tx)
            return transactions
    
        def test_initialization(self):
            """Test block initialization and attribute setting."""
            self.assertEqual(self.block.index, 1)
            self.assertEqual(self.block.previous_hash, self.previous_block.hash)
            self.assertEqual(self.block.validator, "node1")
            self.assertEqual(self.block.shard_id, 1)
            self.assertEqual(len(self.block.transactions), 2)
            self.assertIsNotNone(self.block.merkle_root)
            self.assertIsNotNone(self.block.hash)
            self.assertEqual(self.block.nonce, 0)
            self.assertEqual(self.block.version, "1.0")
            self.assertIn("created_at", self.block.metadata)
    
        def test_merkle_root_calculation(self):
            """Test Merkle root calculation with different scenarios."""
            # Test with existing transactions
            merkle_root = self.block.calculate_merkle_root()
            self.assertEqual(merkle_root, self.block.merkle_root)
            
            # Test with empty transactions
            empty_block = Block(
                index=0,
                previous_hash="0",
                timestamp=datetime.now(),
                transactions=[],
                validator="genesis",
                shard_id=0
            )
            self.assertEqual(
                empty_block.merkle_root,
                hashlib.sha256(b"empty").hexdigest()
            )
            
            # Test with odd number of transactions
            odd_block = Block(
                index=2,
                previous_hash=self.block.hash,
                timestamp=datetime.now(),
                transactions=self.sample_transactions[:3],
                validator="node1",
                shard_id=1
            )
            self.assertIsNotNone(odd_block.merkle_root)
            
            # Verify Merkle root changes with transaction modification
            original_root = self.block.merkle_root
            modified_tx = self.block.transactions[0]
            modified_tx.data["amount"] = 999.9
            new_root = self.block.calculate_merkle_root()
            self.assertNotEqual(original_root, new_root)
    
        def test_hash_calculation(self):
            """Test block hash calculation and verification."""
            # Test initial hash
            initial_hash = self.block.hash
            calculated_hash = self.block.calculate_hash()
            self.assertEqual(initial_hash, calculated_hash)
            
            # Test hash changes with block modifications
            self.block.nonce += 1
            new_hash = self.block.calculate_hash()
            self.assertNotEqual(initial_hash, new_hash)
            
            # Test hash changes with timestamp modification
            original_timestamp = self.block.timestamp
            self.block.timestamp += timedelta(seconds=1)
            newer_hash = self.block.calculate_hash()
            self.assertNotEqual(new_hash, newer_hash)
            # Restore timestamp for other tests
            self.block.timestamp = original_timestamp
            
            # Verify hash format
            self.assertTrue(all(c in "0123456789abcdef" for c in self.block.hash))
            self.assertEqual(len(self.block.hash), 64)  # SHA-256 produces 64 hex chars
    
        def test_validation(self):
            """Test block validation logic."""
            # Test valid block
            self.assertTrue(self.block.validate(self.previous_block))
            
            # Test invalid hash
            original_hash = self.block.hash
            self.block.hash = "invalid_hash"
            self.assertFalse(self.block.validate(self.previous_block))
            self.block.hash = original_hash
            
            # Test future timestamp
            original_timestamp = self.block.timestamp
            self.block.timestamp = datetime.now() + timedelta(hours=1)
            self.assertFalse(self.block.validate(self.previous_block))
            self.block.timestamp = original_timestamp
            
            # Test invalid previous hash
            original_prev_hash = self.block.previous_hash
            self.block.previous_hash = "wrong_hash"
            self.assertFalse(self.block.validate(self.previous_block))
            self.block.previous_hash = original_prev_hash
    
        def test_add_transaction(self):
            """Test adding transactions to the block."""
            initial_tx_count = len(self.block.transactions)
            new_tx = self.sample_transactions[3]  # Unused transaction
            
            # Test adding valid transaction
            self.assertTrue(self.block.add_transaction(new_tx))
            self.assertEqual(len(self.block.transactions), initial_tx_count + 1)
            
            # Verify Merkle root was updated
            self.assertNotEqual(self.block.merkle_root, "")
            
            # Test adding transaction with wrong shard_id
            wrong_shard_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 50.0},
                shard_id=2  # Different shard
            )
            self.assertFalse(self.block.add_transaction(wrong_shard_tx))
            
            # Test adding duplicate transaction
            self.assertFalse(self.block.add_transaction(new_tx))
    
        def test_block_size(self):
            """Test block size calculations and limits."""
            # Add maximum transactions
            for tx in self.sample_transactions:
                self.block.add_transaction(tx)
                
            # Verify block can be serialized
            block_dict = self.block.to_dict()
            block_json = json.dumps(block_dict)
            
            # Simulate block size calculation
            block_size = len(block_json.encode('utf-8'))
            self.assertGreater(block_size, 0)
    
        def test_cross_shard_references(self):
            """Test cross-shard reference handling."""
            # Add cross-shard reference
            ref = "cross_shard_ref_123"
            self.block.cross_shard_refs.append(ref)
            
            # Verify serialization includes references
            block_dict = self.block.to_dict()
            self.assertIn("cross_shard_refs", block_dict)
            self.assertIn(ref, block_dict["cross_shard_refs"])
            
            # Verify deserialization preserves references
            new_block = Block.from_dict(block_dict)
            self.assertIn(ref, new_block.cross_shard_refs)
    
        def test_metadata(self):
            """Test block metadata handling."""
            # Test default metadata
            self.assertIn("created_at", self.block.metadata)
            
            # Add custom metadata
            self.block.metadata["test_key"] = "test_value"
            
            # Verify serialization includes metadata
            block_dict = self.block.to_dict()
            self.assertIn("metadata", block_dict)
            self.assertEqual(block_dict["metadata"]["test_key"], "test_value")
            
            # Verify deserialization preserves metadata
            new_block = Block.from_dict(block_dict)
            self.assertEqual(new_block.metadata["test_key"], "test_value")
    
        def test_serialization(self):
            """Test block serialization and deserialization."""
            # Convert block to dictionary
            block_dict = self.block.to_dict()
            
            # Verify dictionary structure
            self.assertIn("index", block_dict)
            self.assertIn("previous_hash", block_dict)
            self.assertIn("timestamp", block_dict)
            self.assertIn("transactions", block_dict)
            self.assertIn("validator", block_dict)
            self.assertIn("hash", block_dict)
            self.assertIn("merkle_root", block_dict)
            self.assertIn("shard_id", block_dict)
            self.assertIn("version", block_dict)
            
            # Create new block from dictionary
            new_block = Block.from_dict(block_dict)
            
            # Verify all attributes match
            self.assertEqual(new_block.index, self.block.index)
            self.assertEqual(new_block.previous_hash, self.block.previous_hash)
            self.assertEqual(new_block.validator, self.block.validator)
            self.assertEqual(new_block.shard_id, self.block.shard_id)
            self.assertEqual(new_block.hash, self.block.hash)
            self.assertEqual(new_block.merkle_root, self.block.merkle_root)
            
            # Verify transactions were properly deserialized
            self.assertEqual(len(new_block.transactions), len(self.block.transactions))
            for orig_tx, new_tx in zip(self.block.transactions, new_block.transactions):
                self.assertEqual(orig_tx.transaction_id, new_tx.transaction_id)
                self.assertEqual(orig_tx.sender, new_tx.sender)
                self.assertEqual(orig_tx.receiver, new_tx.receiver)
                self.assertEqual(orig_tx.data, new_tx.data)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_validator_manager.py

```py
    import unittest
    from datetime import datetime, timedelta
    from blockchain.consensus.proof_of_cooperation.validator_manager import ValidatorManager
    from blockchain.core.node import Node
    
    class TestValidatorManager(unittest.TestCase):
        def setUp(self):
            self.manager = ValidatorManager(min_reputation=10.0, cooldown_blocks=3)
            self.node1 = Node(node_id="node1", cooperative_id="coop1", initial_stake=100.0)
            self.node1.reputation = 25.0
    
        def test_validator_selection(self):
            # Test that node1 can be selected as a validator
            validator = self.manager.select_validator([self.node1])
            self.assertEqual(validator, self.node1)
            self.assertEqual(validator.cooldown, 3)
    
        def test_validator_ineligibility_due_to_cooldown(self):
            # Put node1 into cooldown and test that it cannot be selected
            self.node1.cooldown = 1
            validator = self.manager.select_validator([self.node1])
            self.assertIsNone(validator)
    
        def test_priority_calculation(self):
            # Test the priority calculation for validator selection
            score = self.manager._calculate_priority_score(self.node1)
            self.assertGreater(score, 0)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_shard.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import List, Dict, Optional, Set
    import logging
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.shard import Shard, ShardConfig
    from blockchain.core.transaction import Transaction
    from blockchain.core.block import Block
    
    logger = logging.getLogger(__name__)
    
    class TestShard(unittest.TestCase):
        """Test cases for the modular Shard implementation."""
    
        def setUp(self):
            """Set up test environment before each test."""
            self.config = ShardConfig(
                max_transactions_per_block=5,
                max_pending_transactions=10,
                max_cross_shard_refs=3,
                pruning_interval=60,
                min_block_interval=0,  # Set to 0 for testing
                max_block_size=1024 * 1024,  # 1MB
                max_state_size=10 * 1024 * 1024  # 10MB
            )
            self.shard = Shard(shard_id=1, config=self.config)
            
            # Initialize some balances in state for testing
            self.shard.state_manager.state = {
                "balances": {
                    "user0": 1000.0,
                    "user1": 1000.0,
                    "user2": 1000.0,
                    "user3": 1000.0,
                    "user4": 1000.0
                }
            }
            
            self.sample_transactions = self._create_sample_transactions()
    
        def _create_sample_transactions(self) -> List[Transaction]:
            """Create sample transactions for testing."""
            return [
                Transaction(
                    sender=f"user{i}",
                    receiver=f"user{i+1}",
                    action="transfer",
                    data={"amount": 50.0},  # Changed from 10.0 to make changes more noticeable
                    shard_id=1
                ) for i in range(4)
            ]
    
        def test_initialization(self):
            """Test shard initialization with all components."""
            self.assertEqual(self.shard.shard_id, 1)
            self.assertIsInstance(self.shard.transaction_manager.pending_transactions, list)
            self.assertIsInstance(self.shard.state_manager.state, dict)
            self.assertEqual(len(self.shard.chain), 1)  # Genesis block
            self.assertEqual(self.shard.height, 1)
            self.assertEqual(self.shard.chain[0].validator, "genesis")
    
        def test_genesis_block(self):
            """Test genesis block creation and properties."""
            genesis = self.shard.chain[0]
            self.assertEqual(genesis.index, 0)
            self.assertEqual(genesis.previous_hash, "0" * 64)
            self.assertEqual(len(genesis.transactions), 0)
            self.assertEqual(genesis.validator, "genesis")
            self.assertEqual(genesis.shard_id, 1)
            self.assertTrue(genesis.validate(None))
    
        def test_transaction_management(self):
            """Test transaction management functionality."""
            # Test valid transaction addition
            tx = self.sample_transactions[0]
            self.assertTrue(self.shard.add_transaction(tx))
            self.assertEqual(len(self.shard.pending_transactions), 1)
    
            # Test duplicate transaction
            self.assertFalse(self.shard.add_transaction(tx))
    
            # Test transaction with wrong shard_id
            invalid_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 50.0},
                shard_id=2
            )
            self.assertFalse(self.shard.add_transaction(invalid_tx))
    
        def test_state_management(self):
            """Test state management and updates."""
            initial_state = self.shard.state_manager.state.copy()
            initial_balance = initial_state["balances"]["user0"]
    
            # Add and process transaction
            tx = self.sample_transactions[0]
            self.shard.add_transaction(tx)
            block = self.shard.create_block("test_validator")
            self.assertTrue(self.shard.add_block(block))
    
            # Verify balance changes
            new_state = self.shard.state_manager.state
            self.assertEqual(
                new_state["balances"]["user0"],
                initial_balance - 50.0  # Verify sender balance decreased
            )
            self.assertEqual(
                new_state["balances"]["user1"],
                initial_balance + 50.0  # Verify receiver balance increased
            )
    
        def test_create_block(self):
            """Test block creation from pending transactions."""
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
    
            block = self.shard.create_block("test_validator")
            self.assertIsNotNone(block)
            self.assertEqual(block.index, self.shard.height)
            self.assertEqual(block.shard_id, self.shard.shard_id)
            self.assertEqual(len(block.transactions), 3)
    
        def test_add_block(self):
            """Test adding blocks to the shard."""
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
            
            block = self.shard.create_block("test_validator")
            initial_height = self.shard.height
            
            self.assertTrue(self.shard.add_block(block))
            self.assertEqual(self.shard.height, initial_height + 1)
            self.assertEqual(len(self.shard.pending_transactions), 0)
    
        def test_cross_shard_operations(self):
            """Test cross-shard operations and references."""
            cross_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={
                    "amount": 50.0,
                    "target_shard": 2
                },
                shard_id=1,
                cross_shard_refs=["ref_1"]
            )
    
            self.assertTrue(self.shard.add_transaction(cross_tx))
            block = self.shard.create_block("test_validator")
            self.assertIsNotNone(block)
            self.assertTrue(len(block.cross_shard_refs) > 0)
    
            # Verify cross-shard reference tracking
            self.assertTrue(self.shard.add_block(block))
            cross_shard_metrics = self.shard.cross_shard_manager.get_metrics()
            self.assertGreater(cross_shard_metrics["cross_shard_operations"], 0)
    
        def test_state_consistency(self):
            """Test state consistency across operations."""
            initial_state = self.shard.state_manager.state.copy()
            amount = 50.0  # Transaction amount
            
            # Add and process transactions
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
    
            block = self.shard.create_block("test_validator")
            self.shard.add_block(block)
    
            # Verify state changes are consistent
            new_state = self.shard.state_manager.state
            for tx in block.transactions:
                # Get initial balances
                initial_sender_balance = initial_state["balances"][tx.sender]
                initial_receiver_balance = initial_state["balances"][tx.receiver]
                
                # Get new balances
                sender_balance = new_state["balances"][tx.sender]
                receiver_balance = new_state["balances"][tx.receiver]
                
                # Verify balances
                self.assertEqual(sender_balance, initial_sender_balance - amount)
                self.assertEqual(receiver_balance, initial_receiver_balance + amount)
                self.assertGreaterEqual(sender_balance, 0)
                self.assertGreater(receiver_balance, initial_state["balances"][tx.receiver])
    
        def test_manager_coordination(self):
            """Test coordination between different managers."""
            tx = self.sample_transactions[0]
            
            # Verify transaction gets properly distributed to managers
            self.shard.add_transaction(tx)
            self.assertIn(tx, self.shard.transaction_manager.pending_transactions)
            self.assertTrue(self.shard.validation_manager.validate_transaction(tx))
    
            # Create and add block
            block = self.shard.create_block("test_validator")
            initial_state = self.shard.state_manager.state.copy()
            
            self.assertTrue(self.shard.add_block(block))
            self.assertNotEqual(self.shard.state_manager.state, initial_state)
            self.assertEqual(len(self.shard.transaction_manager.pending_transactions), 0)
    
        def test_transaction_validation(self):
            """Test transaction validation in shard context."""
            valid_tx = self.sample_transactions[0]
            self.assertTrue(self.shard.validation_manager.validate_transaction(valid_tx))
    
            # Test invalid amount
            invalid_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": -50.0},
                shard_id=1
            )
            self.assertFalse(self.shard.validation_manager.validate_transaction(invalid_tx))
    
            # Test insufficient balance
            large_tx = Transaction(
                sender="user1",
                receiver="user2",
                action="transfer",
                data={"amount": 2000.0},
                shard_id=1
            )
            self.assertFalse(self.shard.validation_manager.validate_transaction(large_tx))
    
        def test_validate_chain(self):
            """Test chain validation functionality."""
            # Add some blocks
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
                
            block = self.shard.create_block("test_validator")
            self.shard.add_block(block)
            
            self.assertTrue(self.shard.validate_chain())
    
        def test_get_metrics(self):
            """Test metrics collection across all managers."""
            # Generate some activity
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
                
            block = self.shard.create_block("test_validator")
            self.shard.add_block(block)
            
            metrics = self.shard.get_metrics()
            
            self.assertIn("total_transactions", metrics)
            self.assertIn("blocks_created", metrics)
            self.assertIn("pending_transactions", metrics)
            self.assertIn("state_size", metrics)
            self.assertEqual(metrics["shard_id"], self.shard.shard_id)
    
        def test_serialization(self):
            """Test shard serialization and deserialization."""
            # Add some data
            for tx in self.sample_transactions[:3]:
                self.shard.add_transaction(tx)
            block = self.shard.create_block("test_validator")
            self.shard.add_block(block)
    
            # Serialize
            shard_dict = self.shard.to_dict()
    
            # Deserialize
            new_shard = Shard.from_dict(shard_dict)
    
            # Verify properties
            self.assertEqual(new_shard.shard_id, self.shard.shard_id)
            self.assertEqual(new_shard.height, self.shard.height)
            self.assertEqual(len(new_shard.chain), len(self.shard.chain))
            self.assertEqual(
                new_shard.state_manager.state["balances"],
                self.shard.state_manager.state["balances"]
            )
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_node.py

```py
    import unittest
    from datetime import datetime, timedelta
    from blockchain.core.block import Block
    from blockchain.core.transaction import Transaction
    from blockchain.core.node import Node
    from blockchain.core.shard import Shard
    from blockchain.consensus.proof_of_cooperation import ProofOfCooperation
    
    class TestBlock(unittest.TestCase):
        def setUp(self):
            """Set up test environment before each test method."""
            self.transactions = [
                Transaction(
                    sender="user1",
                    receiver="user2", 
                    action="transfer",
                    data={"amount": 10.0}
                ),
                Transaction(
                    sender="user2",
                    receiver="user3",
                    action="transfer",
                    data={"amount": 5.0}
                )
            ]
            
            self.block = Block(
                index=1,
                previous_hash="abc123",
                timestamp=datetime.now(),
                transactions=self.transactions,
                validator="node1",
                shard_id=1
            )
    
        def test_initialization(self):
            """Test block initialization with proper values."""
            self.assertEqual(self.block.index, 1)
            self.assertEqual(self.block.previous_hash, "abc123")
            self.assertEqual(self.block.validator, "node1")
            self.assertEqual(self.block.shard_id, 1)
            self.assertEqual(len(self.block.transactions), 2)
            self.assertIsNotNone(self.block.merkle_root)
    
        def test_calculate_merkle_root(self):
            """Test Merkle root calculation."""
            merkle_root = self.block.calculate_merkle_root()
            self.assertEqual(merkle_root, self.block.merkle_root)
            
            # Test with empty transactions
            empty_block = Block(
                index=0,
                previous_hash="0",
                timestamp=datetime.now(),
                transactions=[],
                validator="genesis",
                shard_id=0
            )
            self.assertIsNotNone(empty_block.merkle_root)
    
        def test_calculate_hash(self):
            """Test block hash calculation."""
            initial_hash = self.block.hash
            new_hash = self.block.calculate_hash()
            self.assertEqual(initial_hash, new_hash)
            
            # Test hash changes with different transactions
            self.block.transactions.append(
                Transaction(
                    sender="user3",
                    receiver="user4",
                    action="transfer",
                    data={"amount": 15.0}
                )
            )
            self.assertNotEqual(initial_hash, self.block.calculate_hash())
    
        def test_validate(self):
            """Test block validation logic."""
            # Create a previous block
            previous_block = Block(
                index=0,
                previous_hash="0" * 64,
                timestamp=datetime.now() - timedelta(minutes=5),
                transactions=[],
                validator="genesis",
                shard_id=1
            )
            
            # Test valid block
            self.assertTrue(self.block.validate(previous_block))
            
            # Test invalid cases
            self.block.hash = "invalid_hash"
            self.assertFalse(self.block.validate(previous_block))
            
            self.block.hash = self.block.calculate_hash()
            self.block.timestamp = datetime.now() + timedelta(hours=1)
            self.assertFalse(self.block.validate(previous_block))
    
        def test_add_transaction(self):
            """Test adding transactions to the block."""
            new_tx = Transaction(
                sender="user3",
                receiver="user4",
                action="transfer",
                data={"amount": 15.0},
                shard_id=1
            )
            
            initial_merkle_root = self.block.merkle_root
            self.assertTrue(self.block.add_transaction(new_tx))
            self.assertNotEqual(initial_merkle_root, self.block.merkle_root)
            
            # Test adding transaction with wrong shard_id
            invalid_tx = Transaction(
                sender="user4",
                receiver="user5",
                action="transfer",
                data={"amount": 20.0},
                shard_id=2
            )
            self.assertFalse(self.block.add_transaction(invalid_tx))
    
        def test_to_dict_and_from_dict(self):
            """Test converting block to dict and back."""
            block_dict = self.block.to_dict()
            new_block = Block.from_dict(block_dict)
            
            self.assertEqual(new_block.index, self.block.index)
            self.assertEqual(new_block.previous_hash, self.block.previous_hash)
            self.assertEqual(new_block.validator, self.block.validator)
            self.assertEqual(len(new_block.transactions), len(self.block.transactions))
            self.assertEqual(new_block.hash, self.block.hash)
    
    class TestNode(unittest.TestCase):
        def setUp(self):
            """Set up test environment before each test method."""
            self.node = Node(
                node_id="test_node",
                cooperative_id="test_coop",
                initial_stake=100.0
            )
    
        def test_initialization(self):
            """Test node initialization with proper values."""
            self.assertEqual(self.node.node_id, "test_node")
            self.assertEqual(self.node.cooperative_id, "test_coop")
            self.assertEqual(self.node.stake, 100.0)
            self.assertEqual(self.node.metadata["status"], "active")
            self.assertGreater(len(self.node.reputation_scores), 0)
    
        def test_update_reputation(self):
            """Test updating reputation scores."""
            category = "validation"
            initial_score = self.node.reputation_scores[category]
            
            # Test positive update
            success = self.node.update_reputation(
                category=category,
                score=5.0,
                cooperative_id="test_coop",
                evidence={"type": "successful_validation"}
            )
            self.assertTrue(success)
            self.assertEqual(self.node.reputation_scores[category], initial_score + 5.0)
            
            # Test invalid category
            success = self.node.update_reputation(
                category="invalid_category",
                score=3.0
            )
            self.assertFalse(success)
    
        def test_assign_to_shard(self):
            """Test shard assignment logic."""
            # Test successful assignment
            self.assertTrue(self.node.assign_to_shard(1))
            self.assertIn(1, self.node.shard_assignments)
            
            # Test maximum shard limit
            self.node.assign_to_shard(2)
            self.node.assign_to_shard(3)
            self.assertFalse(self.node.assign_to_shard(4))
    
        def test_can_validate(self):
            """Test validation eligibility checks."""
            # Test initial state
            self.assertTrue(self.node.can_validate())
            
            # Test cooldown period
            self.node.enter_cooldown(2)
            self.assertFalse(self.node.can_validate())
            
            # Test shard-specific validation
            self.node.assign_to_shard(1)
            self.assertTrue(self.node.can_validate(1))
            self.assertFalse(self.node.can_validate(2))
    
        def test_to_dict_from_dict(self):
            """Test converting node to dict and back."""
            node_dict = self.node.to_dict()
            restored_node = Node.from_dict(node_dict)
            
            self.assertEqual(restored_node.node_id, self.node.node_id)
            self.assertEqual(restored_node.cooperative_id, self.node.cooperative_id)
            self.assertEqual(restored_node.stake, self.node.stake)
            self.assertEqual(restored_node.reputation_scores, self.node.reputation_scores)
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_transaction.py

```py
    # tests/unit/test_transaction.py
    
    import unittest
    from datetime import datetime, timedelta
    import json
    import sys
    import os
    import hashlib
    from typing import Dict
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.core.transaction import Transaction
    
    class TestTransaction(unittest.TestCase):
        """Test cases for the Transaction class."""
    
        def setUp(self):
            """Set up test fixtures before each test method."""
            self.transaction_data = {
                "amount": 100.0,
                "fee": 1.0,
                "metadata": {"type": "transfer"}
            }
            
            self.transaction = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data.copy(),
                shard_id=1
            )
    
        def test_initialization(self):
            """Test transaction initialization and attribute setting."""
            self.assertEqual(self.transaction.sender, "sender123")
            self.assertEqual(self.transaction.receiver, "receiver456")
            self.assertEqual(self.transaction.action, "transfer")
            self.assertEqual(self.transaction.data["amount"], 100.0)
            self.assertEqual(self.transaction.shard_id, 1)
            self.assertIsNotNone(self.transaction.timestamp)
            self.assertIsNotNone(self.transaction.transaction_id)
    
        def test_invalid_initialization(self):
            """Test transaction initialization with invalid data."""
            # Test empty sender
            with self.assertRaises(ValueError):
                Transaction(
                    sender="",
                    receiver="receiver456",
                    action="transfer",
                    data=self.transaction_data,
                    shard_id=1
                )
    
            # Test empty receiver
            with self.assertRaises(ValueError):
                Transaction(
                    sender="sender123",
                    receiver="",
                    action="transfer",
                    data=self.transaction_data,
                    shard_id=1
                )
    
            # Test empty action
            with self.assertRaises(ValueError):
                Transaction(
                    sender="sender123",
                    receiver="receiver456",
                    action="",
                    data=self.transaction_data,
                    shard_id=1
                )
    
        def test_transaction_id_consistency(self):
            """Test that transaction ID remains consistent after serialization."""
            # Create two identical transactions
            tx1 = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data.copy(),
                shard_id=1
            )
            
            # Convert to dict and back
            tx_dict = tx1.to_dict()
            tx2 = Transaction.from_dict(tx_dict)
            
            # IDs should match
            self.assertEqual(tx1.transaction_id, tx2.transaction_id)
            
            # Create transaction with same data but different timestamp
            tx3 = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data.copy(),
                shard_id=1
            )
            
            # IDs should be different due to timestamp
            self.assertNotEqual(tx1.transaction_id, tx3.transaction_id)
    
        def test_validation(self):
            """Test transaction validation."""
            # Valid transaction should pass
            self.assertTrue(self.transaction.validate())
            
            # Test invalid timestamp
            tx = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data.copy(),
                shard_id=1
            )
            tx.timestamp = datetime.now() + timedelta(hours=1)
            self.assertFalse(tx.validate())
            
            # Test invalid shard_id
            tx = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=self.transaction_data.copy(),
                shard_id=-1
            )
            self.assertFalse(tx.validate())
            
            # Test invalid data type
            tx = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data="invalid_data",  # Should be dict
                shard_id=1
            )
            self.assertFalse(tx.validate())
    
        def test_serialization(self):
            """Test transaction serialization and deserialization."""
            # Convert to dictionary
            tx_dict = self.transaction.to_dict()
            
            # Verify dictionary structure
            self.assertIn("transaction_id", tx_dict)
            self.assertIn("sender", tx_dict)
            self.assertIn("receiver", tx_dict)
            self.assertIn("action", tx_dict)
            self.assertIn("data", tx_dict)
            self.assertIn("timestamp", tx_dict)
            self.assertIn("shard_id", tx_dict)
            
            # Create new transaction from dictionary
            new_tx = Transaction.from_dict(tx_dict)
            
            # Verify all attributes match
            self.assertEqual(new_tx.transaction_id, self.transaction.transaction_id)
            self.assertEqual(new_tx.sender, self.transaction.sender)
            self.assertEqual(new_tx.receiver, self.transaction.receiver)
            self.assertEqual(new_tx.action, self.transaction.action)
            self.assertEqual(new_tx.data, self.transaction.data)
            self.assertEqual(new_tx.shard_id, self.transaction.shard_id)
            self.assertEqual(new_tx.timestamp, self.transaction.timestamp)
    
        def test_hash_consistency(self):
            """Test that transaction hash calculation is consistent."""
            tx1_hash = self.transaction.calculate_hash()
            tx1_dict = self.transaction.to_dict()
            tx2 = Transaction.from_dict(tx1_dict)
            tx2_hash = tx2.calculate_hash()
            
            self.assertEqual(tx1_hash, tx2_hash)
            
            # Modify transaction and verify hash changes
            self.transaction.data["amount"] = 200.0
            self.assertNotEqual(self.transaction.calculate_hash(), tx1_hash)
    
        def test_deep_copy_data(self):
            """Test that transaction data is properly deep copied."""
            nested_data = {
                "amount": 100.0,
                "metadata": {
                    "tags": ["test", "transfer"],
                    "extra": {"note": "test transaction"}
                }
            }
            
            tx = Transaction(
                sender="sender123",
                receiver="receiver456",
                action="transfer",
                data=nested_data,
                shard_id=1
            )
            
            # Modify original data
            nested_data["metadata"]["tags"].append("modified")
            
            # Transaction data should be unchanged
            self.assertEqual(len(tx.data["metadata"]["tags"]), 2)
            self.assertNotIn("modified", tx.data["metadata"]["tags"])
    
        def test_timestamp_serialization(self):
            """Test that timestamp is properly serialized and deserialized."""
            tx_dict = self.transaction.to_dict()
            new_tx = Transaction.from_dict(tx_dict)
            
            self.assertEqual(
                self.transaction.timestamp.isoformat(),
                new_tx.timestamp.isoformat()
            )
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/test_smart_contract.py

```py
    import unittest
    from datetime import datetime, timedelta
    import sys
    import os
    from typing import Dict, Optional
    
    # Add project root to Python path
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    sys.path.insert(0, project_root)
    
    from blockchain.contracts.smart_contract import SmartContract, ContractExecutionError
    
    class TestSmartContract(unittest.TestCase):
        """Test cases for the SmartContract class."""
    
        def setUp(self):
            """Set up test fixtures before each test method."""
            self.sample_code = """
    def execute(input_data, state):
        # Simple contract that adds numbers
        a = input_data.get('a', 0)
        b = input_data.get('b', 0)
        result = a + b
        state['last_result'] = result
        return result
    """
            self.contract = SmartContract(
                contract_id="test_contract",
                code=self.sample_code,
                creator="test_creator",
                mana_cost=10,
                version="1.0"
            )
    
        def test_initialization(self):
            """Test smart contract initialization and attributes."""
            self.assertEqual(self.contract.contract_id, "test_contract")
            self.assertEqual(self.contract.creator, "test_creator")
            self.assertEqual(self.contract.mana_cost, 10)
            self.assertEqual(self.contract.version, "1.0")
            self.assertEqual(self.contract.state, {})
            self.assertEqual(self.contract.execution_count, 0)
            self.assertEqual(self.contract.total_mana_consumed, 0)
            self.assertIsNone(self.contract.last_executed)
            self.assertIn(self.contract.creator, self.contract.allowed_callers)
    
        def test_execute_valid_contract(self):
            """Test execution of a valid contract."""
            input_data = {"a": 5, "b": 3}
            result = self.contract.execute(input_data, available_mana=20)
            
            self.assertEqual(result["result"], 8)
            self.assertEqual(result["mana_used"], 10)
            self.assertEqual(self.contract.state["last_result"], 8)
            self.assertEqual(self.contract.execution_count, 1)
            self.assertEqual(self.contract.total_mana_consumed, 10)
            self.assertIsNotNone(self.contract.last_executed)
    
        def test_execute_insufficient_mana(self):
            """Test execution with insufficient mana."""
            input_data = {"a": 5, "b": 3}
            
            with self.assertRaises(ContractExecutionError) as context:
                self.contract.execute(input_data, available_mana=5)
            
            self.assertIn("Insufficient mana", str(context.exception))
            self.assertEqual(self.contract.execution_count, 0)
            self.assertEqual(self.contract.total_mana_consumed, 0)
    
        def test_execute_invalid_code(self):
            """Test execution with invalid contract code."""
            invalid_contract = SmartContract(
                contract_id="invalid_contract",
                code="def invalid_function(): return 'no execute'",
                creator="test_creator",
                mana_cost=10
            )
            
            with self.assertRaises(ContractExecutionError) as context:
                invalid_contract.execute({}, available_mana=20)
            
            self.assertIn("Contract missing execute function", str(context.exception))
    
        def test_execute_with_state_updates(self):
            """Test contract execution with state updates."""
            # First execution
            result1 = self.contract.execute({"a": 5, "b": 3}, available_mana=20)
            self.assertEqual(self.contract.state["last_result"], 8)
            
            # Second execution
            result2 = self.contract.execute({"a": 2, "b": 4}, available_mana=20)
            self.assertEqual(self.contract.state["last_result"], 6)
            
            self.assertEqual(self.contract.execution_count, 2)
            self.assertEqual(self.contract.total_mana_consumed, 20)
    
        def test_execution_limits(self):
            """Test contract execution limits."""
            # Set low daily limit for testing
            self.contract.restrictions["max_daily_executions"] = 2
            
            # First execution
            self.contract.execute({"a": 1, "b": 2}, available_mana=20)
            # Second execution
            self.contract.execute({"a": 3, "b": 4}, available_mana=20)
            
            # Third execution should fail
            with self.assertRaises(ContractExecutionError) as context:
                self.contract.execute({"a": 5, "b": 6}, available_mana=20)
            
            self.assertIn("Daily execution limit exceeded", str(context.exception))
            self.assertEqual(self.contract.execution_count, 2)
    
        def test_authorize_and_revoke_caller(self):
            """Test caller authorization management."""
            new_caller = "new_caller"
            
            # Test authorization
            self.assertTrue(self.contract.authorize_caller(new_caller))
            self.assertIn(new_caller, self.contract.allowed_callers)
            
            # Test revocation
            self.assertTrue(self.contract.revoke_caller(new_caller))
            self.assertNotIn(new_caller, self.contract.allowed_callers)
            
            # Test creator cannot be revoked
            self.assertFalse(self.contract.revoke_caller(self.contract.creator))
            self.assertIn(self.contract.creator, self.contract.allowed_callers)
    
        def test_update_restrictions(self):
            """Test updating contract restrictions."""
            new_restrictions = {
                "max_state_size": 2048,
                "max_execution_time": 10
            }
            
            self.assertTrue(self.contract.update_restrictions(new_restrictions))
            self.assertEqual(self.contract.restrictions["max_state_size"], 2048)
            self.assertEqual(self.contract.restrictions["max_execution_time"], 10)
            
            # Test invalid restriction update
            invalid_restrictions = {"invalid_key": 100}
            self.assertFalse(self.contract.update_restrictions(invalid_restrictions))
    
        def test_serialization(self):
            """Test contract serialization and deserialization."""
            # Execute contract to populate some data
            self.contract.execute({"a": 5, "b": 3}, available_mana=20)
            
            # Convert to dictionary
            contract_dict = self.contract.to_dict()
            
            # Create new contract from dictionary
            new_contract = SmartContract.from_dict(contract_dict)
            
            # Verify attributes
            self.assertEqual(new_contract.contract_id, self.contract.contract_id)
            self.assertEqual(new_contract.creator, self.contract.creator)
            self.assertEqual(new_contract.code, self.contract.code)
            self.assertEqual(new_contract.mana_cost, self.contract.mana_cost)
            self.assertEqual(new_contract.version, self.contract.version)
            self.assertEqual(new_contract.state, self.contract.state)
            self.assertEqual(new_contract.restrictions, self.contract.restrictions)
    
        def test_execution_history(self):
            """Test execution history tracking."""
            # Multiple executions
            self.contract.execute({"a": 1, "b": 2}, available_mana=20)
            self.contract.execute({"a": 3, "b": 4}, available_mana=20)
            
            # Check history
            self.assertEqual(len(self.contract.execution_history), 2)
            
            # Verify history entries
            latest_execution = self.contract.execution_history[-1]
            self.assertIn("timestamp", latest_execution)
            self.assertIn("execution_time", latest_execution)
            self.assertIn("mana_used", latest_execution)
            self.assertIn("state_size", latest_execution)
    
        def test_get_metrics(self):
            """Test contract metrics calculation."""
            # Execute contract
            self.contract.execute({"a": 5, "b": 3}, available_mana=20)
            
            metrics = self.contract.get_metrics()
            
            self.assertEqual(metrics["contract_id"], "test_contract")
            self.assertEqual(metrics["version"], "1.0")
            self.assertEqual(metrics["creator"], "test_creator")
            self.assertEqual(metrics["execution_count"], 1)
            self.assertEqual(metrics["total_mana_consumed"], 10)
            self.assertGreater(metrics["state_size"], 0)
    
        def test_state_size_limit(self):
            """Test contract state size limitations."""
            # Create contract that grows state
            growing_code = """
    def execute(input_data, state):
        # Add large data to state
        state['data'] = 'x' * input_data['size']
        return len(state['data'])
    """
            growing_contract = SmartContract(
                contract_id="growing_contract",
                code=growing_code,
                creator="test_creator",
                mana_cost=10
            )
            
            # Set small state size limit
            growing_contract.restrictions["max_state_size"] = 100
            
            # Execute with small state update
            growing_contract.execute({"size": 50}, available_mana=20)
            
            # Execute with too large state update
            with self.assertRaises(ContractExecutionError) as context:
                growing_contract.execute({"size": 200}, available_mana=20)
            
            self.assertIn("State size limit exceeded", str(context.exception))
    
        def test_dependencies(self):
            """Test contract dependency management."""
            dependency_id = "dependency_contract"
            
            # Add dependency
            self.contract.dependencies.add(dependency_id)
            self.assertIn(dependency_id, self.contract.dependencies)
            
            # Verify serialization includes dependencies
            contract_dict = self.contract.to_dict()
            self.assertIn(dependency_id, contract_dict["dependencies"])
            
            # Create new contract from dict and verify dependencies
            new_contract = SmartContract.from_dict(contract_dict)
            self.assertIn(dependency_id, new_contract.dependencies)
    
        def test_metadata_updates(self):
            """Test contract metadata management."""
            # Update metadata
            self.contract.metadata["description"] = "Test contract"
            self.contract.metadata["tags"].add("test")
            
            # Verify serialization includes metadata
            contract_dict = self.contract.to_dict()
            self.assertEqual(contract_dict["metadata"]["description"], "Test contract")
            self.assertIn("test", contract_dict["metadata"]["tags"])
            
            # Create new contract and verify metadata
            new_contract = SmartContract.from_dict(contract_dict)
            self.assertEqual(new_contract.metadata["description"], "Test contract")
            self.assertIn("test", new_contract.metadata["tags"])
    
    if __name__ == '__main__':
        unittest.main()
```

# File: /home/matt/icn-prototype/tests/unit/__init__.py

```py

```
